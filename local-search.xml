<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ARM体系架构</title>
    <link href="/2024/06/28/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/06/28/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容部分摘录自《ARM Cortex-M3 权威指南》、《ARM Cortex-M3与Cortex-M4权威指南》、《ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition》、韦东山老师的课程《深入理解ARM架构》，仅用于个人交流与学习，如涉及侵权请联系站长删除！</p></blockquote><h1 id="第一章-ARM架构版本及处理器系列介绍"><a href="#第一章-ARM架构版本及处理器系列介绍" class="headerlink" title="第一章 ARM架构版本及处理器系列介绍"></a>第一章 ARM架构版本及处理器系列介绍</h1><h2 id="1-ARM背景"><a href="#1-ARM背景" class="headerlink" title="1.ARM背景"></a>1.ARM背景</h2><p>ARM在1990年成立，当初的名字是“Advanced RISC Machines Ltd.,”，当时它是三家公司的合资——它们分别是苹果电脑，Acorn电脑公司，以及VLSI技术（公司）。</p><p>ARM的版本分为两类，一个是内核版本，一个处理器版本。</p><ul><li>内核版本也就是ARM架构，如ARMv1、ARMv2、ARMv3、ARMv4、ARMv5、ARMv6、ARMv7、ARMv8等。</li><li>处理器版本也就是ARM处理器，如ARM1、ARM9、ARM11、ARM Cortex-A（A7、A9、A15），ARM Cortex-M（M1、M3、M4）、ARM Cortex-R，这个也是我们通常意义上所指的ARM版本。</li></ul><h2 id="2-ARM架构与处理器的关系"><a href="#2-ARM架构与处理器的关系" class="headerlink" title="2.ARM架构与处理器的关系"></a>2.ARM架构与处理器的关系</h2><p>基于不同的ARM架构可以设计出不同特点的ARM处理器。比如基于ARMv3架构设计出的处理器ARM6、ARM7，这两款处理器适用于不同的场景，硬件可能不同，但是架构指令集是一样的。</p><p>举个例子，比如说盖房子，早期因为发展落后，盖的都是平房，这就是一种架构(ARMv5)，然后这种平房架构你可以设计出一款三室一厅的款式， 这叫ARM7处理器。 然后其他人(芯片设计公司)想盖房子的就买你这个款式去盖，接着过一段时间，有人觉得光三室一厅的不好， 我还想每个房间有独立卫! 于是，ARM就满足你们的要求，出个独卫的款式(ARM9)。</p><p>即ARMv5等是指令集的架构，ARM7&#x2F;9等是基于架构设计出的内核处理器。ARM的架构都是基于RISC指令集而设计的，内核处理器是实现这一指令集的硬件架构的基础。</p><h2 id="3-ARM版本"><a href="#3-ARM版本" class="headerlink" title="3.ARM版本"></a>3.ARM版本</h2><p><img src="/a.png"></p><p>最近的几年，基于从ARMv6开始的新设计理念，ARM进一步扩展了它的CPU设计，成果 就是ARMv7架构的闪亮登场。在这个版本中，内核架构首次从单一款式变成3种款式。 </p><ul><li><p>款式A：设计用于高性能的“开放应用平台”——越来越接近电脑了 </p></li><li><p>款式R：用于高端的嵌入式系统，尤其是那些带有实时要求的——又要快又要实时。 </p></li><li><p>款式M：用于深度嵌入的，单片机风格的系统中——本文章主要讲解的知识。</p></li></ul><p>让我们再进距离地考察这3种款式： </p><ul><li>款式A（ARMv7‐A）：需要运行复杂应用程序的“应用处理器” 。支持大型嵌入式操作系统，比如Symbian（诺基亚智能手机用），Linux，以及微软 的Windows CE和智能手机操作系统Windows Mobile。这些应用需要劲爆的处理性能，并 且需要硬件MMU实现的完整而强大的虚拟内存机制，还基本上会配有Java支持，有时 还要求一个安全程序执行环境。典型的产品包括高端手机和手持仪器，电子钱包以及金融事务处理机。 </li><li>款式R（ARMv7‐R）：硬实时且高性能的处理器。标的是高端实时市场。那些高级的玩意，像高档轿车的组件，大型发电机控制器，机器手臂控制器等，它们使用的处理 器不但要很好很强大，还要极其可靠，对事件的反应也要极其敏捷。 </li><li>款式M（ARMv7‐M）：认准了旧世代单片机的应用而量身定制。在这些应用中，尤其是 对于实时控制系统，低成本、低功耗、极速中断反应以及高处理效率，都是至关重要的。  Cortex系列是v7架构的第一次亮相，其中Cortex‐M3就是按款式M设计的。</li></ul><h1 id="第二章-ARM基础知识"><a href="#第二章-ARM基础知识" class="headerlink" title="第二章 ARM基础知识"></a>第二章 ARM基础知识</h1><h2 id="1-哈弗架构与冯诺伊曼架构"><a href="#1-哈弗架构与冯诺伊曼架构" class="headerlink" title="1.哈弗架构与冯诺伊曼架构"></a>1.<strong>哈弗架构与冯诺伊曼架构</strong></h2><p>CPU架构可以分为哈弗架构与冯诺伊曼架构，如下图所示。</p><ul><li><p><strong>哈弗架构</strong>中指令与数据分开存放，CPU可以同时读入指令、读写数据。</p><p><img src="/b.png"></p></li><li><p><strong>冯诺伊曼架构</strong>中指令、数据混合存放，CPU依次读取指令、读写数据，不可同时操作指令和数据。</p><p><img src="/c.png"></p></li></ul><blockquote><p>Cortex‐M3采用了哈佛结构，拥有独立的指令总线和数据总线，可以让取指与数据访问 并行不悖。</p></blockquote><h2 id="2-RISC与CISC"><a href="#2-RISC与CISC" class="headerlink" title="2. RISC与CISC"></a>2. RISC与CISC</h2><ul><li><strong>复杂指令集CISC</strong>:   以Intel、AMD的X86 CPU为代表，CISC也是要通过操作内存、寄存器、运算器来完成复杂指令的。它在实现时，是将复杂指令转换成了一个微程序，微程序在制造CPU时就已存储于微服务存储器。一个微程序包含若干条微指令（也称微码），执行复杂指令时，实际上是在执行一个微程序。这也带来两种指令集的一个差别，微程序的执行是不可被打断的，而RISC指令之间可以被打断，所以理论上RISC可更快响应中断。特点：</li><li><strong>精简指令集RISC</strong>：以ARM、IBM Power为代表，设计初衷针对CISC CPU复杂的弊端，选择一些可以在单个CPU周期完成的指令，以降低CPU的复杂度，将复杂性交给编译器</li></ul><blockquote><p><strong>ARM公司的芯片都使用RISC指令集，对内存只有load&#x2F;store操作，数据的处理是在CPU寄存器上进行。</strong></p></blockquote><ul><li>二者的比较：<ul><li>CISC的指令能力强，单多数指令使用率低却增加了CPU的复杂度，指令是可变长格式；</li><li>RISC的指令大部分为单周期指令，指令长度固定，操作寄存器，对于内存只有Load&#x2F;Store操作</li><li>CISC支持多种寻址方式；RISC支持的寻址方式</li><li>CISC通过微程序控制技术实现；</li><li>RISC增加了通用寄存器，硬布线逻辑控制为主，采用流水线</li><li>CISC的研制周期长</li><li>RISC优化编译，有效支持高级语言</li></ul></li></ul><h1 id="第三章-ARM-寄存器"><a href="#第三章-ARM-寄存器" class="headerlink" title="第三章 ARM 寄存器"></a>第三章 ARM 寄存器</h1><p>这里以Cortex‐M3 &#x2F;Cortex‐M4&#x2F;Cortex‐A7处理器为例，他们拥有 R0‐R15 的寄存器组。其中 R13 作为堆栈指针 SP。SP 有两个，但在同一 时刻只能有一个可以看到，这也就是所谓的“banked”寄存器。</p><p><img src="/image-20231021162714042.png" alt="image-20231021162714042"></p><ul><li>R0-R12：通用寄存器 ，R0‐R12 都是 32 位通用寄存器，用于数据操作。但是注意：绝大多数 16 位 Thumb 指令只能访 问 R0‐R7，而 32 位 Thumb‐2 指令可以访问所有寄存器。</li><li>Banked R13: 两个堆栈指针 <ul><li>主堆栈指针（MSP）：复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程（包 括中断服务例程） </li><li>进程堆栈指针（PSP）：由用户的应用程序代码使用。</li></ul></li><li>R14：连接寄存器，当呼叫一个子程序时，由 R14 存储返回地址 </li><li>R15：程序计数寄存器 ，指向当前的程序地址。如果修改它的值，就能改变程序的执行流</li><li>特殊功能寄存器 <ul><li>程序状态字寄存器组（PSRs）  </li><li>中断屏蔽寄存器组（PRIMASK, FAULTMASK, BASEPRI）  </li><li>控制寄存器（CONTROL）</li></ul></li></ul><p><img src="/image-20231021163136833.png" alt="image-20231021163136833"></p><p>功能如下表：</p><p><img src="/image-20231021163233661.png" alt="image-20231021163233661"></p><h1 id="第四章-ARM汇编"><a href="#第四章-ARM汇编" class="headerlink" title="第四章 ARM汇编"></a>第四章 ARM汇编</h1><h2 id="1-ARM汇编概述"><a href="#1-ARM汇编概述" class="headerlink" title="1.ARM汇编概述"></a>1.ARM汇编概述</h2><p>①最初，ARM公司发布两类指令集：</p><ul><li><p><strong>Thumb指令集：</strong>这是16位的，每条指令占据16位，节省空间</p></li><li><p><strong>ARM指令集：</strong>这是32位的，每条指令占据32位，高效，但是太占空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV R1, #1;Thumb指令：len(mov) + len(r1) + len(立即数) = 16bit<br>MOV R1, #1;ARM指令：len(mov) + len(r1) + len(立即数) = 32bit<br></code></pre></td></tr></table></figure></li></ul><p>要节省空间时用Thumb指令，要效率时用ARM指令</p><p>②一个CPU既可以运行Thumb指令，也能运行ARM指令。怎么区分当前指令是Thumb还是ARM指令呢？</p><p>​程序状态寄存器中有一位，名为“T”，它等于1时表示当前运行的是Thumb指令。</p><p>③假设函数A是使用Thumb指令写的，函数B是使用ARM指令写的，怎么调用A&#x2F;B？</p><p>​我们可以往PC寄存器里写入函数A或B的地址，就可以调用A或B，</p><p>④但是怎么让CPU在执行A函数是进入Thumb状态，在执行B函数时进入ARM状态？</p><p>​做个手脚：</p><p>​调用函数A时，让PC寄存器的BIT0等于1，即：PC&#x3D;函数A地址+(1&lt;&lt;0)；</p><p>​调用函数B时，让PC寄存器的BIT0等于0:，即：PC&#x3D;函数B地址</p><p>⑤但是这样做太麻烦，于是引入Thumb2指令集</p><ul><li><strong>Thumb2指令集：</strong>它支持16位指令、32位指令混合编程。</li></ul><h2 id="2-区分指令集"><a href="#2-区分指令集" class="headerlink" title="2.区分指令集"></a>2.区分指令集</h2><p>ARM公司推出了： Unified Assembly Language UAL，统一汇编语言，我们不需要去区分这些指令集</p><p>我们只需要在程序前面用CODE32&#x2F;CODE16&#x2F;THUMB表示指令集:ARM&#x2F;Thumb&#x2F;Thumb2</p><h2 id="3-汇编指令格式"><a href="#3-汇编指令格式" class="headerlink" title="3.汇编指令格式"></a>3.汇编指令格式</h2><blockquote><p>参考《DEN0013D_cortex_a_series_PG.pdf》P70</p><p>《ARM Cortex-M3与Cortex-M4权威指南.pdf》第5章汇编指令可以分为几大类：数据处理、内存访问、跳转、饱和运算、其他指令</p></blockquote><p>以“数据处理”指令为例，UAL汇编格式为：</p><p><img src="/image-20231021175310394.png" alt="image-20231021175310394"></p><ul><li><p>Operation表示各类汇编指令，比如ADD、MOV；</p></li><li><p>cond表示conditon，即该指令执行的条件；</p></li><li><p>S表示该指令执行后，会去修改程序状态寄存器；</p></li><li><p>Rd为目的寄存器，用来存储运算的结果；</p></li><li><p>Rn、Operand2是两个源操作数</p></li></ul><h2 id="4-常用汇编指令"><a href="#4-常用汇编指令" class="headerlink" title="4.常用汇编指令"></a>4.常用汇编指令</h2><h3 id="1-内存访问指令"><a href="#1-内存访问指令" class="headerlink" title="1.内存访问指令"></a>1.内存访问指令</h3><p>加载指令LDR：Load Register</p><p>读多个寄存器</p><p>存储指令STR：Store Register</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0X20000<br>LDR R1, =0X1234<br>STR R1,[R0]      ;将R1里面的值写入到R0指向的地址里<br><br>LDMIA R0!, &#123; R4-R11 &#125;;lrmia: ldr mutiple inc after<br>;ldr r0 [r4]   r0 = r0 + 4<br>;ldr r0 [r5]   r0 = r0 + 4<br></code></pre></td></tr></table></figure><h3 id="2-数据处理指令"><a href="#2-数据处理指令" class="headerlink" title="2.数据处理指令"></a>2.数据处理指令</h3><p>加法指令ADD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV R2,#1<br>MOV R3,#2<br>ADD R1,R2,R3;R1 = R2 + R3<br></code></pre></td></tr></table></figure><p>减法指令SUB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV R2,#1<br>MOV R3,#2<br>ADD R1,R3,R2;R1 = R3 - R2<br></code></pre></td></tr></table></figure><p>位操作指令AND&#x2F;BIC&#x2F;ORR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0XFFFFFFFF<br>AND R0,R0,#(1&lt;&lt;4);与：只保留第四位<br>LDR R0, =0XFFFFFFFF<br>BIC R0,R0,#(1&lt;&lt;4);位清除：清除第四位<br>LDR R0, =0<br>ORR R0,#(1&lt;&lt;2|1&lt;&lt;3);或：设置第2、3位为1<br></code></pre></td></tr></table></figure><p>比较指令CMP&#x2F;TST</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0X12<br>LDR R1, =0X12<br>CMP R0,R1;比较R0-R1里面的结果，结果存放在程序装载寄存器<br>MOVEQ R0, #2；如果相等，执行这条指令，R0=2<br><br>TST R0,R1;测试R0&amp;R1的结果<br></code></pre></td></tr></table></figure><h3 id="3-跳转指令"><a href="#3-跳转指令" class="headerlink" title="3.跳转指令"></a>3.跳转指令</h3><ul><li><p>B：Branch，跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">B Delay<br>Delay<br>MOV R0, #5<br>Loop<br>SUBS R0,R0,#1<br>BNE Loop;不等于0就一直循环<br>MOV PC, LR;结束，将LR值返回给PC<br></code></pre></td></tr></table></figure></li><li><p>BL：Branch with Link，跳转前先把返回地址保持在LR寄存器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">BL Delay<br>MOV R1, #1;执行完之后会直接跳转到这条指令 PC=LR+4<br>Delay<br>MOV R0, #5<br>Loop<br>SUBS R0,R0,#1<br>BNE Loop;不等于0就一直循环<br>MOV PC, LR;结束，将LR值返回给PC<br></code></pre></td></tr></table></figure></li><li><p>BX：Branch and eXchange，根据跳转地址的BIT0切换为ARM或Thumb状态(0：ARM状态，1：Thumb状态)</p></li><li><p>BLX：Branch with Link and eXchange ，根据跳转地址的BIT0切换为ARM或Thumb状态(0：ARM状态，1：Thumb状态)#</p></li></ul><h3 id="4-CPU操作指令"><a href="#4-CPU操作指令" class="headerlink" title="4.CPU操作指令"></a>4.CPU操作指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">;开启CPU接收中断<br>cpsie i<br>cpsie f<br><br>;存储器屏蔽指令:确保前面的指令和数据都处理完成<br>dsb;数据同步屏蔽<br>isb;指令同步屏蔽<br></code></pre></td></tr></table></figure><h1 id="五、异常与中断"><a href="#五、异常与中断" class="headerlink" title="五、异常与中断"></a>五、异常与中断</h1><h2 id="1-异常与中断的概念引入与处理流程"><a href="#1-异常与中断的概念引入与处理流程" class="headerlink" title="1.异常与中断的概念引入与处理流程"></a>1.异常与中断的概念引入与处理流程</h2><h3 id="1-1-使用生活实例引入中断"><a href="#1-1-使用生活实例引入中断" class="headerlink" title="1.1 使用生活实例引入中断"></a>1.1 使用生活实例引入中断</h3><p><img src="/001_mother_son.png"></p><p>假设有个大房间里面有小房间，婴儿正在睡觉，他的妈妈在外面看书。<br>问：这个母亲怎么才能知道这个小孩醒？</p><ol><li>过一会打开一次房门，看婴儿是否睡醒，然后接着看书</li><li>一直等到婴儿发出声音以后再过去查看，期间都在读书</li></ol><p>第一种方法叫做<strong>查询方式</strong>：</p><ul><li>优点：简单 </li><li>缺点： 累</li></ul><p>如何写程序？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-number">1</span> read <span class="hljs-title function_">book</span><span class="hljs-params">(读书)</span><br>2 open <span class="hljs-title function_">door</span><span class="hljs-params">(开门)</span><br>  <span class="hljs-title function_">if</span><span class="hljs-params">(小孩还在睡)</span><br> <span class="hljs-title function_">return</span><span class="hljs-params">(继续读书)</span><br>   <span class="hljs-keyword">else</span><br> 照顾小孩<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方法叫<strong>中断方式</strong>：</p><ul><li>优点：不累</li><li>缺点：复杂</li></ul><p>如何写程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>read book<br>&#125;<br>中断服务程序() <span class="hljs-comment">//核心问题：如何被调用？</span><br>&#123;<br>处理照顾小孩<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-母亲如何处理中断"><a href="#1-2-母亲如何处理中断" class="headerlink" title="1.2 母亲如何处理中断"></a>1.2 母亲如何处理中断</h3><p>我们还是看看母亲被小孩哭声打断如何照顾小孩？</p><p>母亲的处理过程</p><ul><li>平时看书</li><li>发生了各种声音，如何处理这些声音<ul><li>有远处的猫叫（听而不闻，忽略）</li><li>门铃声有快递（开门收快递）</li><li>小孩哭声（打开房门，照顾小孩）</li></ul></li><li>母亲的处理<ul><li>只会处理门铃声和小孩哭声<ul><li>先在书中放入书签，合上书(保存现场)</li><li>去处理 (调用对应的中断服务程序)</li><li>继续看书(恢复现场)</li></ul></li></ul></li></ul><p>不同情况，不同处理</p><ul><li>对于门铃：开门取快件</li><li>对于哭声:照顾小孩</li></ul><h3 id="1-3-ARM系统中异常与中断处理流程"><a href="#1-3-ARM系统中异常与中断处理流程" class="headerlink" title="1.3 ARM系统中异常与中断处理流程"></a>1.3 ARM系统中异常与中断处理流程</h3><p>我们将母亲的处理过程抽象化：</p><ul><li>母亲的头脑相当于CPU<ul><li>耳朵听到声音会发送信号给脑袋</li><li>声音来源有很多种<ul><li>有远处的猫叫，门铃声，小孩哭声</li></ul></li><li>这些声音传入耳朵，再由耳朵传给大脑</li><li>除了这些可以中断母亲的看书，还有其他情况，比如：<ul><li>身体不舒服</li><li>有只蜘蛛掉下来</li><li>对于特殊情况无法回避，必须立即处理</li></ul></li></ul></li></ul><p>对于arm系统，异常与中断的硬件框图如下：</p><p><img src="/002_exception_on_arm.png"></p><p>所有的中断源(按键、定时器等)，它们发出的中断汇聚到<strong>中断控制器</strong>，<br>再由中断控制器发信号给CPU，告诉它发生了那些紧急情况。</p><p>除了这些中断，还有什么可以打断CPU的运行？</p><ul><li>指令不对</li><li>数据访问有问题</li><li>reset信号</li><li>等等，这些都可以打断断CPU，这些被称为<strong>异常</strong></li><li>中断属于一种异常</li></ul><p>ARM系统中如何处理异常与中断？重点在于<strong>保存现场</strong>以及<strong>恢复现场</strong>，<br>处理过程如下：</p><ul><li>保存现场(各种寄存器)</li><li>处理异常(中断属于一种异常)</li><li>恢复现场</li></ul><p>细化一下，在ARM系统中如何使用异常(中断)？</p><ul><li><p>初始化</p><ul><li>设置中断源，让它可以产生中断</li><li>设置中断控制器(可以屏蔽某个中断，优先级)</li><li>设置CPU总开关，使能中断</li></ul></li><li><p>执行其他程序：正常程序</p></li><li><p>产生中断，举例：按下按键—&gt;中断控制器—&gt;CPU</p></li><li><p>cpu每执行完一条指令都会检查有无中断&#x2F;异常产生</p></li><li><p>发现有中断&#x2F;异常产生，开始处理：</p><ul><li>保存现场</li><li>分辨异常&#x2F;中断，调用对于异常&#x2F;中断的处理函数</li><li>恢复现场</li></ul></li></ul><p>不同的芯片，不同的架构，在这方面的处理稍有差别：</p><ul><li><p>保存&#x2F;恢复现场：cortex M3&#x2F;M4是硬件实现的，cortex A7是软件实现的</p></li><li><p>CPU中止当前执行，跳转去执行处理异常的代码：也有差异</p><ul><li><p>cortex M3&#x2F;M4在向量表上放置的是函数地址</p></li><li><p>cortex A7在向量表上放置的是跳转指令</p></li></ul></li></ul><h2 id="2-ARM架构中异常与中断的处理"><a href="#2-ARM架构中异常与中断的处理" class="headerlink" title="2.ARM架构中异常与中断的处理"></a>2.ARM架构中异常与中断的处理</h2><h3 id="1-1-处理流程是一样的"><a href="#1-1-处理流程是一样的" class="headerlink" title="1.1 处理流程是一样的"></a>1.1 处理流程是一样的</h3><ul><li>每执行完一条指令都会检查有无中断&#x2F;异常产生</li><li>发现有中断&#x2F;异常产生，开始处理：<ul><li>保存现场</li><li>分辨异常&#x2F;中断，调用对应的异常&#x2F;中断处理函数</li><li>恢复现场</li></ul></li></ul><p>不同的芯片，不同的架构，在这方面的处理稍有差别：</p><ul><li><p>CPU中止当前执行，跳转去执行处理异常的代码：也有差异</p><ul><li>cortex M3&#x2F;M4在向量表上放置的是函数地址</li><li>cortex A7在向量表上放置的是跳转指令</li></ul></li><li><p>保存&#x2F;恢复现场：cortex M3&#x2F;M4是硬件实现的，cortex A7是软件实现的</p></li></ul><h3 id="1-2-cortex-M3-M4"><a href="#1-2-cortex-M3-M4" class="headerlink" title="1.2 cortex M3&#x2F;M4"></a>1.2 cortex M3&#x2F;M4</h3><p>参考资料：<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>PM0056.pdf</code></p><p>要想理解这个处理流程，需要从向量表说起。<br>向量，在数学定义里是<strong>有方向的量</strong>，在程序里可以认为向量就是一个数组，里面有多个项。<br>在ARM架构里，对于异常&#x2F;中断，它们的<strong>处理入口</strong>会整齐地排放在一起。</p><h4 id="1-2-1-M3-M4的向量表"><a href="#1-2-1-M3-M4的向量表" class="headerlink" title="1.2.1 M3&#x2F;M4的向量表"></a>1.2.1 M3&#x2F;M4的向量表</h4><p>M3&#x2F;M4的向量表中，放置的是具体异常&#x2F;中断的处理函数的地址。<br>比如发生<code>Reset</code>异常时，CPU就会从向量表里找到第1项，得到Reset_Handler函数的地址，跳转去执行。<br>比如发生<code>EXTI Line 0</code>中断时，CPU就会从向量表里找到第22项，得到EXTI0_IRQHandler函数的地址，跳转去执行。</p><ul><li>跳转之前，硬件会保存现场</li><li>函数执行完毕，返回之后，硬件会恢复现场</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">; Vector Table Mapped to Address 0 at Reset</span><br>                AREA    RESET, DATA, READONLY<br>                EXPORT  __Vectors<br>                EXPORT  __Vectors_End<br>                EXPORT  __Vectors_Size<br><br>__Vectors       DCD     __initial_sp               <span class="hljs-comment">; Top of Stack</span><br>                DCD     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><br>                DCD     NMI_Handler                <span class="hljs-comment">; NMI Handler</span><br>                DCD     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                DCD     MemManage_Handler          <span class="hljs-comment">; MPU Fault Handler</span><br>                DCD     <span class="hljs-keyword">BusFault_Handler </span>          <span class="hljs-comment">; Bus Fault Handler</span><br>                DCD     UsageFault_Handler         <span class="hljs-comment">; Usage Fault Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     SVC_Handler                <span class="hljs-comment">; SVCall Handler</span><br>                DCD     DebugMon_Handler           <span class="hljs-comment">; Debug Monitor Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     PendSV_Handler             <span class="hljs-comment">; PendSV Handler</span><br>                DCD     SysTick_Handler            <span class="hljs-comment">; SysTick Handler</span><br><br>                <span class="hljs-comment">; External Interrupts</span><br>                DCD     WWDG_IRQHandler            <span class="hljs-comment">; Window Watchdog</span><br>                DCD     PVD_IRQHandler             <span class="hljs-comment">; PVD through EXTI Line detect</span><br>                DCD     TAMPER_IRQHandler          <span class="hljs-comment">; Tamper</span><br>                DCD     RTC_IRQHandler             <span class="hljs-comment">; RTC</span><br>                DCD     FLASH_IRQHandler           <span class="hljs-comment">; Flash</span><br>                DCD     RCC_IRQHandler             <span class="hljs-comment">; RCC</span><br>                DCD     <span class="hljs-keyword">EXTI0_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 0</span><br>                DCD     <span class="hljs-keyword">EXTI1_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 1</span><br>                DCD     <span class="hljs-keyword">EXTI2_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 2</span><br>                DCD     <span class="hljs-keyword">EXTI3_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 3</span><br>                DCD     <span class="hljs-keyword">EXTI4_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 4</span><br>                DCD     DMA1_Channel1_IRQHandler   <span class="hljs-comment">; DMA1 Channel 1</span><br>                DCD     DMA1_Channel2_IRQHandler   <span class="hljs-comment">; DMA1 Channel 2</span><br>                DCD     DMA1_Channel3_IRQHandler   <span class="hljs-comment">; DMA1 Channel 3</span><br>                DCD     DMA1_Channel4_IRQHandler   <span class="hljs-comment">; DMA1 Channel 4</span><br>                DCD     DMA1_Channel5_IRQHandler   <span class="hljs-comment">; DMA1 Channel 5</span><br>                DCD     DMA1_Channel6_IRQHandler   <span class="hljs-comment">; DMA1 Channel 6</span><br>                DCD     DMA1_Channel7_IRQHandler   <span class="hljs-comment">; DMA1 Channel 7</span><br>                DCD     ADC1_2_IRQHandler          <span class="hljs-comment">; ADC1 &amp; ADC2</span><br>                DCD     USB_HP_CAN1_TX_IRQHandler  <span class="hljs-comment">; USB High Priority or CAN1 TX</span><br>                DCD     USB_LP_CAN1_RX0_IRQHandler <span class="hljs-comment">; USB Low  Priority or CAN1 RX0</span><br>                DCD     CAN1_RX1_IRQHandler        <span class="hljs-comment">; CAN1 RX1</span><br>                DCD     CAN1_SCE_IRQHandler        <span class="hljs-comment">; CAN1 SCE</span><br>                DCD     <span class="hljs-keyword">EXTI9_5_IRQHandler </span>        <span class="hljs-comment">; EXTI Line 9..5</span><br>                DCD     TIM1_BRK_IRQHandler        <span class="hljs-comment">; TIM1 Break</span><br>                DCD     TIM1_UP_IRQHandler         <span class="hljs-comment">; TIM1 Update</span><br>                DCD     TIM1_TRG_COM_IRQHandler    <span class="hljs-comment">; TIM1 Trigger and Commutation</span><br>                DCD     TIM1_CC_IRQHandler         <span class="hljs-comment">; TIM1 Capture Compare</span><br>                DCD     TIM2_IRQHandler            <span class="hljs-comment">; TIM2</span><br>                DCD     TIM3_IRQHandler            <span class="hljs-comment">; TIM3</span><br>                DCD     TIM4_IRQHandler            <span class="hljs-comment">; TIM4</span><br>                DCD     I2C1_EV_IRQHandler         <span class="hljs-comment">; I2C1 Event</span><br>                DCD     I2C1_ER_IRQHandler         <span class="hljs-comment">; I2C1 Error</span><br>                DCD     I2C2_EV_IRQHandler         <span class="hljs-comment">; I2C2 Event</span><br>                DCD     I2C2_ER_IRQHandler         <span class="hljs-comment">; I2C2 Error</span><br>                DCD     SPI1_IRQHandler            <span class="hljs-comment">; SPI1</span><br>                DCD     SPI2_IRQHandler            <span class="hljs-comment">; SPI2</span><br>                DCD     USART1_IRQHandler          <span class="hljs-comment">; USART1</span><br>                DCD     USART2_IRQHandler          <span class="hljs-comment">; USART2</span><br>                DCD     USART3_IRQHandler          <span class="hljs-comment">; USART3</span><br>                DCD     <span class="hljs-keyword">EXTI15_10_IRQHandler </span>      <span class="hljs-comment">; EXTI Line 15..10</span><br>                DCD     RTCAlarm_IRQHandler        <span class="hljs-comment">; RTC Alarm through EXTI Line</span><br>                DCD     USBWakeUp_IRQHandler       <span class="hljs-comment">; USB Wakeup from suspend</span><br>                DCD     TIM8_BRK_IRQHandler        <span class="hljs-comment">; TIM8 Break</span><br>                DCD     TIM8_UP_IRQHandler         <span class="hljs-comment">; TIM8 Update</span><br>                DCD     TIM8_TRG_COM_IRQHandler    <span class="hljs-comment">; TIM8 Trigger and Commutation</span><br>                DCD     TIM8_CC_IRQHandler         <span class="hljs-comment">; TIM8 Capture Compare</span><br>                DCD     ADC3_IRQHandler            <span class="hljs-comment">; ADC3</span><br>                DCD     FSMC_IRQHandler            <span class="hljs-comment">; FSMC</span><br>                DCD     SDIO_IRQHandler            <span class="hljs-comment">; SDIO</span><br>                DCD     TIM5_IRQHandler            <span class="hljs-comment">; TIM5</span><br>                DCD     SPI3_IRQHandler            <span class="hljs-comment">; SPI3</span><br>                DCD     UART4_IRQHandler           <span class="hljs-comment">; UART4</span><br>                DCD     UART5_IRQHandler           <span class="hljs-comment">; UART5</span><br>                DCD     TIM6_IRQHandler            <span class="hljs-comment">; TIM6</span><br>                DCD     TIM7_IRQHandler            <span class="hljs-comment">; TIM7</span><br>                DCD     DMA2_Channel1_IRQHandler   <span class="hljs-comment">; DMA2 Channel1</span><br>                DCD     DMA2_Channel2_IRQHandler   <span class="hljs-comment">; DMA2 Channel2</span><br>                DCD     DMA2_Channel3_IRQHandler   <span class="hljs-comment">; DMA2 Channel3</span><br>                DCD     DMA2_Channel4_5_IRQHandler <span class="hljs-comment">; DMA2 Channel4 &amp; Channel5</span><br>__Vectors_End<br></code></pre></td></tr></table></figure><h4 id="1-2-2-M3-M4的异常-中断处理流程"><a href="#1-2-2-M3-M4的异常-中断处理流程" class="headerlink" title="1.2.2 M3&#x2F;M4的异常&#x2F;中断处理流程"></a>1.2.2 M3&#x2F;M4的异常&#x2F;中断处理流程</h4><p>发生异常&#x2F;中断时，硬件上实现了这些事情：</p><ul><li><p>保存现场：把被中断瞬间的寄存器的值保存进栈里</p></li><li><p>根据异常&#x2F;中断号，从向量表中得到<strong>函数地址</strong>，跳转过去执行</p></li><li><p>函数执行完后，从栈中恢复现场</p></li></ul><p>保存现场、分辨异常&#x2F;中断、跳转执行，都是硬件实现的。<br>我们只需要在向量表中，把处理函数的地址填进去就可以了。</p><p><strong>硬件</strong>承包了大部分的工作。</p><p>M3&#x2F;M4的向量表中，存放的是<strong>函数地址</strong>。</p><h3 id="1-3-cortex-A7"><a href="#1-3-cortex-A7" class="headerlink" title="1.3 cortex A7"></a>1.3 cortex A7</h3><p>参考资料：<code>ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf</code></p><p>实际上，以前的S3C2440属于ARM9处理器，它的异常&#x2F;中断处理流程给cortex A7是一样的。</p><h4 id="1-3-1-A7的向量表"><a href="#1-3-1-A7的向量表" class="headerlink" title="1.3.1 A7的向量表"></a>1.3.1 A7的向量表</h4><p>A7的向量表中，放置的是某类异常的<strong>跳转指令</strong>。<br>比如发生<code>Reset</code>异常时，CPU就会从向量表里找到第0项，得到<code>b reset</code>指令，执行后就跳转到reset函数。<br>比如发生任何的中断时，CPU就会从向量表里找到第6项，得到<code>ldrpc, _irq</code>指令，执行后就跳转到_irq函数。</p><ul><li>跳转之前，硬件只会保存CPSR寄存器</li><li>跳转之后，软件要保存现场</li><li>函数执行完毕，返回之前，软件恢复现场</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">_start:</span> <br>    <span class="hljs-keyword">b</span>reset<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _undefined_instruction<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _software_interrupt<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _prefetch_abort<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _data_abort<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _not_used<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _irq<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _fiq<br></code></pre></td></tr></table></figure><h4 id="1-3-2-A7的异常-中断处理流程"><a href="#1-3-2-A7的异常-中断处理流程" class="headerlink" title="1.3.2 A7的异常&#x2F;中断处理流程"></a>1.3.2 A7的异常&#x2F;中断处理流程</h4><p>发生异常&#x2F;中断时，硬件上实现了这些事情：</p><ul><li><p>CPU切换到对应的异常模式，比如IRQ模式、未定义模式、SVC模式</p></li><li><p>保存被中断时的CPSR到SPSR</p><ul><li>CPSR：current program status register，当前程序状态寄存器</li><li>SRSR：saved program status register，保存的程序状态寄存器</li></ul></li><li><p>跳到这个异常的入口地址去，执行<strong>指令</strong>，这通常是一条跳转指令</p></li></ul><p>软件要做的事情就比较多了：</p><ul><li>保存现场</li><li>分辨异常&#x2F;中断</li><li>调用对应的处理函数</li><li>恢复现场</li></ul><p>A7的向量表中，存放的是<strong>跳转指令</strong>。</p><h2 id="3-异常处理深入分析-保存现场"><a href="#3-异常处理深入分析-保存现场" class="headerlink" title="3.异常处理深入分析_保存现场"></a>3.异常处理深入分析_保存现场</h2><h3 id="1-1-回顾一下处理流程"><a href="#1-1-回顾一下处理流程" class="headerlink" title="1.1 回顾一下处理流程"></a>1.1 回顾一下处理流程</h3><p>CPU每执行完一条指令都会检查有无中断&#x2F;异常产生，发现有中断&#x2F;异常产生，开始处理：</p><ul><li>保存现场</li><li>分辨异常&#x2F;中断，调用对应的异常&#x2F;中断处理函数</li><li>恢复现场</li></ul><p>对于不用的处理器，具体的处理工作有差别：</p><ul><li>保存现场：cortex M3&#x2F;M4里是硬件完成，cortex A7等是软件实现</li><li>分辨异常&#x2F;中断：cortex M3&#x2F;M4里是硬件完成，cortex A7等是软件实现</li><li>调用处理函数：cortex M3&#x2F;M4里是硬件来调用，cortex A7等是软件自己去调用</li><li>恢复现场：cortex M3&#x2F;M4里是软件触发、硬件实现，cortex A7等是软件实现</li></ul><p>不管是硬件还是软件实现，第一步都是<strong>保存现场</strong>。</p><h3 id="1-2-为什么要保存现场"><a href="#1-2-为什么要保存现场" class="headerlink" title="1.2 为什么要保存现场"></a>1.2 为什么要保存现场</h3><p><img src="/008_save_register.png"></p><p>任何程序，最终都会转换为机器码，上述C代码可以转换为右边的汇编指令。<br>对于这4条指令，它们可能随时被异常打断，怎么保证异常处理完后，被打断的程序还能正确运行？</p><ul><li><p>这4条指令涉及R0、R1寄存器，程序被打断时、恢复运行时，R0、R1要保持不变</p></li><li><p>执行完第3条指令时，比较结果保存在<strong>程序状态寄存器</strong>里，程序被打断时、恢复运行时，程序状态寄存器保持不变</p></li><li><p>这4条指令，读取a、b内存，程序被打断时、恢复运行时，a、b内存保持不变</p></li></ul><p>内存保持不变，这很容易实现，程序不越界就可以。<br>所以，关键在于R0、R1、程序状态寄存器要保持不变(当然不止这些寄存器)：</p><ul><li>在处理异常前，把这些寄存器保存在栈中，这称为<strong>保存现场</strong></li><li>在处理完异常后，从栈中恢复这些寄存器，这称为<strong>恢复现场</strong></li></ul><h3 id="1-3-保存现场"><a href="#1-3-保存现场" class="headerlink" title="1.3 保存现场"></a>1.3 保存现场</h3><p>ARM处理器中有这些寄存器：<br><img src="/003_cpu_register.png"></p><p>在arm中有个ATPCS规则(ARM-THUMB procedure call standard（ARM-Thumb过程调用标准）。<br>约定R0-R15寄存器的用途：</p><ul><li><p>R0-R3</p><p>调用者和被调用者之间传参数</p></li><li><p>R4-R11</p><p>函数可能被使用，所以在函数的入口保存它们，在函数的出口恢复它们。</p></li></ul><p><img src="/004_atpcs.png"></p><p>还有一个<strong>程序状态寄存器</strong>，对于M3&#x2F;M4它被称为<strong>XPSR</strong>，对于A7它被称为<strong>CPSR</strong>，我们简称为PSR。<br>R0-R15、PSR，就是所谓的<strong>现场</strong>。<br>发生异常&#x2F;中断后，在处理异常&#x2F;中断前，需要<strong>保存现场</strong>，难道需要保存所有这些寄存器吗？<br>不需要！<br>在C函数中，可以修改R0-R3、R12、R14(LR)以及PSR。如果C函数要用到这些寄存器，就要把它们保存到栈里，在函数结束前在从栈中恢复它们。<br>这些寄存器被拆分成2部分：**调用者保存的寄存器(R0-R3,R12,LR,PSR)<strong>、</strong>被调用者保存的寄存器(R4-R11)**。<br>比如函数A调用函数B，函数A应该知道：</p><ul><li>R0-R3是用来传参数给函数B的</li><li>函数B可以肆意修改R0-R3</li><li>函数A不要指望函数B帮你保存R0-R3</li><li>保存R0-R3，是函数A的事情</li><li>对于LR、PSR也是同样的道理，保存它们是函数A的责任</li></ul><p>对于函数B：</p><ul><li>我用到R4-R11中的某一个，我都会在函数入口保存、在函数返回前恢复</li><li>保证在B函数调用前后，函数A看到的R4-R11保存不变</li></ul><p>假设函数B就是异常&#x2F;中断处理函数，函数B本身能保证R4-R11不变，那么保存现场时，只需要保存这些：</p><ul><li>调用者保存的寄存器(R0-R3,R12,LR,PSR)</li><li>PC</li></ul><h3 id="1-4-对于M3-M4"><a href="#1-4-对于M3-M4" class="headerlink" title="1.4 对于M3&#x2F;M4"></a>1.4 对于M3&#x2F;M4</h3><p>参考资料：<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>PM0056.pdf</code></p><h4 id="1-4-1-硬件保存现场"><a href="#1-4-1-硬件保存现场" class="headerlink" title="1.4.1 硬件保存现场"></a>1.4.1 硬件保存现场</h4><p><img src="/005_saved_register_for_exception.png"></p><h4 id="1-4-2-然后调用C函数"><a href="#1-4-2-然后调用C函数" class="headerlink" title="1.4.2 然后调用C函数"></a>1.4.2 然后调用C函数</h4><p>C函数执行完后，它返回LR所指示的位置。<br>难道把LR设置为被中断的程序的地址就行了吗？<br>如果只是返回LR所指示的地方，硬件帮我们保存在栈里的寄存器，怎么恢复？<br>M3&#x2F;M4在调用异常处理函数前，把LR设置为一个特殊的值，转给特殊的值被称为<strong>EXC_RETURN</strong>。<br>当PC寄存器的值等于<strong>EXC_RETURN</strong>时，会触发异常返回机制，简单地说：会从栈里恢复R0-R3,R12,LR,PC,PSR等寄存器。<br><strong>EXC_RETURN</strong>的值，请参考<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>，截图如下：<br><img src="/006_exc_return.png"></p><p>补充2个知识点：</p><ul><li><p>操作模式：M3&#x2F;M4有两个操作模式</p><ul><li>处理模式：执行中断服务程序等异常处理时，处于<strong>处理模式</strong></li><li>线程模式：执行普通应用程序代码时，处于<strong>线程模式</strong></li></ul></li><li><p>M3&#x2F;M4有连个SP寄存器：SP_process、SP_main</p><ul><li>有些RTOS在运行用户程序时会使用SP_process，默认使用SP_main。</li></ul></li></ul><h3 id="1-5-对于A7"><a href="#1-5-对于A7" class="headerlink" title="1.5 对于A7"></a>1.5 对于A7</h3><p>它寄存器如下：<br><img src="/007_bank_register.png"></p><p>处理器有9中模式：User、Sys、FIQ、IRQ、ABT、SVC、UND、MON、HYP。<br>上图中深色的寄存器，表示该模式下的”Banked”寄存器，比如SPSR寄存器，在很多模式下都有自己的、单独的寄存器。<br>比如IRQ模式下访问SPSR时，访问到的是IRQ模式下自己的SPSR_irq，别的模式下无法访问SPSR_irq。</p><p>比较值得关注的是FIQ模式，名为”快中断”，它有很多”Banked”寄存器：R8-R12,SP,LR。<br>在FIQ模式下，它既然能使用自己的R8-R12,SP,LR，自然不需要去保存被中断的程序的”R8-R12,SP,LR”了。<br>省去保存这几个寄存器的时间，处理中断时自然就快很多，所以被称为”FIQ”。</p><p>从上图也看到，几乎每个模式下都有自己是SP寄存器，意味着这些模式下有自己的栈。</p><p>当发生异常时，以IRQ为例：</p><ul><li>CPU会自动切换进入对应的模式，比如进入IRQ模式</li><li>并且会把被中断是的CPSR保存到SPSR_irq里</li></ul><p>所以发生异常&#x2F;中断时，在保存现场时，只需要保存：</p><ul><li>调用者保存的寄存器(R0-R3,R12,LR)</li><li>PC</li></ul><h2 id="4-实战-未定义指令异常"><a href="#4-实战-未定义指令异常" class="headerlink" title="4.实战_未定义指令异常"></a>4.实战_未定义指令异常</h2><p>参考资料：<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>PM0056.pdf</code></p><h3 id="1-1-M3-M4支持哪些异常"><a href="#1-1-M3-M4支持哪些异常" class="headerlink" title="1.1 M3_M4支持哪些异常"></a>1.1 M3_M4支持哪些异常</h3><p>从向量表可以看出，M3&#x2F;M4支持哪些异常：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">__Vectors       DCD     __initial_sp               <span class="hljs-comment">; Top of Stack</span><br>                DCD     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><br>                DCD     NMI_Handler                <span class="hljs-comment">; NMI Handler</span><br>                DCD     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                DCD     MemManage_Handler          <span class="hljs-comment">; MPU Fault Handler</span><br>                DCD     <span class="hljs-keyword">BusFault_Handler </span>          <span class="hljs-comment">; Bus Fault Handler</span><br>                DCD     UsageFault_Handler         <span class="hljs-comment">; Usage Fault Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     SVC_Handler                <span class="hljs-comment">; SVCall Handler</span><br>                DCD     DebugMon_Handler           <span class="hljs-comment">; Debug Monitor Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     PendSV_Handler             <span class="hljs-comment">; PendSV Handler</span><br>                DCD     SysTick_Handler            <span class="hljs-comment">; SysTick Handler</span><br>                <br>                <span class="hljs-comment">; External Interrupts</span><br>                DCD     WWDG_IRQHandler            <span class="hljs-comment">; Window Watchdog</span><br>                DCD     PVD_IRQHandler             <span class="hljs-comment">; PVD through EXTI Line detect   </span><br></code></pre></td></tr></table></figure><p>前面几个对应各类错误：</p><ul><li>Hard Fault</li><li>MPU Fault</li><li>Bus Fault</li><li>Usage Fault</li></ul><p>这几类错误产生的原因入下图所示，这个图来自<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>:<br><img src="/009_m3m4_fault.png"></p><p>以未定义指令为例，它属于”处理器操作相关的错误”，如果没有使能”Usage Fault”，发就会触发”Hard Fault”。</p><h3 id="1-2-什么是未定义指令？"><a href="#1-2-什么是未定义指令？" class="headerlink" title="1.2 什么是未定义指令？"></a>1.2 什么是未定义指令？</h3><p>未定义指令，即使”还没有定义的指令”，也就是CPU不认识的指令。<br>很多时候，我们故意在代码里插入一些伪造的指令，故意让CPU执行到它时触发错误。<br>这在调试时很有用，比如想打断点：怎么实现呢？<br>有很多种方法：硬件监视点(watch point，数量有限)、软件断点(数量无限)。<br>软件断点就是使用<code>未定义指令</code>来实现的，比如想让程序执行到某个地址A时停下来，可以这样做：</p><ul><li>地址A上原来的指令是<code>xxx</code></li><li>我们故意把它改成<code>yyy</code>，改成一条CPU无法识别的指令</li><li>当CPU执行到地址A上的<code>yyy</code>指令时，触发异常</li><li>在异常处理函数里，打印更多调试信息</li><li>调试完毕后，恢复地址A上的指令为<code>xxx</code></li><li>从地址A重新执行程序</li></ul><p>本节教程并不打算制作调试器，这里只是讲述一下未定义指令的作用，使用它来深入理解异常处理流程。</p><h3 id="1-3-在汇编代码里插入未定义指令"><a href="#1-3-在汇编代码里插入未定义指令" class="headerlink" title="1.3 在汇编代码里插入未定义指令"></a>1.3 在汇编代码里插入未定义指令</h3><p>在代码中插入：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">DCD</span>  <span class="hljs-number">0xffffffff</span>；在main函数之前插入<br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">PC</span>,<span class="hljs-symbol">=mymain</span><span class="hljs-comment">;绝对跳转</span><br></code></pre></td></tr></table></figure><h4 id="1-3-1-先不使能”HardFault”、”Usage-Fault”"><a href="#1-3-1-先不使能”HardFault”、”Usage-Fault”" class="headerlink" title="1.3.1 先不使能”HardFault”、”Usage Fault”"></a>1.3.1 先不使能”HardFault”、”Usage Fault”</h4><p> 结果：不会进入main函数</p><h4 id="1-3-2-使能”HardFault”"><a href="#1-3-2-使能”HardFault”" class="headerlink" title="1.3.2 使能”HardFault”"></a>1.3.2 使能”HardFault”</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">__Vectors</span><span class="hljs-meta">DCD</span>(<span class="hljs-number">0X20000000</span>+<span class="hljs-number">0X10000</span>)<span class="hljs-comment">;设置栈大小</span><br><span class="hljs-meta">DCD</span>Reset_Handler<span class="hljs-comment">;Reset_Handler 伪指令,一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化</span><br><span class="hljs-meta">DCD</span>     <span class="hljs-number">0</span>                   <span class="hljs-comment">; NMI Handler</span><br>                <span class="hljs-meta">DCD</span>     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HardFault_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;HardFault!\r\n&quot;</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：只打印异常处理函数HardFault_Handler（）里面实现的 <strong>HardFault!</strong></p><h4 id="1-3-3-使能”Usage-Fault”"><a href="#1-3-3-使能”Usage-Fault”" class="headerlink" title="1.3.3 使能”Usage Fault”"></a>1.3.3 使能”Usage Fault”</h4><ul><li><p>设置SCB寄存器的第18位，才能使能Usage Fault</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">__VectorsDCD(0X20000000+0X10000);设置栈大小<br>DCDReset_Handler;Reset_Handler 伪指令,一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化<br>DCD     0                ; NMI Handler<br>                DCD     HardFault_Handler          ; Hard Fault Handler<br>                DCD     0          ; MPU Fault Handler<br>                DCD     0           ; Bus Fault Handler<br>                DCD     UsageFault_Handler         ; Usage Fault Handler<br></code></pre></td></tr></table></figure></li><li><p>初始化UsageFault，实现对应的异常处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">UsageFaultInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>SCB_Type * SCB = (SCB_Type *)SCB_BASE_ADDR;<br>SCB-&gt;SHCSR |= (SCB_SHCSR_USGFAULTENA_Msk);  <span class="hljs-comment">//UsageFault Enable</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">UsageFault_Handler</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> * <span class="hljs-built_in">stack</span>)</span><br>&#123;<br>SCB_Type * SCB = (SCB_Type *)SCB_BASE_ADDR;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;UsageFault!\r\n&quot;</span>);<br>SCB-&gt;CFSR = SCB-&gt;CFSR;    <span class="hljs-comment">//1.清除标志位，否则会一直触发</span><br><span class="hljs-built_in">stack</span>[<span class="hljs-number">6</span>] += <span class="hljs-number">4</span>;  <span class="hljs-comment">//2.设置返回地址，指向下一条指令,否则返回之后又会执行这条指令，还是会一直触发</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果：打印异常处理函数UsageFault_Handler（）里面实现的 <strong>UsageFault!<strong>之后，紧接着</strong>进去main函数中去</strong></p></li></ul><h2 id="5-实战-SVC异常"><a href="#5-实战-SVC异常" class="headerlink" title="5.实战_SVC异常"></a>5.实战_SVC异常</h2><p>参考资料：<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>PM0056.pdf</code></p><h3 id="1-1-M3-M4支持哪些异常-1"><a href="#1-1-M3-M4支持哪些异常-1" class="headerlink" title="1.1 M3_M4支持哪些异常"></a>1.1 M3_M4支持哪些异常</h3><p>从向量表可以看出，M3&#x2F;M4支持哪些异常：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">__Vectors       DCD     __initial_sp               <span class="hljs-comment">; Top of Stack</span><br>                DCD     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><br>                DCD     NMI_Handler                <span class="hljs-comment">; NMI Handler</span><br>                DCD     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                DCD     MemManage_Handler          <span class="hljs-comment">; MPU Fault Handler</span><br>                DCD     <span class="hljs-keyword">BusFault_Handler </span>          <span class="hljs-comment">; Bus Fault Handler</span><br>                DCD     UsageFault_Handler         <span class="hljs-comment">; Usage Fault Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     SVC_Handler                <span class="hljs-comment">; SVCall Handler</span><br>                DCD     DebugMon_Handler           <span class="hljs-comment">; Debug Monitor Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     PendSV_Handler             <span class="hljs-comment">; PendSV Handler</span><br>                DCD     SysTick_Handler            <span class="hljs-comment">; SysTick Handler</span><br>                <br>                <span class="hljs-comment">; External Interrupts</span><br>                DCD     WWDG_IRQHandler            <span class="hljs-comment">; Window Watchdog</span><br>                DCD     PVD_IRQHandler             <span class="hljs-comment">; PVD through EXTI Line detect   </span><br></code></pre></td></tr></table></figure><p>在上述代码中，可以看到<code>SVC_Handler</code>，它对应SVC异常，当执行<code>SVC</code>指令时，会导致<code>SVC_Handler</code>被调用。</p><h3 id="1-2-什么是SVC指令？"><a href="#1-2-什么是SVC指令？" class="headerlink" title="1.2 什么是SVC指令？"></a>1.2 什么是SVC指令？</h3><p>在ARM指令中，有一条指令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SVC</span> <span class="hljs-comment">#VAL</span><br></code></pre></td></tr></table></figure><p>它会触发一个异常。<br>在操作系统中，比如各类RTOS或者Linux，都会使用<code>SVC</code>指令故意触发异常，从而导致内核的异常处理函数被调用，进而去使用内核的服务。<br>比如Linux中，各类文件操作的函数<code>open</code>、<code>read</code>、<code>write</code>，它的实质都是<code>SVC</code>指令。<br>本节课程不讲解<code>SVC</code>在内核中的使用，我们只是看看如何处理<code>SVC</code>触发的异常。</p><h3 id="1-3-在汇编代码里插入SVC指令"><a href="#1-3-在汇编代码里插入SVC指令" class="headerlink" title="1.3 在汇编代码里插入SVC指令"></a>1.3 在汇编代码里插入SVC指令</h3><p>在代码中插入：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SVC</span> <span class="hljs-comment">#1</span><br></code></pre></td></tr></table></figure><p>看看会发生什么事情。</p><p> 结果：只打印异常处理函数HardFault_Handler（）里面实现的 <strong>HardFault!</strong></p><h4 id="1-3-1-提供SVC异常处理函数"><a href="#1-3-1-提供SVC异常处理函数" class="headerlink" title="1.3.1 提供SVC异常处理函数"></a>1.3.1 提供SVC异常处理函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SVC_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;SVC!\r\n&quot;</span>);  <span class="hljs-comment">//执行完这条指令，会自动执行下一条指令</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果：只打印异常处理函数SVC_Handler（）里面实现的 <strong>HardFault!<strong>之后，紧接着</strong>进去main函数中去</strong></p><h2 id="6-实战-SysTick异常"><a href="#6-实战-SysTick异常" class="headerlink" title="6.实战_SysTick异常"></a>6.实战_SysTick异常</h2><p>使用CPU自带的SysTick定时器，让它产生周期性的中断，用来操作LED。</p><p>参考资料：<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>PM0056.pdf</code></p><h3 id="1-1-M3-M4支持哪些异常-2"><a href="#1-1-M3-M4支持哪些异常-2" class="headerlink" title="1.1 M3_M4支持哪些异常"></a>1.1 M3_M4支持哪些异常</h3><p>从向量表可以看出，M3&#x2F;M4支持哪些异常：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">__Vectors       DCD     __initial_sp               <span class="hljs-comment">; Top of Stack</span><br>                DCD     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><br>                DCD     NMI_Handler                <span class="hljs-comment">; NMI Handler</span><br>                DCD     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                DCD     MemManage_Handler          <span class="hljs-comment">; MPU Fault Handler</span><br>                DCD     <span class="hljs-keyword">BusFault_Handler </span>          <span class="hljs-comment">; Bus Fault Handler</span><br>                DCD     UsageFault_Handler         <span class="hljs-comment">; Usage Fault Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     SVC_Handler                <span class="hljs-comment">; SVCall Handler</span><br>                DCD     DebugMon_Handler           <span class="hljs-comment">; Debug Monitor Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     PendSV_Handler             <span class="hljs-comment">; PendSV Handler</span><br>                DCD     SysTick_Handler            <span class="hljs-comment">; SysTick Handler</span><br>                <br>                <span class="hljs-comment">; External Interrupts</span><br>                DCD     WWDG_IRQHandler            <span class="hljs-comment">; Window Watchdog</span><br>                DCD     PVD_IRQHandler             <span class="hljs-comment">; PVD through EXTI Line detect   </span><br></code></pre></td></tr></table></figure><h3 id="1-2-SysTick操作"><a href="#1-2-SysTick操作" class="headerlink" title="1.2 SysTick操作"></a>1.2 SysTick操作</h3><p>Cortex-M处理器内部集成了一个小型的、名为SysTick的定时器。可以使用它来为操作系统提供系统时钟，也可以把它当做一般的定时器。<br>之所以在处理器内增加这样的定时器，是为了提高软件的可以移植性。<br>它是一个24位的定时器，向下计数。<br>在时钟源的驱动下，计数值到达0时，可以触发异常。<br>它的框图如下：<br><img src="/010_systick.png"></p><p>在本程序中，只需要设置这几个寄存器：</p><h4 id="1-2-1-SysTick-CTRL"><a href="#1-2-1-SysTick-CTRL" class="headerlink" title="1.2.1 SysTick-&gt;CTRL"></a>1.2.1 SysTick-&gt;CTRL</h4><p>  <img src="/011_stk_ctrl.png"></p><h4 id="1-2-2-SysTick-VAL"><a href="#1-2-2-SysTick-VAL" class="headerlink" title="1.2.2 SysTick-&gt;VAL"></a>1.2.2 SysTick-&gt;VAL</h4><p><img src="/012_stk_val.png"></p><h4 id="1-2-3-SysTick-LOAD"><a href="#1-2-3-SysTick-LOAD" class="headerlink" title="1.2.3 SysTick-&gt;LOAD"></a>1.2.3 SysTick-&gt;LOAD</h4><p><img src="/013_stk_load.png"></p><h3 id="1-3-清除SysTick异常"><a href="#1-3-清除SysTick异常" class="headerlink" title="1.3 清除SysTick异常"></a>1.3 清除SysTick异常</h3><p><img src="/014_clear_systick_pending.png"></p><h1 id="第六章-操作模式和特权等级"><a href="#第六章-操作模式和特权等级" class="headerlink" title="第六章 操作模式和特权等级"></a>第六章 操作模式和特权等级</h1><h2 id="1-CPU模式和状态以及栈寄存器"><a href="#1-CPU模式和状态以及栈寄存器" class="headerlink" title="1.CPU模式和状态以及栈寄存器"></a>1.CPU模式和状态以及栈寄存器</h2><h3 id="1-模式和状态"><a href="#1-模式和状态" class="headerlink" title="1. 模式和状态"></a>1. 模式和状态</h3><h4 id="1-1-状态"><a href="#1-1-状态" class="headerlink" title="1.1 状态"></a>1.1 状态</h4><p>ARM芯片支持Thumb指令集、ARM指令集，处理器运行Thumb指令时处于Thumb状态，运行ARM指令时处于ARM状态。</p><p>CortexM3&#x2F;M4只支持Thumb指令集，所以处理器运行时只有Thumb状态。除此之外，还有一个调试状态：比如通过调试器或触发断点后，处理器就会进入调试状态并停止指令执行。</p><p>本课程不涉及调试状态，所以处理器只处于Thumb状态。</p><h4 id="1-2-模式-访问等级-栈"><a href="#1-2-模式-访问等级-栈" class="headerlink" title="1.2 模式&#x2F;访问等级&#x2F;栈"></a>1.2 模式&#x2F;访问等级&#x2F;栈</h4><p>CortexM3&#x2F;M4处理器有两种模式：</p><ul><li>处理模式：执行中断服务程序等异常处理，在处理模式下，处理器有最大权限(具有特权访问等级)</li><li>线程模式：执行普通程序。这是处理器可以处于特权访问等级，也可以处于非特权访问等级。</li></ul><p>不同模式下，处理权限可能不同，最大的不同就是：栈寄存器可能也不同。</p><p>ARM处理器的通用寄存器有R0、R1、……、R15，其中的R13也被称为SP，即栈寄存器。对于SP，它有两个实体：MSP(Main SP)、PSP(Process SP)。</p><p>在处理模式下，使用MSP，也就是说指令中使用SP时，它对应的物理寄存器是MSP。</p><p>在线程模式下，根据CONTROL寄存器的设置，处理器可能用的是MSP，也可能用的是PSP。</p><p>图示如下：</p><p><img src="/06_spsel.png" alt="image-20220326170811105"></p><p>栈寄存器的选择：</p><ul><li>① 启动时，CONTROL寄存器的SPSEL等于0，默认使用MSP。注意：启动时是线程模式，使用的仍然是MSP</li><li>② 程序可以修改CONTROL寄存器让SPSEL等于1，以使用PSP</li><li>③ 发生异常时，异常处理函数中使用的必定是MSP</li><li>④ 异常返回时，可以控制返回之后使用MSP还是PSP</li></ul><p>所谓访问等级，有两种：</p><ul><li>特权访问等级：可以访问所有寄存器、所有存储器。</li><li>非特权访问等级：无法访问某些寄存器，比如无法访问NVIC寄存器(嵌套向量中断控制器)。</li></ul><p>在一般的单片机系统中，RTOS、各类应用之间是无法隔离的：某个应用程序崩溃了，整个系统也就崩溃了。如果能让RTOS、各类应用程序彼此之间隔离开，那么可以增强系统的健壮性。这需要硬件的支持，比如需要有MPU(Memory Protection Unit)。</p><p>没有MPU时，访问等级的用处不大，只能用来限制应用程序无法访问某些寄存器。</p><h4 id="1-3-转换图"><a href="#1-3-转换图" class="headerlink" title="1.3 转换图"></a>1.3 转换图</h4><p>处理器状态和模式转换图如下：</p><p><img src="/04_mode_status.png" alt="image-20220326164725625"></p><p>注意：</p><ul><li>① 上电启动时，处理处于线程模式，处于特权访问等级</li><li>② 在特权模式下，它自然可以设置某些寄存器降低自己的等级，进入非特权访问等级</li><li>③ 在非特权模式下，无法自行提升自己的等级</li><li>④ 发生异常时，处理器进入处理模式</li><li>⑤ 在处理模式下永远都是特权访问等级</li><li>⑥ 异常放回时，可以返回到特权访问等级，也可以返回到非特权访问等级</li></ul><h4 id="1-4-CONTROL寄存器"><a href="#1-4-CONTROL寄存器" class="headerlink" title="1.4 CONTROL寄存器"></a>1.4 CONTROL寄存器</h4><p>上图中，第②那里，怎么从特权访问等级降级为非特权访问等级？通过设置CONTROL寄存器。</p><p>CONTROL寄存器定义如下：</p><ul><li>SPSEL：用来选择线程模式使用的是MSP还是PSP</li><li>nPRIV：用来设置线程模式的访问等级(特权&#x2F;非特权)</li></ul><p><img src="/07_control_reg.png" alt="image-20220326171250026"></p><p><img src="/08_control_reg_bits.png" alt="image-20220326171338515"></p><p>两种等级、两种栈，组合起来就有4种情况：</p><p><img src="/13_control_bit_table.png" alt="image-20220326162610884"></p><p>怎么读写CONTROL寄存器？使用如下汇编指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">MRS r0, CONTROL  ; 将CONTROL寄存器的值读入R0<br>MSR CONTROL, r0  ; 将R0写入CONTROL寄存器<br></code></pre></td></tr></table></figure><p><img src="/10_process_mode_switch.png" alt="image-20220326180056270"></p><h4 id="1-5-EXC-RETURN"><a href="#1-5-EXC-RETURN" class="headerlink" title="1.5 EXC_RETURN"></a>1.5 EXC_RETURN</h4><p>通过设置CONTROL寄存器，可以选择MSP或PSP，可以把特权访问等级降为非特权访问等级。</p><p>但是无法把非特权等级提升为特权访问等级，为什么？如果可以这样简单地提升等级的话，等级也就失去了意义。</p><p>线程模式下无法自行提升等级，只能借助异常处理来提升等级：</p><ul><li>在异常的处理函数中，LR等于一个特殊的值EXC_RETURN</li><li>EXC_RETURN决定里异常返回后，处理器处于什么模式、使用什么栈</li></ul><p><img src="/09_exc_return.png" alt="image-20220326174011909"></p><h3 id="2-编程"><a href="#2-编程" class="headerlink" title="2. 编程"></a>2. 编程</h3><p>调试本节程序时，在Keil自带的模拟器上调试，这样更容易看清楚。</p><p>工程需要如下设置：</p><p><img src="/01_use_emulator.png" alt="image-20220326183856624"></p><h2 id="2-提升访问等级"><a href="#2-提升访问等级" class="headerlink" title="2.提升访问等级"></a>2.提升访问等级</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="3-MSP和PSP"><a href="#3-MSP和PSP" class="headerlink" title="3.MSP和PSP"></a>3.MSP和PSP</h2>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
      <tag>汇编</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile</title>
    <link href="/2024/06/28/Makefile/"/>
    <url>/2024/06/28/Makefile/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Makefile的引入及规则"><a href="#1-Makefile的引入及规则" class="headerlink" title="1 Makefile的引入及规则"></a>1 Makefile的引入及规则</h1><p>使用keil, mdk,avr等工具开发程序时点击鼠标就可以编译了，它的内部机制是什么？它怎么组织管理程序？怎么决定编译哪一个文件？</p><p>答：实际上windows工具管理程序的内部机制，也是Makefile，我们在linux下来开发裸板程序的时候，使用Makefile组织管理这些程序，本节我们来讲解Makefile最基本的规则。Makefile要做什么事情呢？<br>组织管理程序，组织管理文件，我们写一个程序来实验一下：</p><p>文件a.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">02</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">03</span><br><span class="hljs-number">04</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>05&#123;<br><span class="hljs-number">06</span>func_b();<br><span class="hljs-number">07</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">08</span>&#125;<br></code></pre></td></tr></table></figure><p>文件b.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">2</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><span class="hljs-type">void</span> <span class="hljs-title function_">func_b</span><span class="hljs-params">()</span><br>5&#123;<br><span class="hljs-number">6</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is B\n&quot;</span>);<br><span class="hljs-number">7</span>&#125;<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -o <span class="hljs-built_in">test</span> a.c b.c<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./test<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">This is B<br></code></pre></td></tr></table></figure><p><strong>gcc -o test a.c b.c</strong>  这条命令虽然简单，但是它完成的功能不简单。</p><p>我们来看看它做了哪些事情，</p><p>我们知道.c程序  &#x3D;&#x3D;》 得到可执行程序它们之间要经过四个步骤：</p><ul><li>1.预处理</li><li>2.编译</li><li>3.汇编</li><li>4.链接</li></ul><p>我们经常把前三个步骤统称为编译了。我们具体分析：gcc -o test a.c b.c这条命令<br>它们要经过下面几个步骤：</p><ul><li>1）对于<strong>a.c</strong>：执行：预处理 编译 汇编 的过程，<strong>a.c &#x3D;&#x3D;&gt;xxx.s &#x3D;&#x3D;&gt;xxx.o</strong> 文件。</li><li>2）对于<strong>b.c</strong>：执行：预处理 编译 汇编 的过程，<strong>b.c &#x3D;&#x3D;&gt;yyy.s &#x3D;&#x3D;&gt;yyy.o</strong> 文件。</li><li>3）最后：<strong>xxx.o</strong>和<strong>yyy.o</strong>链接在一起得到一个<strong>test</strong>应用程序。</li></ul><p>提示：<strong>gcc -o test a.c b.c -v</strong> ：加上一个<strong>‘-v’</strong>选项可以看到它们的处理过程，</p><p>第一次编译 a.c 得到 xxx.o 文件，这是很合乎情理的， 执行完第一次之后，如果修改 a.c 又再次执行：<strong>gcc -o test a.c b.c</strong>，对于 a.c 应该重新生成 xxx.o，但是对于 b.c 又会重新编译一次，这完全没有必要，b.c 根本没有修改，直接使用第一次生成的 yyy.o 文件就可以了。</p><p>缺点：对所有的文件都会再处理一次，即使 b.c 没有经过修改，b.c 也会重新编译一次，当文件比较少时，这没有没有什么问题，当文件非常多的时候，就会带来非常多的效率问题如果文件非常多的时候，我们，只是修改了一个文件，所用的文件就会重新处理一次，编译的时候就会等待很长时间。</p><p>对于这些源文件，我们应该分别处理，执行：预处理 编译 汇编，先分别编译它们，最后再把它们链接在一次，比如：</p><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -o a.o a.c<br>gcc -o b.o b.c<br></code></pre></td></tr></table></figure><p>链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -o <span class="hljs-built_in">test</span> a.o b.o<br></code></pre></td></tr></table></figure><p>比如：上面的例子，当我们修改a.c之后,a.c会重现编译然后再把它们链接在一起就可以了。b.c<br>就不需要重新编译。</p><p>那么问题又来了，怎么知道哪些文件被更新了&#x2F;被修改了？</p><p>比较时间：比较 a.o 和 a.c 的时间，如果a.c的时间比 a.o 的时间更加新的话，就表明 a.c 被修改了，同理b.o和b.c也会进行同样的比较。比较test和 a.o,b.o 的时间，如果a.o或者b.o的时间比test更加新的话，就表明应该重新生成test。Makefile<br>就是这样做的。我们现在来写出一个简单的Makefile:</p><p>makefie最基本的语法是规则，规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">目标 : 依赖1 依赖2 ...<br>[TAB]命令<br></code></pre></td></tr></table></figure><p>当“依赖”比“目标”新，执行它们下面的命令。我们要把上面三个命令写成makefile规则，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span> ：a.o b.o  //test是目标，它依赖于a.o b.o文件，一旦a.o或者b.o比<span class="hljs-built_in">test</span>新的时候，<br>就需要执行下面的命令，重新生成<span class="hljs-built_in">test</span>可执行程序。<br>gcc -o <span class="hljs-built_in">test</span> a.o b.o<br>a.o : a.c  //a.o依赖于a.c，当a.c更加新的话，执行下面的命令来生成a.o<br>gcc -c -o a.o a.c<br>b.o : b.c  //b.o依赖于b.c,当b.c更加新的话，执行下面的命令，来生成b.o<br>gcc -c -o b.o b.c<br></code></pre></td></tr></table></figure><p>我们来作一下实验：</p><p>在改目录下我们写一个Makefile文件：</p><p>文件：Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">1test:a.o b.o<br>2gcc -o test a.o b.o<br>3<br>4a.o : a.c<br>5gcc -c -o a.o a.c<br>6<br>7b.o : b.c<br>8gcc -c -o b.o b.c<br></code></pre></td></tr></table></figure><p>上面是makefile中的三条规则。makefile,就是名字为“makefile”的文件。当我们想编译程序时，直接执行make命令就可以了，一执行make命令它想生成第一个目标test可执行程序,<br>如果发现a.o 或者b.o没有，就要先生成a.o或者b.o，发现a.o依赖a.c，有a.c但是没有a.o,他就会认为a.c比a.o新，就会执行它们下面的命令来生成a.o，同理b.o和b.c的处理关系也是这样的。</p><p>如果修改a.c ，我们再次执行make，它的本意是想生成第一个目标test应用程序,它需要先生成a.o,发现a.o依赖a.c(执行我们修改了a.c)发现a.c比a.o更加新，就会执行gcc -c -o a.o<br>a.c命令来生成a.o文件。b.o依赖b.c，发现b.c并没有修改，就不会执行gcc -c -o b.o<br>b.c来重新生成b.o文件。现在a.o b.o都有了，其中的a.o比test更加新，就会执行 gcc -o<br>test a.ob.o来重新链接得到test可执行程序。所以当执行make命令时候就会执行下面两条执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c -o a.o a.c<br>gcc -o <span class="hljs-built_in">test</span> a.o b.o<br></code></pre></td></tr></table></figure><p>我们第一次执行make的时候，会执行下面三条命令(三条命令都执行)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c -o a.o a.c<br>gcc -c -o b.o b.c<br>gcc -o <span class="hljs-built_in">test</span> a.o b.o<br></code></pre></td></tr></table></figure><p>再次执行make 就会显示下面的提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make: `<span class="hljs-built_in">test</span><span class="hljs-string">&#x27; is up to date.</span><br></code></pre></td></tr></table></figure><p>我们再次执行make就会判断Makefile文件中的依赖，发现依赖没有更新，所以目标文件就不会重现生成，就会有上面的提示。当我们修改a.c后，重新执行make,</p><p>就会执行下面两条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ash">gcc -c -o a.o a.c<br>gcc -o test a.o b.o<br></code></pre></td></tr></table></figure><p>我们同时修改a.c b.c，执行make就会执行下面三条指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c -o a.o a.c<br>gcc -c -o b.o b.c<br>gcc -o <span class="hljs-built_in">test</span> a.o b.o<br></code></pre></td></tr></table></figure><p>a.c文件修改了，重新编译生成a.o, b.c修改了重新编译生成b.o，a.o,b.o都更新了重新链接生成test可执行程序，makefile的规则其实还是比较简单的。规则是Makefie的核心，</p><p>执行make命令的时候，就会在当前目录下面找到名字为：Makefile的文件，根据里面的内容来执行里面的判断&#x2F;命令。</p><h1 id="2-Makefile的语法"><a href="#2-Makefile的语法" class="headerlink" title="2 Makefile的语法"></a>2 Makefile的语法</h1><p>本节我们只是简单的讲解Makefile的语法，如果想比较深入学习Makefile的话可以：</p><ul><li>a. 百度搜 “gnu make 于凤昌”。</li><li>b. 查看官方文档: <a href="http://www.gnu.org/software/make/manual/">http://www.gnu.org/software/make/manual/</a></li></ul><h2 id="a-通配符"><a href="#a-通配符" class="headerlink" title="a. 通配符"></a>a. 通配符</h2><p>假如一个目标文件所依赖的依赖文件很多，那样岂不是我们要写很多规则，这显然是不合乎常理的</p><p>我们可以使用通配符，来解决这些问题。</p><p>我们对上节程序进行修改代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>: a.o b.o <br>gcc -o <span class="hljs-built_in">test</span> $^<br><br>%.o : %.c<br>gcc -c -o <span class="hljs-variable">$@</span> $&lt;<br></code></pre></td></tr></table></figure><p>%.o：表示所用的.o文件</p><p>%.c：表示所有的.c文件</p><p>$@：表示目标</p><p>$&lt;：表示第1个依赖文件</p><p>$^：表示所有依赖文件</p><p>我们来在该目录下增加一个 c.c 文件，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>void <span class="hljs-function"><span class="hljs-title">func_c</span></span>()<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is C\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在main函数中调用修改Makefile，修改后的代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>: a.o b.o c.o<br>gcc -o <span class="hljs-built_in">test</span> $^<br><br>%.o : %.c<br>gcc -c -o <span class="hljs-variable">$@</span> $&lt;<br></code></pre></td></tr></table></figure><p>执行： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c -o a.o a.c<br>gcc -c -o b.o b.c<br>gcc -c -o c.o c.c<br>gcc -o <span class="hljs-built_in">test</span> a.o b.o c.o<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./test<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">This is B<br>This is C<br></code></pre></td></tr></table></figure><h2 id="b-假想目标-PHONY"><a href="#b-假想目标-PHONY" class="headerlink" title="b. 假想目标: .PHONY"></a>b. 假想目标: .PHONY</h2><p>1.我们想清除文件，我们在Makefile的结尾添加如下代码就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">clean:<br><span class="hljs-built_in">rm</span> *.o <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>*1）执行 make ：生成第一个可执行文件。<br>*2）执行 make clean : 清除所有文件，即执行： rm *.o test。</p><p>make后面可以带上目标名，也可以不带，如果不带目标名的话它就想生成第一个规则里面的第一个目标。</p><p>2.使用Makefile</p><p>执行：<strong>make [目标]</strong> 也可以不跟目标名，若无目标默认第一个目标。我们直接执行make的时候，会在makefile里面找到第一个目标然后执行下面的指令生成第一个目标。当我们执行 make clean 的时候，就会在 Makefile 里面找到 clean 这个目标，然后执行里面的命令，这个写法有些问题，原因是我们的目录里面没有 clean 这个文件，这个规则执行的条件成立，他就会执行下面的命令来删除文件。</p><p>如果：该目录下面有名为clean文件怎么办呢？</p><p>我们在该目录下创建一个名为 “clean” 的文件，然后重新执行：make然后make<br>clean，结果(会有下面的提示：)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make: \`clean<span class="hljs-string">&#x27; is up to date.</span><br></code></pre></td></tr></table></figure><p>它根本没有执行我们的删除操作，这是为什么呢？</p><p>我们之前说，一个规则能过执行的条件：</p><p>*1)目标文件不存在<br>*2)依赖文件比目标新</p><p>现在我们的目录里面有名为“clean”的文件，目标文件是有的，并且没有依赖文件，没有办法判断依赖文件的时间。这种写法会导致：有同名的”clean”文件时，就没有办法执行make clean操作。解决办法：我们需要把目标定义为假象目标，用关键子PHONY</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.PHONY: clean //把clean定义为假象目标。他就不会判断名为“clean”的文件是否存在，<br></code></pre></td></tr></table></figure><p>然后在Makfile结尾添加.PHONY: clean语句，重新执行：make clean，就会执行删除操作。</p><h2 id="C-变量"><a href="#C-变量" class="headerlink" title="C. 变量"></a>C. 变量</h2><p>在makefile中有两种变量：</p><p>1), 简单变量(即使变量)：</p><p>A :&#x3D; xxx    # A的值即刻确定，在定义时即确定</p><p>对于即使变量使用 “:&#x3D;” 表示，它的值在定义的时候已经被确定了</p><p>2）延时变量</p><p>B &#x3D; xxx   # B的值使用到时才确定</p><p>对于延时变量使用“&#x3D;”表示。它只有在使用到的时候才确定，在定义&#x2F;等于时并没有</p><p>确定下来。</p><p>想使用变量的时候使用“$”来引用，如果不想看到命令是，可以在命令的前面加上”@“符号，就不会显示命令本身。当我们执行make命令的时候，make这个指令本身，会把整个Makefile读进去，进行全部分析，然后解析里面的变量。常用的变量的定义如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">:= <span class="hljs-comment"># 即时变量</span><br>= <span class="hljs-comment"># 延时变量</span><br>?= <span class="hljs-comment"># 延时变量, 如果是第1次定义才起效, 如果在前面该变量已定义则忽略这句</span><br>\+= <span class="hljs-comment"># 附加, 它是即时变量还是延时变量取决于前面的定义</span><br>?=: 如果这个变量在前面已经被定义了，这句话就会不会起效果，<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">A := $(C)<br>B = $(C)<br>C = abc<br><br><span class="hljs-comment">#D = 100ask</span><br>D ?= weidongshan<br><br>all:<br>@<span class="hljs-built_in">echo</span> A = $(A)<br>@<span class="hljs-built_in">echo</span> B = $(B)<br>@<span class="hljs-built_in">echo</span> D = $(D)<br><br>C += 123<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">A =<br>B = abc 123<br>D = weidongshan<br></code></pre></td></tr></table></figure><p>分析：</p><ol><li>A :&#x3D; $(C)：</li></ol><p>A为即使变量，在定义时即确定，由于刚开始C的值为空，所以A的值也为空。</p><ol start="2"><li><p>B &#x3D; $(C)：<br>B为延时变量，只有使用到时它的值才确定，当执行make时，会解析Makefile里面的所用变量，所以先解析C&#x3D; abc,然后解析C +&#x3D; 123，此时，C &#x3D; abc 123，当执行：@echo B &#x3D; $(B) B的值为 abc 123。</p></li><li><p>D ?&#x3D; weidongshan：</p></li></ol><p>D变量在前面没有定义，所以D的值为weidongshan，如果在前面添加D &#x3D; 100ask，最后D的值为100ask。</p><p>我们还可以通过命令行存入变量的值 例如：</p><p>执行：make D&#x3D;123456 里面的 D ?&#x3D; weidongshan 这句话就不起作用了。</p><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">A =<br>B = abc 123<br>D = 123456<br></code></pre></td></tr></table></figure><h1 id="3-Makefile函数"><a href="#3-Makefile函数" class="headerlink" title="3 Makefile函数"></a>3 Makefile函数</h1><p>makefile里面可以包含很多函数，这些函数都是make本身实现的，下面我们来几个常用的函数。引用一个函数用“$”。</p><h2 id="函数foreach"><a href="#函数foreach" class="headerlink" title="函数foreach"></a>函数foreach</h2><p>函数foreach语法如下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$(foreach var,list,text) <br></code></pre></td></tr></table></figure><p>前两个参数，‘var’和‘list’，将首先扩展，注意最后一个参数 ‘text’ 此时不扩展；接着，对每一个 ‘list’ 扩展产生的字，将用来为 ‘var’ 扩展后命名的变量赋值；然后 ‘text’ 引用该变量扩展；因此它每次扩展都不相同。结果是由空格隔开的 ‘text’。在 ‘list’ 中多次扩展的字组成的新的 ‘list’。‘text’ 多次扩展的字串联起来，字与字之间由空格隔开，如此就产生了函数 foreach 的返回值。</p><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">A = a b c<br>B = $(foreach f, &amp;(A), $(f).o)<br><br>all:<br>@<span class="hljs-built_in">echo</span> B = $(B)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">B = a.o b.o c.o<br></code></pre></td></tr></table></figure><h2 id="函数filter-filter-out"><a href="#函数filter-filter-out" class="headerlink" title="函数filter&#x2F;filter-out"></a>函数filter&#x2F;filter-out</h2><p>函数filter&#x2F;filter-out语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$(filter pattern...,text)     <span class="hljs-comment"># 在text中取出符合patten格式的值</span><br>$(filter-out pattern...,text) <span class="hljs-comment"># 在text中取出不符合patten格式的值</span><br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">C = a b c d/<br><br>D = $(filter %/, $(C))<br>E = $(filter-out %/, $(C))<br><br>all:<br>        @<span class="hljs-built_in">echo</span> D = $(D)<br>        @<span class="hljs-built_in">echo</span> E = $(E)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">D = d/<br>E = a b c<br></code></pre></td></tr></table></figure><h2 id="Wildcard"><a href="#Wildcard" class="headerlink" title="Wildcard"></a>Wildcard</h2><p>函数Wildcard语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$(wildcard pattern) <span class="hljs-comment"># pattern定义了文件名的格式, wildcard取出其中存在的文件。</span><br></code></pre></td></tr></table></figure><p>这个函数 wildcard 会以 pattern 这个格式，去寻找存在的文件，返回存在文件的名字。</p><p>实例：</p><p>在该目录下创建三个文件：a.c b.c c.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">files = $(wildcard *.c)<br><br>all:<br>        @<span class="hljs-built_in">echo</span> files = $(files)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">files = a.c b.c c.c<br></code></pre></td></tr></table></figure><p>我们也可以用wildcard函数来判断，真实存在的文件</p><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">files2 = a.c b.c c.c d.c e.c  abc<br>files3 = $(wildcard $(files2))<br><br>all:<br>        @<span class="hljs-built_in">echo</span> files3 = $(files3)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">files3 = a.c b.c c.c<br></code></pre></td></tr></table></figure><h2 id="patsubst函数"><a href="#patsubst函数" class="headerlink" title="patsubst函数"></a>patsubst函数</h2><p>函数 patsubst 语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$(patsubst pattern,replacement,\$(var))<br></code></pre></td></tr></table></figure><p>patsubst 函数是从 var 变量里面取出每一个值，如果这个符合 pattern 格式，把它替换成 replacement 格式，</p><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">files2  = a.c b.c c.c d.c e.c abc<br><br>dep_files = $(patsubst %.c,%.d,$(files2))<br><br>all:<br>        @<span class="hljs-built_in">echo</span> dep_files = $(dep_files)<br><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dep_files = a.d b.d c.d d.d e.d abc<br></code></pre></td></tr></table></figure><h1 id="4-Makefile实例"><a href="#4-Makefile实例" class="headerlink" title="4 Makefile实例"></a>4 Makefile实例</h1><p>前面讲了那么多Makefile的知识，现在开始做一个实例。<br>在<code>c.c</code>里面，包含一个头文件<code>c.h</code>，在<code>c.h</code>里面定义一个宏，把这个宏打印出来。<br>c.c:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;c.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_c</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is C = %d\n&quot;</span>, C);<br>&#125;<br></code></pre></td></tr></table></figure><p>c.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> C 1</span><br></code></pre></td></tr></table></figure><p>然后上传编译，执行<code>./test</code>,打印出：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">This <span class="hljs-keyword">is</span> B<br>This <span class="hljs-keyword">is</span> C =<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>测试没有问题，然后修改<code>c.h</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> C 2</span><br></code></pre></td></tr></table></figure><p>重新编译，发现没有更新程序，运行，结果不变，说明现在的Makefile存在问题。</p><p>为什么会出现这个问题呢， 首先我们test依赖c.o，c.o依赖c.c，如果我们更新c.c，会重新更新整个程序。<br>但c.o也依赖c.h，我们更新了c.h，并没有在Makefile上体现出来，导致c.h的更新，Makefile无法检测到。<br>因此需要添加:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">c</span>.o : <span class="hljs-keyword">c</span>.<span class="hljs-keyword">c</span> <span class="hljs-keyword">c</span>.h<br></code></pre></td></tr></table></figure><p>现在每次修改c.h，Makefile都能识别到更新操作，从而更新最后输出文件。</p><p>这样又冒出了一个新的问题，我们怎么为每个.c文件添加.h文件呢？对于内核，有几万个文件，不可能为每个文件依次写出其头文件。<br>因此需要做出改进，让其自动生成头文件依赖，可以参考这篇文章：<a href="http://blog.csdn.net/qq1452008/article/details/50855810">http://blog.csdn.net/qq1452008/article/details/50855810</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -M c<span class="hljs-selector-class">.c</span> <span class="hljs-comment">// 打印出依赖</span><br><br>gcc -M -MF c<span class="hljs-selector-class">.d</span> c<span class="hljs-selector-class">.c</span>  <span class="hljs-comment">// 把依赖写入文件c.d</span><br><br>gcc -c -o c<span class="hljs-selector-class">.o</span> c<span class="hljs-selector-class">.c</span> -MD -MF c<span class="hljs-selector-class">.d</span>  <span class="hljs-comment">// 编译c.o, 把依赖写入文件c.d</span><br></code></pre></td></tr></table></figure><p>修改Makefile如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objs = a.o b.o c.o<br><br>dep_files := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %,.%.d, <span class="hljs-variable">$(objs)</span>)</span><br>dep_files := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dep_files)</span>)</span><br><br><span class="hljs-section">test: <span class="hljs-variable">$(objs)</span></span><br>gcc -o test <span class="hljs-variable">$^</span><br><br><span class="hljs-keyword">ifneq</span> (<span class="hljs-variable">$(dep_files)</span>,)<br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(dep_files)</span><br><span class="hljs-keyword">endif</span><br><br>%.o : %.c<br>gcc -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span> -MD -MF .<span class="hljs-variable">$@</span>.d<br><br><span class="hljs-section">clean:</span><br>rm *.o test<br><br><span class="hljs-section">distclean:</span><br>rm <span class="hljs-variable">$(dep_files)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br></code></pre></td></tr></table></figure><p>首先用obj变量将.o文件放在一块。<br>利用前面讲到的函数，把obj里所有文件都变为.%.d格式，并用变量dep_files表示。<br>利用前面介绍的wildcard函数，判断dep_files是否存在。<br>然后是目标文件test依赖所有的.o文件。<br>如果dep_files变量不为空，就将其包含进来。<br>然后就是所有的.o文件都依赖.c文件，且通过-MD -MF生成.d依赖文件。<br>清理所有的.o文件和目标文件<br>清理依赖.d文件。</p><p>现在我门修改了任何.h文件，最终都会影响最后生成的文件，也没任何手工添加.h、.c、.o文件，完成了支持头文件依赖。</p><p>下面再添加CFLAGS，即编译参数。比如加上编译参数-Werror，把所有的警告当成错误。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mel">CFLAGS = -Werror -Iinclude<br><br>…………<br><br><br>%.o : %.c<br>gcc $(CFLAGS) -c -o $@ $&lt; -MD -MF .$@.d<br></code></pre></td></tr></table></figure><p>现在重新make，发现以前的警告就变成了错误，必须要解决这些错误编译才能进行。在<code>a.c</code>里面声明一下函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func_b</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func_c</span>()</span>;<br></code></pre></td></tr></table></figure><p>重新make，错误就没有了。</p><p>除了编译参数-Werror，还可以加上-I参数，指定头文件路径，-Iinclude表示当前的inclue文件夹下。<br>此时就可以把c.c文件里的<code>#include &quot;.h&quot;</code>改为<code>#include &lt;c.h&gt;</code>，前者表示当前目录，后者表示编译器指定的路径和GCC路径。</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>驱动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rttread移植</title>
    <link href="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/"/>
    <url>/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1、rtthread介绍"><a href="#1、rtthread介绍" class="headerlink" title="1、rtthread介绍"></a>1、rtthread介绍</h1><ul><li>RT-Thread 是一款完全由国内团队开发维护的嵌入式实时操作系统（RTOS），具有完全的自主知识产权。经过 16 个年头的沉淀，伴随着物联网的兴起，它正演变成一个功能强大、组件丰富的物联网操作系统。</li><li>rtthread官网提供了很多个版本，针对于不同的应用情况：标准版、nano版、smart版本。我们移植的是nano版本，是一个去除了很多第三方组件的只保留操作系统的内核基本功能：线程管理、线程间通信、时钟管理、中断管理、内存管理。</li><li>支持的CPU架构有：ARM架构下的Cortex M0&#x2F; M3&#x2F; M4&#x2F; M7 等；RISC-V架构及其他。</li><li>nano版本源码也可以保留了finsh组件，让rtthread也可以像linux那样有终端界面，通过命令行来进行相应的命令操作。</li></ul><h1 id="2、rtthread源码"><a href="#2、rtthread源码" class="headerlink" title="2、rtthread源码"></a>2、rtthread源码</h1><h2 id="2-1nano版本的源码获取"><a href="#2-1nano版本的源码获取" class="headerlink" title="2&#x2F;1nano版本的源码获取"></a>2&#x2F;1nano版本的源码获取</h2><ul><li>进入官网下载界面选择nano版本下载;<a href="https://www.rt-thread.org/download.html#download-rt-thread-nano">rt-thread.org&#x2F;download.html#download-rt-thread-nano</a></li></ul><h2 id="2-2源码目录及文件分析"><a href="#2-2源码目录及文件分析" class="headerlink" title="2&#x2F;2源码目录及文件分析"></a>2&#x2F;2源码目录及文件分析</h2><ul><li>源码目录</li></ul><p><img src="/./../photo/rtt%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95.png"></p><ul><li>重点rtt内核相关文件</li></ul><p><img src="/./../photo/rttsrc%E7%9B%AE%E5%BD%95.png"></p><ul><li><p>需要移植的文件</p><ul><li><p><strong>板级支持包和rtt配置文件：bsp文件夹下面的board.c和rtconfig.h</strong></p></li><li><p><strong>可选的第三方组件；components文件夹下面的finsh组件和device驱动框架</strong></p></li><li><p><strong>include文件夹所有内容</strong></p></li><li><p><strong>libcpu文件下对应的架构文件；这里使用的是stm32h743vit6所以要移植该文件夹下的arm-&gt;cortex-m7文件夹下面的所有内容</strong></p></li><li><p><strong>src文件夹下所有内核源码</strong></p></li></ul></li></ul><h1 id="3、具体移植细节"><a href="#3、具体移植细节" class="headerlink" title="3、具体移植细节"></a>3、具体移植细节</h1><h2 id="3-1基于gcc工程的移植"><a href="#3-1基于gcc工程的移植" class="headerlink" title="3&#x2F;1基于gcc工程的移植"></a>3&#x2F;1基于gcc工程的移植</h2><ul><li>按照如下cubemx配置一个简单的gcc工程，参考另外一篇cubemx搭建工程文章。这里主要配置一些led引脚和串口1。串口1来作为finsh组件终端通信。另外这里使用的是stm32h7系列的，我们开启数据cache和指令cache</li></ul><p><img src="/./../photo/h743cache.png"></p><ul><li>stm32h743有2M的flash和1M的RAM所以堆栈可以设置大些。然后生成Makefile工程</li></ul><p><img src="/./../photo/743%E5%A0%86%E6%A0%88%E8%AE%BE%E7%BD%AE.png"></p><ul><li>创建好的工程目录如下。</li></ul><p><img src="/./../photo/743rtt-gcc.png"></p><ul><li>在目录中创建一个rtthread目录，然后将下载的nano源码全都拷贝过来，并且删除一些不必要的文件。</li></ul><p><img src="/./../photo/rtt%E5%88%A0%E9%99%A41.png"></p><p><img src="/./../photo/rtt%E5%88%A0%E9%99%A42.png"></p><p><img src="/./../photo/rtt%E5%88%A0%E9%99%A43.png"></p><p><img src="/./../photo/rtt%E5%88%A0%E9%99%A44.png"></p><ul><li>到上面，需要的文件都已经移植好了，然后修改工程里面的Makefile文件，将刚刚添加进来的c文件和h文件包含到编译依赖里面；用vscode打开刚刚新建的工程。修改Makefile文件内容。</li></ul><p><img src="/./../photo/rttmk1.png"></p><p><img src="/./../photo/rttmk2.png"></p><p><img src="/./../photo/rttmk3.png"></p><p><img src="/./../photo/rttmk4.png"></p><ul><li>然后屏蔽掉芯片原厂提供的中断文件中的三个中断。void HardFault_Handler(void)；void PendSV_Handler(void)；void SysTick_Handler(void)；因为rtthread内核实现了这三个函数。这三个函数一般在it.c文件里面定义的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief This function handles Hard fault interrupt.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HardFault_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">/* USER CODE BEGIN HardFault_IRQn 0 */</span><br><br>  <span class="hljs-comment">/* USER CODE END HardFault_IRQn 0 */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-comment">/* USER CODE BEGIN W1_HardFault_IRQn 0 */</span><br>    <span class="hljs-comment">/* USER CODE END W1_HardFault_IRQn 0 */</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief This function handles Pendable request for system service.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PendSV_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief This function handles System tick timer.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br>  HAL_IncTick();<br><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>gcc编译的话还要修改启动文件的入口函数，为什么要修改呢？修改启动文件；</li></ul><p><img src="/./../photo/rttgcc%E5%85%A5%E5%8F%A3.png"></p><p><img src="/./../photo/rttgcc%E5%90%AF%E5%8A%A8.png"></p><ul><li>rtthread启动流程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C">entry()-&gt;rtthread_startup()-&gt;<br>&#123;<br>    rt_hw_interrupt_disable();<br><br>    <span class="hljs-comment">/* board level initialization</span><br><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> please initialize heap inside board initialization.</span><br><span class="hljs-comment">     */</span><br>    rt_hw_board_init();-&gt;板级初始化<br><br>    <span class="hljs-comment">/* show RT-Thread version */</span><br>    rt_show_version();-&gt;这里的先实现串口打印功能<br><br>    <span class="hljs-comment">/* timer system initialization */</span><br>    rt_system_timer_init();<br><br>    <span class="hljs-comment">/* scheduler system initialization */</span><br>    rt_system_scheduler_init();<br><br>    <span class="hljs-comment">/* create init_thread */</span><br>    rt_application_init();-&gt;这个里面创建了一个线程；而这个线程的线程函数会调用main函数<br><br>    <span class="hljs-comment">/* timer thread initialization */</span><br>    rt_system_timer_thread_init();<br><br>    <span class="hljs-comment">/* idle thread initialization */</span><br>    rt_thread_idle_init();<br><br>    <span class="hljs-comment">/* start scheduler */</span><br>    rt_system_scheduler_start();-&gt;这里启动了调度器后，就会进入刚刚创建这个线程函数<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>至此rtthread的nano版本已经移植完了，可以在main函数里面创建不同的线程了；</li></ul><h2 id="3-2移植第三方finsh组件，来实现命令行交互"><a href="#3-2移植第三方finsh组件，来实现命令行交互" class="headerlink" title="3&#x2F;2移植第三方finsh组件，来实现命令行交互"></a>3&#x2F;2移植第三方finsh组件，来实现命令行交互</h2><ul><li><p>修改makefile，将rtthread&#x2F;components&#x2F;finsh里面的c文件和h文件都添加进编译文件里面。具体看上面怎么添加的，同理添加。</p></li><li><p>修改链接文件ld，在text段里面添加虚线之内的代码</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs ld">.text :<br>  &#123;<br>    . = ALIGN(4);<br>    *(.text)           /* .text sections (code) */<br>    *(.text*)          /* .text* sections (code) */<br>    *(.glue_7)         /* glue arm to thumb code */<br>    *(.glue_7t)        /* glue thumb to arm code */<br>    *(.eh_frame)<br><br>    KEEP (*(.init))<br>    KEEP (*(.fini))<br><br>    /*RT-thread GCC Add start---------------------------------*/    <br>    /* section information for finsh shell */<br>    . = ALIGN(4);<br>    __fsymtab_start = .;<br>    KEEP(*(FSymTab))<br>    __fsymtab_end = .;<br>    . = ALIGN(4);<br>    __vsymtab_start = .;<br>    KEEP(*(VSymTab))<br>    __vsymtab_end = .;<br>    . = ALIGN(4);<br><br>    /* section information for initial. */<br>    . = ALIGN(4);<br>    __rt_init_start = .;<br>    KEEP(*(SORT(.rti_fn*)))<br>    __rt_init_end = .;<br>    . = ALIGN(4);<br>    /* RT-thread GCC Add end ------------------------------------*/<br><br>    . = ALIGN(4);<br>    _etext = .;        /* define a global symbols at end of code */<br>  &#125; &gt;FLASH<br></code></pre></td></tr></table></figure><ul><li>实现两个函数，这两个函数都是弱定义的，即rtthread里面终端接收和发送函数。在finsh_port.c文件里面实现以下两个函数。具体还要包含相应的uart文件，这里使用的是串口1；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> <span class="hljs-title function_">rt_hw_console_getchar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> ch = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_RXNE) != RESET)<br>    &#123;<br><br>        ch = huart1.Instance-&gt;RDR &amp; <span class="hljs-number">0xff</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_ORE) != RESET)<br>        &#123;<br>            __HAL_UART_CLEAR_OREFLAG(&amp;huart1);<br>        &#125;<br>        rt_thread_mdelay(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ch;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_console_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-type">rt_size_t</span> i = <span class="hljs-number">0</span>, size = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;\r&#x27;</span>;<br><br>    __HAL_UNLOCK(&amp;huart1);<br><br>    size = rt_strlen(str);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (*(str + i) == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        &#123;<br>            HAL_UART_Transmit(&amp;huart1, (<span class="hljs-type">uint8_t</span> *)&amp;a, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>        HAL_UART_Transmit(&amp;huart1, (<span class="hljs-type">uint8_t</span> *)(str + i), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在配置文件rtconfig.h里面添加包含finsh组件的配置文件finsh_config.h;</li></ul><p><img src="/./../photo/rttfinsh1.png"></p><ul><li>屏蔽重复定义的宏，这样防止出现警告。有些在finsh_config.h里面已经宏定义过了。屏蔽掉rtconfig.h里面的相关内容。</li></ul><p><img src="/./../photo/rttfinsh2.png"></p><ul><li>第三方组件也移植好了，在终端make。生成hex文件，下载进cpu内。打开Mobaxterm建立一个串口通信。连接好串口，然后打开终端。复位cpu，可以在终端看到如下，表示移植成功。</li></ul><p><img src="/./../photo/rttfinshxterm.png" alt=""></p><ul><li>finsh常用的内置命令如下</li></ul><p><img src="/./../photo/finshcmd.png" alt=""></p><ul><li>其他kile以及IAR编译道理相同，更加简单，一样只需要添加相应c文件到工程里面，将头文件添加到IDE的搜索路径。</li></ul><h1 id="4、rtthread常用的API"><a href="#4、rtthread常用的API" class="headerlink" title="4、rtthread常用的API"></a>4、rtthread常用的API</h1><ul><li>线程管理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*线程动态创建函数*/</span><br><span class="hljs-type">rt_thread_t</span> <span class="hljs-title function_">rt_thread_create</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * name,<span class="hljs-comment">//线程的名称</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span>(*)(<span class="hljs-type">void</span> *parameter) entry,<span class="hljs-comment">//线程的入口函数</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> * parameter,<span class="hljs-comment">//入口函数的传入参数</span></span><br><span class="hljs-params">    <span class="hljs-type">rt_uint32_t</span> stack_size,<span class="hljs-comment">//线程堆栈的大小</span></span><br><span class="hljs-params">    <span class="hljs-type">rt_uint8_t</span> priority,<span class="hljs-comment">//线程的优先级</span></span><br><span class="hljs-params">    <span class="hljs-type">rt_uint32_t</span> tick <span class="hljs-comment">//线程的时间片大小。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。</span></span><br><span class="hljs-params">)</span><br>    <br><span class="hljs-comment">/*线程启动函数函数*/</span>   <br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_startup</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span><span class="hljs-comment">//参数是线程的句柄</span><br><br><span class="hljs-comment">/*线程删除函数*/</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delete</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span><br>    <br><span class="hljs-comment">/*线程挂起函数*/</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_suspend</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span><br><br><span class="hljs-comment">/*线程恢复函数*/</span>   <br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_resume</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>    <br>    <br><span class="hljs-comment">/*线程延时相关函数函数*/</span> <br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_sleep</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delay</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_mdelay</span><span class="hljs-params">(<span class="hljs-type">rt_int32_t</span> ms)</span><br></code></pre></td></tr></table></figure><ul><li>软件定时器相关函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*动态创建软件定时器*/</span><br><br><span class="hljs-type">rt_timer_t</span> <span class="hljs-title function_">rt_timer_create</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * name,<span class="hljs-comment">//定时器名称</span></span><br><span class="hljs-params"><span class="hljs-type">void</span>(*)(<span class="hljs-type">void</span> *parameter) timeout,<span class="hljs-comment">//超时回调函数</span></span><br><span class="hljs-params"><span class="hljs-type">void</span> * parameter,<span class="hljs-comment">//超时回调函数的传入参数</span></span><br><span class="hljs-params"><span class="hljs-type">rt_tick_t</span> time,<span class="hljs-comment">//定时超时时间</span></span><br><span class="hljs-params"><span class="hljs-type">rt_uint8_t</span> flag <span class="hljs-comment">//定时器的标志位</span></span><br><span class="hljs-params">)</span><br><br><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_delete</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_start</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_stop</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span><br></code></pre></td></tr></table></figure><ul><li>线程通信函数：这里有信号量、互斥量、事件、邮箱、消息队列等等。可以参考官网编程手册</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS移植</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于FreeRtos+STM32智能车载终端系统</title>
    <link href="/2023/12/05/%E5%9F%BA%E4%BA%8EFreeRtos-STM32%E6%99%BA%E8%83%BD%E8%BD%A6%E8%BD%BD%E7%BB%88%E7%AB%AF%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/12/05/%E5%9F%BA%E4%BA%8EFreeRtos-STM32%E6%99%BA%E8%83%BD%E8%BD%A6%E8%BD%BD%E7%BB%88%E7%AB%AF%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="1、项目概述"><a href="#1、项目概述" class="headerlink" title="1、项目概述"></a>1、项目概述</h1><p>​基于freertos实时操作系统加stm32完成一个智能车载终端系统。主要实现功能：车载娱乐播放、车内温湿度记录、模拟汽车启动，加速，减速；语音控制、黑匣子以及录音功能、实现人机交互，移动互联进行车内数据上云，界面设计。</p><h1 id="2、硬件目录和功能"><a href="#2、硬件目录和功能" class="headerlink" title="2、硬件目录和功能"></a>2、硬件目录和功能</h1><table><thead><tr><th align="center">器件</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">stm32f103zet6</td><td align="center">主控CPU</td></tr><tr><td align="center">VS1053模块</td><td align="center">音频解码以及录音</td></tr><tr><td align="center">DS18B20模块</td><td align="center">测量车内温度</td></tr><tr><td align="center">对射光电传感器</td><td align="center">测量车速</td></tr><tr><td align="center">AT24C64模块</td><td align="center">黑匣子存储功能</td></tr><tr><td align="center">esp8266</td><td align="center">wifi互联功能</td></tr><tr><td align="center">LD3320模块</td><td align="center">语音识别</td></tr><tr><td align="center">TFT串口屏幕</td><td align="center">车载终端界面</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32mp157启动及移植</title>
    <link href="/2023/06/16/stm32mp157%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%A7%BB%E6%A4%8D/"/>
    <url>/2023/06/16/stm32mp157%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1、stm32mp157启动方式"><a href="#1、stm32mp157启动方式" class="headerlink" title="1、stm32mp157启动方式"></a>1、stm32mp157启动方式</h1><ul><li><p>相对于MCU的启动方式，MPU的启动要复杂很多。对于MPU的芯片来说，启动方式都是大差不差，大致如下进行；看似先从启动bootloader，但是实际这个bootloader也需要运行的地方。所以大部分的芯片内部都有一小段存放厂商写好的一个裸机程序放在ROM里面，这里的ROM不是指的flash之类的。而是芯片内部的ROM，然后还有一个内部的RAM，这个不是DDR。</p></li><li><p>stm32mp1的启动方式有以下几种，根据芯片的BOOT0和BOOT1和BOOT2引脚来设置。</p><p><img src="/./../photo/157%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F.png"></p></li><li><p>我们的代码存在EMMC上面，也就是NAND Flash上面，他是非XIP设备，不能直接运行程序。因此需要把上面的代码搬运到DDR上面来运行，可是DDR不像SRAM，不用初始化就可以使用。使用前需要初始化DDR才能使用。stm32mp157里面有128K的内部ROM地址为0x00000000<del>0x00020000和256KB的内部RAM地址为0x2FFC0000</del>0x2FFFFFFF。内部的ROM存储的代码针对不同启动方式有实现不同的功能。</p><p><img src="/./../photo/157%E5%86%85%E9%83%A8ROM.png"></p><p><img src="/./../photo/157%E5%86%85%E9%83%A8RAM.png"></p></li><li><p>我们选择外部FLASH启动时候，内部ROM的功能就会执行安全启动（secure boot）；安全启动很复杂，只要CPU正常运行，就会进入冷启动，然后就从flash中加载系统，并且进行鉴权，鉴权成功才会加载内核系统。</p></li><li><p>bootloader启动分成两个阶段第一阶段启动阶段FSBL和第二启动阶段SSBL阶段。上电后内部ROM在安全启动方式下。ROM代码从选定的flash里面加载的第一段代码就是FSBL镜像，这个镜像有个要求在可执行二进制文件加一段头部信息代码。ROM读取了带头部信息的FSBL镜像后，把带头部信息的镜像拷贝到内部RAM里面运行，先对头部信息进行鉴权，鉴权成功后，头部信息保存着FSBL镜像的入口地址0x2FFC2500，头部信息大小为0x100。因此带头信息的FSBL镜像会被加载到0x2FFC2400这个地址上执行。我们可以在任意裸机程序加上头部信息就可以作为FSBL镜像了。</p></li><li><p>st公司专门做了一个添加头部信息的软件，来给二进制文件加头部，让内部代码可以鉴权成功。工具叫stm32image。可以从github下载：<a href="https://github.com/ARM-software/arm-trusted-firmware/tree/master/tools/stm32image">arm-trusted-firmware&#x2F;tools&#x2F;stm32image at master · ARM-software&#x2F;arm-trusted-firmware · GitHub</a>；下载后是一个c代码，我们需要编译一下。注意这里不是使用交叉编译工具链，是使用ubunt自带的gcc工具链</p><p><img src="/./../photo/157image.png"></p></li><li><p>在stm32mp157中启动流程是bootROM-&gt;TFA可信固件(FSBL)-&gt;uboot(SSBL)-&gt;linux-&gt;rootfs这里多出来一个TFA可信固件，主要是ARM为了针对CPU安全提出来的一种隔离方式启动，如果内部ROM鉴权失败，是不会启动后面的uboot一系列操作。</p></li><li><p>TFA源码介绍</p></li></ul><h1 id="2、SD卡移植"><a href="#2、SD卡移植" class="headerlink" title="2、SD卡移植"></a>2、SD卡移植</h1>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FAT文件系统移植</title>
    <link href="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
    <url>/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1、FAT文件系统简介"><a href="#1、FAT文件系统简介" class="headerlink" title="1、FAT文件系统简介"></a>1、FAT文件系统简介</h1><ul><li><p>FAT是一种文件格式，而FATFS是一个文件系统，为什么要文件系统呢？文件系统可以帮助我们更好的管理存储空间，另外让我们操作文件更加的简便，屏蔽掉具体实现细节，提供API函数供我们来读写，控制文件。FATFS是一个完全用C语言（ANSIC C89）编写的专为嵌入式设备设计的小型文件系统，可以很好的兼容各种硬件平台，并且支持RTOS，支持挂载最多十个存储设备。</p></li><li><p>FATFS的层次结构如下：</p><p><img src="/./../photo/fatfs%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p></li></ul><h1 id="2、移植准备"><a href="#2、移植准备" class="headerlink" title="2、移植准备"></a>2、移植准备</h1><h2 id="2-1移植文件下载及源码介绍"><a href="#2-1移植文件下载及源码介绍" class="headerlink" title="2&#x2F;1移植文件下载及源码介绍"></a>2&#x2F;1移植文件下载及源码介绍</h2><ul><li><p>官网下载fatfs的源码；官网链接:<a href="http://elm-chan.org/fsw/ff/00index_e.html;%E5%9C%A8Resources%E9%87%8C%E9%9D%A2%E4%B8%8B%E8%BD%BD%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%9B%E5%A6%82%E5%9B%BE%EF%BC%9A">http://elm-chan.org/fsw/ff/00index_e.html;在Resources里面下载源代码；如图：</a></p><p><img src="/./../photo/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%98%E7%BD%91.png"></p></li><li><p>下载后解压源码目录如下：</p><p><img src="/./../photo/fat%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95.png"></p></li><li><p>sourece目录下源码作用</p><p><img src="/./../photo/fatfs%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95.png"></p></li></ul><h2 id="2-2移植具体细节修改"><a href="#2-2移植具体细节修改" class="headerlink" title="2&#x2F;2移植具体细节修改"></a>2&#x2F;2移植具体细节修改</h2><ol><li><p>修改ffconf.h文件来配置需要的功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_MKFS1 /开启定时格式化</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_FASTSEEK1 /使能快速定位</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_LABEL1 /使能磁盘名称读取和设置</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_STRFUNC1 /使能支持字符串操作</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_CODE_PAGE936 /语言设置为GBK</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_LFN3 /支持长文件名，3表示长文件名存在堆区，通过ff_memalloc来动态分配</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_VOLUMES      2 /表示支持的逻辑存储设备数，1到10之间</span><br><span class="hljs-comment">/*这些是基础配置，更多看具体文件内说明，按需裁剪*/</span><br></code></pre></td></tr></table></figure></li><li><p>修改diskio.c文件里面的具体操作函数,修改格式可以按照diskio.c里面的格式来修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">DSTATUS <span class="hljs-title function_">disk_initialize</span> <span class="hljs-params">( BYTE pdrv)</span> /pdrv是逻辑块号<br>&#123;<br>    /相关存储设备初始化函数/<br>&#125;<br>f_mount-&gt;disk_initialize<br>    <br>DSTATUS <span class="hljs-title function_">disk_status</span> <span class="hljs-params">(BYTE pdrv)</span> <br>&#123;<br>    /读取设备状态相关的函数/<br>&#125;<br><br>DRESULT <span class="hljs-title function_">disk_read</span> <span class="hljs-params">(BYTE pdrv, BYTE *buff, DWORD sector, UINT count)</span><br>&#123;<br>    /具体的存储芯片读写函数/<br>&#125;<br>f_read-&gt;disk_read<br>    <br>DRESULT <span class="hljs-title function_">disk_write</span> <span class="hljs-params">( BYTE pdrv, <span class="hljs-type">const</span> BYTE *buff, DWORD sector, UINT count)</span><br>&#123;<br>    /具体的写函数/<br>&#125;<br><br>f_write-&gt;disk_write<br><br>DRESULT <span class="hljs-title function_">disk_ioctl</span> <span class="hljs-params">(BYTE pdrv, BYTE cmd, <span class="hljs-type">void</span> *buff)</span><br>&#123;<br>    /具体的命令控制函数/<br>&#125;<br>f_ioctl-&gt;disk_ioctl<br></code></pre></td></tr></table></figure></li></ol><h1 id="3、实例操作，挂载SD卡作为文件系统"><a href="#3、实例操作，挂载SD卡作为文件系统" class="headerlink" title="3、实例操作，挂载SD卡作为文件系统"></a>3、实例操作，挂载SD卡作为文件系统</h1><h2 id="3-1用cubemx快速生成SDMMC操作SD卡工程"><a href="#3-1用cubemx快速生成SDMMC操作SD卡工程" class="headerlink" title="3&#x2F;1用cubemx快速生成SDMMC操作SD卡工程"></a>3&#x2F;1用cubemx快速生成SDMMC操作SD卡工程</h2><ul><li><p>用cubemx快速生成一个模版文件；新建一个cubemx的工程，并且选取具体的芯片型号</p><p><img src="/./../photo/cubemx%E9%80%89%E6%8B%A9.png"></p></li><li><p>我选用的是stm32h743vit6，具体配置如下</p><p><img src="/./../photo/743%E6%97%B6%E9%92%9F%E9%80%89%E6%8B%A9.png"></p></li><li><p>时钟树配置各种外设设置</p><p><img src="/./../photo/743%E6%97%B6%E9%92%9F%E6%A0%91%E9%85%8D%E7%BD%AE.png"></p></li><li><p>配置串口一为PC通信串口，根据需求开启DMA和中断，配置波特率等等；</p><p><img src="/./../photo/743%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE.png"></p><p><img src="/./../photo/743%E6%B3%A2%E7%89%B9%E7%8E%87%E8%AE%BE%E7%BD%AE.png"></p></li><li><p>配置SDMMC参数</p><p><img src="/./../photo/743SDMMC%E9%85%8D%E7%BD%AE.png"></p></li><li><p>设置Project Manager。这里我是生成makefile工程</p><p><img src="/./../photo/743%E9%A1%B9%E7%9B%AE.png"></p><p><img src="/./../photo/743%E9%A1%B9%E7%9B%AE1.png"></p></li><li><p>用vscode打开整个生成的项目文件夹</p><p>首先进行串口一重定向，来实现c标准库里面的printf函数；找到syscalls.c文件，修改里面的_io_putchar函数；如图所示：</p><p><img src="/./../photo/743%E4%B8%B2%E5%8F%A3%E9%87%8D%E5%AE%9A%E5%90%91.png"></p><p>SDMMC初始化程序在sdmmc.c文件中,我使用的是SDMMC1这个控制器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*部分代码*/</span><br>SD_HandleTypeDef hsd1;<br><span class="hljs-type">void</span> <span class="hljs-title function_">MX_SDMMC1_SD_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  hsd1.Instance = SDMMC1;<br>  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;<br>  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;<br>  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;<br>  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_ENABLE;<br>  hsd1.Init.ClockDiv = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (HAL_SD_Init(&amp;hsd1) != HAL_OK)<br>  &#123;<br>    Error_Handler();<br>  &#125;<br>&#125;<span class="hljs-comment">//SDMMC初始程序；HAL_SD_Init这个函数内部会调用HAL_SD_MspInit；因此在Msp函数内进行相关引脚初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_SD_MspInit</span><span class="hljs-params">(SD_HandleTypeDef* sdHandle)</span><br>&#123;<br>  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;<br>  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">if</span>(sdHandle-&gt;Instance==SDMMC1)<br>  &#123;<br><br>    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SDMMC;<br>    PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;<br>    <span class="hljs-keyword">if</span> (HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInitStruct) != HAL_OK)<br>    &#123;<br>      Error_Handler();<br>    &#125;<br>    __HAL_RCC_SDMMC1_CLK_ENABLE();<br>    __HAL_RCC_GPIOC_CLK_ENABLE();<br>    __HAL_RCC_GPIOD_CLK_ENABLE();<br>    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11<br>                          |GPIO_PIN_12;<br>    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;<br>    GPIO_InitStruct.Pull = GPIO_PULLUP;<br>    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<br>    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;<br>    HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);<br><br>    GPIO_InitStruct.Pin = GPIO_PIN_2;<br>    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;<br>    GPIO_InitStruct.Pull = GPIO_PULLUP;<br>    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<br>    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;<br>    HAL_GPIO_Init(GPIOD, &amp;GPIO_InitStruct);<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>HAL库提供相关SD卡操作函数；注意SD卡读写操作都是以块为单位来操作的；SD卡本质是nand flash，所以不能把数据从0写成1，只能先擦除；先擦除，再写入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//阻塞方式读取和写入函数；</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_ReadBlocks</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd, <span class="hljs-type">uint32_t</span> NumberOfBlocks,<span class="hljs-type">uint32_t</span> Timeout)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_WriteBlocks</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd,<span class="hljs-type">uint32_t</span> NumberOfBlocks, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_Erase</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">uint32_t</span> BlockStartAdd, <span class="hljs-type">uint32_t</span> BlockEndAdd)</span>;<span class="hljs-comment">//扇区擦除函数</span><br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_ReadBlocks_IT</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd,<span class="hljs-type">uint32_t</span> NumberOfBlocks)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_WriteBlocks_IT</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd,<span class="hljs-type">uint32_t</span> NumberOfBlocks)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_ReadBlocks_DMA</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd,<span class="hljs-type">uint32_t</span> NumberOfBlocks)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_WriteBlocks_DMA</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd, <span class="hljs-type">uint32_t</span> NumberOfBlocks)</span>;<br></code></pre></td></tr></table></figure></li><li><p>写个程序测试一下，先擦除SD卡块0，擦除后，先读取看一下擦除后内容是什么；再往块0里面写入0xAB;再读取看一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">SD_test</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> BlockStartAdd, <span class="hljs-type">uint32_t</span> BlockEndAdd)</span><br>&#123; <br>  <span class="hljs-type">uint32_t</span> address=<span class="hljs-number">0</span>;<br>  <span class="hljs-type">uint8_t</span> rxbuf[<span class="hljs-number">512</span>];<br>  <span class="hljs-type">uint8_t</span> txbuf[<span class="hljs-number">512</span>];<br>  <span class="hljs-built_in">memset</span>(rxbuf,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(rxbuf));<br>  <span class="hljs-built_in">memset</span>(txbuf,<span class="hljs-number">0xAB</span>,<span class="hljs-keyword">sizeof</span>(txbuf));<br>  HAL_StatusTypeDef status =HAL_SD_Erase(&amp;hsd1,BlockStartAdd,BlockEndAdd);<br>  <span class="hljs-keyword">if</span> (status == HAL_OK)<br>   &#123;<br>      <span class="hljs-keyword">while</span> (HAL_SD_GetCardState(&amp;hsd1) != HAL_SD_CARD_TRANSFER) &#123;&#125;<br>   &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;擦除完成,等待两秒开始读取数据\r\n&quot;</span>);<br>   HAL_Delay(<span class="hljs-number">2000</span>);<br>  status=ReadSDCard(address,rxbuf,<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (status == HAL_OK)<br>   &#123;<br>      <span class="hljs-keyword">while</span> (HAL_SD_GetCardState(&amp;hsd1) != HAL_SD_CARD_TRANSFER) &#123;&#125;<br>   &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">512</span>;i++)<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;擦除后扇区读到的数据为:0x%X\r\n&quot;</span>,rxbuf[i]);<br>   &#125;<br>  HAL_Delay(<span class="hljs-number">5000</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;开始向擦除扇区写入数据&quot;</span>);<br>  status=WriteSDCard(address,txbuf,<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (status == HAL_OK)<br>   &#123;<br>      <span class="hljs-keyword">while</span> (HAL_SD_GetCardState(&amp;hsd1) != HAL_SD_CARD_TRANSFER) &#123;&#125;<br>   &#125;<br>  HAL_Delay(<span class="hljs-number">2000</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写入完成,等待两秒开始读取数据\r\n&quot;</span>); <br>  status=ReadSDCard(address,rxbuf,<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (status == HAL_OK)<br>   &#123;<br>      <span class="hljs-keyword">while</span> (HAL_SD_GetCardState(&amp;hsd1) != HAL_SD_CARD_TRANSFER) &#123;&#125;<br>   &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">512</span>;i++)<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;从新写入后扇区读到的数据为:0x%X\r\n&quot;</span>,rxbuf[i]);<br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在main函数里面调用，打开串口调试助手，选择相应端口。可以看到打印信息</p><p><img src="/./../photo/743SD%E4%B8%B2%E5%8F%A3%E6%B5%8B%E8%AF%95.png"></p><p><img src="/./../photo/743SD%E4%B8%B2%E5%8F%A3%E6%B5%8B%E8%AF%951.png"></p></li></ul><h2 id="3-2按照上述移植方法，来修改相应文件"><a href="#3-2按照上述移植方法，来修改相应文件" class="headerlink" title="3&#x2F;2按照上述移植方法，来修改相应文件"></a>3&#x2F;2按照上述移植方法，来修改相应文件</h2><ul><li><p>在cubemx来生成文件系统，按照如下配置，来增加FATfs系统。在上述SDMMC配置情况下，添加如下配置；</p><p><img src="/./../photo/743fatfs%E9%85%8D%E7%BD%AE.png"></p><p>fatfs要求有一个SD卡检测引脚，可以任选引脚作为输入，然后接地就行。</p><p><img src="/./../photo/743fat%E8%BE%93%E5%85%A5%E6%A3%80%E6%B5%8B%E5%BC%95%E8%84%9A.png"></p><p>在挂载的时候，如果出现FR_DISK_ERR这个错误，那就开启SDMMC&#x2F;SDIO的硬件流控。</p><p><img src="/./../photo/743sdmmc%E7%A1%AC%E4%BB%B6%E6%B5%81%E6%8E%A7%E5%BC%80%E5%90%AF.png"></p></li><li><p>生成代码后，修改源码，来实现上述需要的函数，打开diskio.c这个文件里面可以看到，disk_initialize、disk_status、disk_read、disk_disk_write、disk_ioctl这些函数都是调用某个结构体里面的指针数组所指向的函数；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C">DSTATUS <span class="hljs-title function_">disk_initialize</span> <span class="hljs-params">(</span><br><span class="hljs-params">BYTE pdrv<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span><br><span class="hljs-params">)</span><br>&#123;<br>  DSTATUS stat = RES_OK;<br><br>  <span class="hljs-keyword">if</span>(disk.is_initialized[pdrv] == <span class="hljs-number">0</span>)<br>  &#123;<br>    stat = disk.drv[pdrv]-&gt;disk_initialize(disk.lun[pdrv]);<br>    <span class="hljs-keyword">if</span>(stat == RES_OK)<br>    &#123;<br>      disk.is_initialized[pdrv] = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> stat;<br>&#125;<br>DSTATUS <span class="hljs-title function_">disk_status</span> <span class="hljs-params">(</span><br><span class="hljs-params">BYTE pdrv<span class="hljs-comment">/* Physical drive number to identify the drive */</span></span><br><span class="hljs-params">)</span><br>&#123;<br>  DSTATUS stat;<br><br>  stat = disk.drv[pdrv]-&gt;disk_status(disk.lun[pdrv]);<br>  <span class="hljs-keyword">return</span> stat;<br>&#125;<br>DRESULT <span class="hljs-title function_">disk_read</span> <span class="hljs-params">(</span><br><span class="hljs-params">BYTE pdrv,<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span><br><span class="hljs-params">BYTE *buff,<span class="hljs-comment">/* Data buffer to store read data */</span></span><br><span class="hljs-params">DWORD sector,        <span class="hljs-comment">/* Sector address in LBA */</span></span><br><span class="hljs-params">UINT count<span class="hljs-comment">/* Number of sectors to read */</span></span><br><span class="hljs-params">)</span><br>&#123;<br>  DRESULT res;<br><br>  res = disk.drv[pdrv]-&gt;disk_read(disk.lun[pdrv], buff, sector, count);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br>......等等函数<br></code></pre></td></tr></table></figure></li><li><p>从上面可以看到都是调用disk这个结构体里面的drv指针数组所指向的函数。disk结构体在ff_gen_drv.h这个文件下定义的；disk里面的drv结构体就是我们要实现的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">uint8_t</span>                 is_initialized[_VOLUMES];<span class="hljs-comment">//记录每个磁盘是否被初始化过</span><br>  <span class="hljs-type">const</span> Diskio_drvTypeDef *drv[_VOLUMES];<span class="hljs-comment">//指针数组，指向每个磁盘的操作函数</span><br>  <span class="hljs-type">uint8_t</span>                 lun[_VOLUMES];<span class="hljs-comment">//记录磁盘号</span><br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>        nbr;<br><br>&#125;Disk_drvTypeDef;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  DSTATUS (*disk_initialize) (BYTE);                     <span class="hljs-comment">/*!&lt; Initialize Disk Drive                     */</span><br>  DSTATUS (*disk_status)     (BYTE);                     <span class="hljs-comment">/*!&lt; Get Disk Status                           */</span><br>  DRESULT (*disk_read)       (BYTE, BYTE*, DWORD, UINT);       <span class="hljs-comment">/*!&lt; Read Sector(s)                            */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _USE_WRITE == 1</span><br>  DRESULT (*disk_write)      (BYTE, <span class="hljs-type">const</span> BYTE*, DWORD, UINT); <span class="hljs-comment">/*!&lt; Write Sector(s) when _USE_WRITE = 0       */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _USE_WRITE == 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _USE_IOCTL == 1</span><br>  DRESULT (*disk_ioctl)      (BYTE, BYTE, <span class="hljs-type">void</span>*);              <span class="hljs-comment">/*!&lt; I/O control operation when _USE_IOCTL = 1 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _USE_IOCTL == 1 */</span></span><br><br>&#125;Diskio_drvTypeDef;<br></code></pre></td></tr></table></figure></li><li><p>新建一个.c文件来实现这些函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> Diskio_drvTypeDef  SD_Driver =<br>&#123;<br>  SD_initialize,<br>  SD_status,<br>  SD_read,<br><span class="hljs-meta">#<span class="hljs-keyword">if</span>  _USE_WRITE == 1</span><br>  SD_write,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _USE_WRITE == 1 */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span>  _USE_IOCTL == 1</span><br>  SD_ioctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _USE_IOCTL == 1 */</span></span><br>&#125;;<br><span class="hljs-comment">//下面就是具体函数</span><br>DSTATUS <span class="hljs-title function_">SD_initialize</span><span class="hljs-params">(BYTE lun)</span><br>&#123;<br>Stat = STA_NOINIT;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(DISABLE_SD_INIT)</span><br><br>  <span class="hljs-keyword">if</span>(BSP_SD_Init() == MSD_OK)<br>  &#123;<br>    Stat = SD_CheckStatus(lun);<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  Stat = SD_CheckStatus(lun);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">return</span> Stat;<br>&#125;<br><br>DSTATUS <span class="hljs-title function_">SD_status</span><span class="hljs-params">(BYTE lun)</span><br>&#123;<br>  <span class="hljs-keyword">return</span> SD_CheckStatus(lun);<br>&#125;<br><br>DRESULT <span class="hljs-title function_">SD_read</span><span class="hljs-params">(BYTE lun, BYTE *buff, DWORD sector, UINT count)</span><br>&#123;<br>  DRESULT res = RES_ERROR;<br><br>  <span class="hljs-keyword">if</span>(BSP_SD_ReadBlocks((<span class="hljs-type">uint32_t</span>*)buff,<br>                       (<span class="hljs-type">uint32_t</span>) (sector),<br>                       count, SD_TIMEOUT) == MSD_OK)<br>  &#123;<br>    <span class="hljs-comment">/* wait until the read operation is finished */</span><br>    <span class="hljs-keyword">while</span>(BSP_SD_GetCardState()!= MSD_OK)<br>    &#123;<br>    &#125;<br>    res = RES_OK;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>DRESULT <span class="hljs-title function_">SD_write</span><span class="hljs-params">(BYTE lun, <span class="hljs-type">const</span> BYTE *buff, DWORD sector, UINT count)</span><br>&#123;<br>  DRESULT res = RES_ERROR;<br><br>  <span class="hljs-keyword">if</span>(BSP_SD_WriteBlocks((<span class="hljs-type">uint32_t</span>*)buff,<br>                        (<span class="hljs-type">uint32_t</span>)(sector),<br>                        count, SD_TIMEOUT) == MSD_OK)<br>  &#123;<br><span class="hljs-comment">/* wait until the Write operation is finished */</span><br>    <span class="hljs-keyword">while</span>(BSP_SD_GetCardState() != MSD_OK)<br>    &#123;<br>    &#125;<br>    res = RES_OK;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>DRESULT <span class="hljs-title function_">SD_ioctl</span><span class="hljs-params">(BYTE lun, BYTE cmd, <span class="hljs-type">void</span> *buff)</span><br>&#123;<br>  DRESULT res = RES_ERROR;<br>  BSP_SD_CardInfo CardInfo;<br><br>  <span class="hljs-keyword">if</span> (Stat &amp; STA_NOINIT) <span class="hljs-keyword">return</span> RES_NOTRDY;<br><br>  <span class="hljs-keyword">switch</span> (cmd)<br>  &#123;<br>  <span class="hljs-comment">/* Make sure that no pending write process */</span><br>  <span class="hljs-keyword">case</span> CTRL_SYNC :<br>    res = RES_OK;<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-comment">/* Get number of sectors on the disk (DWORD) */</span><br>  <span class="hljs-keyword">case</span> GET_SECTOR_COUNT :<br>    BSP_SD_GetCardInfo(&amp;CardInfo);<br>    *(DWORD*)buff = CardInfo.LogBlockNbr;<br>    res = RES_OK;<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-comment">/* Get R/W sector size (WORD) */</span><br>  <span class="hljs-keyword">case</span> GET_SECTOR_SIZE :<br>    BSP_SD_GetCardInfo(&amp;CardInfo);<br>    *(WORD*)buff = CardInfo.LogBlockSize;<br>    res = RES_OK;<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-comment">/* Get erase block size in unit of sector (DWORD) */</span><br>  <span class="hljs-keyword">case</span> GET_BLOCK_SIZE :<br>    BSP_SD_GetCardInfo(&amp;CardInfo);<br>    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;<br>    res = RES_OK;<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-keyword">default</span>:<br>    res = RES_PARERR;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>到这里可能有个疑问，FATfs调用的是disk这个结构体里面drv的函数，他怎么知道要调用哪个具体的drv指针呢。虽然我们定义了drv这个函数指针结构体，但是我们没有链接。fatfs中是如何连接呢，调用如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_FATFS_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">/*## FatFS: Link the SD driver ###########################*/</span><br>  retSD = FATFS_LinkDriver(&amp;SD_Driver, SDPath);<br>&#125;<br><span class="hljs-comment">//这个就是fatfs初始化的时候，将我们上述实现的drv结构体和磁盘号都连接到fatfs定义的disk这个结构体内了。</span><br></code></pre></td></tr></table></figure></li><li><p>到这里FATFS已经完全移植完了。我们可以另外添加各种存储设备，spi flash、emmc、USB虚拟存储设备等等都可以，只需要定义多个Diskio_drvTypeDef结构体，并且链接到系统调用的disk结构体中。</p></li></ul><h2 id="3-3测试一下移植的是否成功"><a href="#3-3测试一下移植的是否成功" class="headerlink" title="3&#x2F;3测试一下移植的是否成功"></a>3&#x2F;3测试一下移植的是否成功</h2><ul><li><p>在mian函数之前写好测试函数，并且设置好串口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C">FRESULT fres; <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FatFs_Test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>    UINT bytes_written, bytes_read;<br><br><br>    fres = f_mount(&amp;SDFatFS, SDPath, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to mount filesystem: %d\n&quot;</span>, fres);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件系统挂载成功！\r\n&quot;</span>);<br><br><br>    fres = f_open(&amp;SDFile, <span class="hljs-string">&quot;test.txt&quot;</span>, FA_CREATE_ALWAYS | FA_WRITE);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to open file: %d\n&quot;</span>, fres);<br>        f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;创建test.txt文件成功\n&quot;</span>);<br><br><br>    <span class="hljs-built_in">strcpy</span>(buffer, <span class="hljs-string">&quot;Hello, STM32H743vit6!&quot;</span>);<br>    fres = f_write(&amp;SDFile, buffer, <span class="hljs-built_in">strlen</span>(buffer), &amp;bytes_written);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK || bytes_written == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to write to file: %d\n&quot;</span>, fres);<br>        f_close(&amp;SDFile);<br>        f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写入文件成功\n&quot;</span>);<br><br><br>    f_close(&amp;SDFile);<br><br><br>    fres = f_open(&amp;SDFile, <span class="hljs-string">&quot;test.txt&quot;</span>, FA_READ);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to open file for reading: %d\n&quot;</span>, fres);<br>        f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开test.txt文件成功\n&quot;</span>);<br><br> <br>    fres = f_read(&amp;SDFile, buffer, <span class="hljs-keyword">sizeof</span>(buffer) - <span class="hljs-number">1</span>, &amp;bytes_read);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK || bytes_read == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to read from file: %d\n&quot;</span>, fres);<br>        f_close(&amp;SDFile);<br>        f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    buffer[bytes_read] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件里面的数据为: %s\n&quot;</span>, buffer);<br><br> <br>    f_close(&amp;SDFile);<br><br><br>    f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;取消挂载文件系统成功\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在main函数内调用，打开串口可以看到，然后make编译程序。如下：</p><p><img src="/./../photo/743fat%E4%B8%B2%E5%8F%A3%E6%B5%8B%E8%AF%95.png"></p></li><li><p>另外注意，如果使用了操作系统，则在应该在任务之外挂载文件系统。不然可能会导致，任务结束后，文件系统会丢失。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS总结</title>
    <link href="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1、FreeRTOS简介"><a href="#1、FreeRTOS简介" class="headerlink" title="1、FreeRTOS简介"></a>1、FreeRTOS简介</h1><h2 id="1-1嵌入式操作系统简介"><a href="#1-1嵌入式操作系统简介" class="headerlink" title="1&#x2F;1嵌入式操作系统简介"></a>1&#x2F;1嵌入式操作系统简介</h2><ul><li>操作系统是允许多个任务“同时运行”的，操作系统的这个特性被称为多任务。然而实际 上，一个 CPU 核心在某一时刻只能运行一个任务，而操作系统中任务调度器的责任就是决定在 某一时刻 CPU 究竟要运行哪一个任务，任务调度器使得 CPU 在各个任务之间来回切换并处理 任务，由于切换处理任务的速度非常快，因此就给人造成了一种同一时刻有多个任务同时运行 的错觉。</li></ul><h2 id="1-2为什么要引入FreeRTOS"><a href="#1-2为什么要引入FreeRTOS" class="headerlink" title="1&#x2F;2为什么要引入FreeRTOS"></a>1&#x2F;2为什么要引入FreeRTOS</h2><ul><li>FreeRTOS是嵌入式实时操作系统的一种，但是它具备的优点：可移植性强、可裁剪、支持多种任务通讯、同步机制、高效的软件定时器、任务数量、优先级数量不限、运行效率高、支持抢占式、合作式调度、开源、免费、可商用。功能强大，技术成熟的实时操作系统。引入实时操作系统后，可以同步处理多个任务，让CPU执行效率更高。不像裸机结构，针对某个任务需要不断查询，造成CPU资源浪费。</li></ul><h2 id="1-3如何获取FreeRTOS"><a href="#1-3如何获取FreeRTOS" class="headerlink" title="1&#x2F;3如何获取FreeRTOS"></a>1&#x2F;3如何获取FreeRTOS</h2><ul><li>FreeRTOS是用C语言编写的一个操作系统，可以在官网获取到源码。<a href="https://www.freertos.org/zh-cn-cmn-s/">FreeRTOS官网链接</a></li></ul><p>进入官网后点击下载，即可获取最新的FreeRTOS的源码，如图所示：</p><p><img src="/./../photo/%E5%AE%98%E7%BD%91%E5%9B%BE.png"></p><h2 id="1-2FreeRTOS源码目录及其介绍"><a href="#1-2FreeRTOS源码目录及其介绍" class="headerlink" title="1&#x2F;2FreeRTOS源码目录及其介绍"></a>1&#x2F;2FreeRTOS源码目录及其介绍</h2><ul><li>下载解压后，如图所示 ：</li></ul><p><img src="/./../photo/%E6%BA%90%E7%A0%81.png"></p><ul><li><p>源码目录内容介绍：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs DTS">├─FreeRTOS<br>│  ├─Demo<span class="hljs-comment">// 各种开发工具的完整Demo，开发者可以方便的以此搭建出自己的项目，甚至直接使用</span><br>│  │  ├─Common<span class="hljs-comment">// 所有例程都可以使用的演示例程文件</span><br>│  │  └─其他<span class="hljs-comment">// 对应平台和开发工具的项目例程（命名：平台_开发工具，例如：CORTEX_M4F_M0_LPC43xx_Keil）</span><br>│  ├─License<span class="hljs-comment">// 使用修改过的 GPL</span><br>│  └─Source<span class="hljs-comment">// FreeRTOS的源码</span><br>│      ├─include<span class="hljs-comment">// 源码对应的头文件</span><br>│      └─portable<span class="hljs-comment">// 每个支持的处理器架构需要一小段与处理器架构相关的RTOS代码。该目录下即为和开发平台相关的代码</span><br>│            ├─MemMang<span class="hljs-comment">// FreeRTOS内存管理方案（一般要根据平台来选择以下5个之一）</span><br>│            │     heap_1.c<br>│            │     heap_2.c<br>│            │     heap_3.c<br>│            │     heap_4.c<br>│            │     heap_5.c<br>│            └─其他<span class="hljs-comment">// 其他开发工具相关的代码，需要根据自己的开发工具进行选择</span><br>│      croutine.c<span class="hljs-comment">// 协线程（协程）文件，和任务类似，在系统资源比较缺乏下使用</span><br>│      event_groups.c<span class="hljs-comment">// 事件标志组</span><br>│      list.c<span class="hljs-comment">// 列表结构描述，在内核整体控制上都使用了列表格式数据处理,一切数据结构的基础</span><br>│      queue.c<span class="hljs-comment">// 队列，任务和任务之间的通讯处理</span><br>│      tasks.c<span class="hljs-comment">// 所有任务相关函数</span><br>│      timers.c<span class="hljs-comment">// 软件定时器，以任务形式存在</span><br>|      stream_buffer.c<span class="hljs-comment">// 10.0.0 新增</span><br>└─FreeRTOS-Plus<span class="hljs-comment">// FreeRTOS+组件和演示例程</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="2、FreeRTOS移植"><a href="#2、FreeRTOS移植" class="headerlink" title="2、FreeRTOS移植"></a>2、FreeRTOS移植</h1><h2 id="2-1源码具体分类"><a href="#2-1源码具体分类" class="headerlink" title="2&#x2F;1源码具体分类"></a>2&#x2F;1源码具体分类</h2><ul><li><p><strong>操作系统内核核心文件</strong>：内核的核心文件，包括任务管理、调度算法、消息通知…等等重要文件</p><ul><li><img src="/./../photo/freertos%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></li></ul></li><li><p><strong>硬件架构相关的文件</strong>：这个里面的内容都是与具体处理器架构相关的文件，根据不同的架构选择不同的文件，如图所示，这个里面的文件是操作系统跟硬件架构相适配，保证系统正常运行</p><ul><li><p>例如ARM架构下的cortex-m3和cortex-m4架构的文件如图</p><p><img src="/./../photo/freertos%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></p></li></ul></li><li><p><strong>内存管理算法文件，以及配置文件</strong>；FreeRTOS提供了5种内存管理算法。为了方便裁剪系统，官方DEMO文件中定义了一个FreeRTOSConfig.h的头文件，里面都是一些宏开关，可以根据需求，来裁剪系统，使不需要的配置不被编译进目标文件。</p><ul><li><p>内存管理文件如图</p><p><img src="/./../photo/freertos%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></p></li><li><p>配置文件模板：这个配置文件，没有固定的文件，官方只是在示例中给出一些模板，用户可以根据这个模板来自己修改内容，另外可以模仿直接从写一份；如图所示</p><p><img src="/./../photo/freertos%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></p></li></ul></li></ul><h2 id="2-2基于CORTEX-M3-M4系列的移植"><a href="#2-2基于CORTEX-M3-M4系列的移植" class="headerlink" title="2&#x2F;2基于CORTEX-M3&#x2F;M4系列的移植"></a>2&#x2F;2基于CORTEX-M3&#x2F;M4系列的移植</h2><ul><li><p>移植前需要稍微了解一下这两个架构异常和中断类型；</p><ul><li><p>如图就是cm3的异常表</p><p><img src="/./../photo/cm4%E5%BC%82%E5%B8%B8%E8%A1%A8.png"></p></li><li><p>这里我们主要关注这三个异常</p><ul><li><p>SYSTICK异常：cortex-m系列的产品里面的系统滴答定时器产生的异常，在freertos中使用滴答定时器作为系统的心跳，以此来实现时间片轮转的调度功能；每当时间片（就是滴答定时器计数到了）到了，调用相应的中断服务函数来检查是否需要切换任务。在freertos的port.c中定义了相应的中断服务函数，如图；</p><p><img src="/./../photo/systick%E5%87%BD%E6%95%B0.png"></p></li><li><p>PendSV异常：根据上述，SYSTICK这个异常只是检查是否要进行任务切换，真正要实现任务切换的是触发PendSV异常，在freertos的port.c中定义了相应的中断服务函数，如图；</p><p><img src="/./../photo/pendsv%E5%87%BD%E6%95%B0.png"></p></li><li><p>SVC异常：这个异常在freertos中一般只会使用一次，它也是用来进行任务调度的，但是只在vTaskStartScheduler(void)这个函数里面调用一次，在freertos中定义了相关的中断服务函数。这个函数调用流程为（vTaskStartScheduler( void )-&gt;xPortStartScheduler( void )-&gt;prvPortStartFirstTask(void)在这个函数里面会触发svc异常）</p><p><img src="/./../photo/svc%E5%87%BD%E6%95%B0.png"></p></li></ul></li></ul></li><li><p>修改启动文件，启动文件里面定义了中断服务函数的名称，需要用freertos中的这三个函数名替换掉三个函数</p><p><img src="/./../photo/%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6.png"></p></li><li><p>注释掉HAL库下的中断服务函数：stm32fxxx_it.c文件里面注释掉这三个函数。</p></li><li><p>最后就是将上述操作系统内核核心文件、架构文件、配置文件的c文件加入到项目内，然后添加相应的头文件路径。到这里基本上freertos移植完成了。剩下一些裁剪功能，配置等等在相应的配置文件来处理。</p></li></ul><h2 id="2-3配置文件以及内存管理算法细节"><a href="#2-3配置文件以及内存管理算法细节" class="headerlink" title="2&#x2F;3配置文件以及内存管理算法细节"></a>2&#x2F;3配置文件以及内存管理算法细节</h2><ul><li><p>配置文件主要是对FreeRTOS.h这个头文件的内容进行一些裁剪，并且里面有些如果不定义就会报错；如图必须需要定义的；其他具体的配置内容可以参考FreeRTOS.h这个头文件来进行裁剪和进行配置</p><p><img src="/./../photo/freertos%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89.png"></p></li><li><p>FreeRTOSConfig.h模板如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FREERTOS_CONFIG_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FREERTOS_CONFIG_H</span><br><br><span class="hljs-comment">/* 头文件 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> SystemCoreClock;<br><br><span class="hljs-comment">/* 基础配置项 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_PREEMPTION                            1                       <span class="hljs-comment">/* 1: 抢占式调度器, 0: 协程式调度器, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION         1                       <span class="hljs-comment">/* 1: 使用硬件计算下一个要运行的任务, 0: 使用软件算法计算下一个要运行的任务, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TICKLESS_IDLE                         0                       <span class="hljs-comment">/* 1: 使能tickless低功耗模式, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configCPU_CLOCK_HZ                              SystemCoreClock         <span class="hljs-comment">/* 定义CPU主频, 单位: Hz, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSYSTICK_CLOCK_HZ                          (configCPU_CLOCK_HZ / 8)<span class="hljs-comment">/* 定义SysTick时钟频率，当SysTick时钟频率与内核时钟频率不同时才可以定义, 单位: Hz, 默认: 不定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTICK_RATE_HZ                              1000                    <span class="hljs-comment">/* 定义系统时钟节拍频率, 单位: Hz, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_PRIORITIES                            32                      <span class="hljs-comment">/* 定义最大优先级数, 最大优先级=configMAX_PRIORITIES-1, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMINIMAL_STACK_SIZE                        128                     <span class="hljs-comment">/* 定义空闲任务的栈空间大小, 单位: Word, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_TASK_NAME_LEN                         16                      <span class="hljs-comment">/* 定义任务名最大字符数, 默认: 16 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_16_BIT_TICKS                          0                       <span class="hljs-comment">/* 1: 定义系统时钟节拍计数器的数据类型为16位无符号数, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configIDLE_SHOULD_YIELD                         1                       <span class="hljs-comment">/* 1: 使能在抢占式调度下,同优先级的任务能抢占空闲任务, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TASK_NOTIFICATIONS                    1                       <span class="hljs-comment">/* 1: 使能任务间直接的消息传递,包括信号量、事件标志组和消息邮箱, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTASK_NOTIFICATION_ARRAY_ENTRIES           1                       <span class="hljs-comment">/* 定义任务通知数组的大小, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_MUTEXES                               1                       <span class="hljs-comment">/* 1: 使能互斥信号量, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_RECURSIVE_MUTEXES                     1                       <span class="hljs-comment">/* 1: 使能递归互斥信号量, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_COUNTING_SEMAPHORES                   1                       <span class="hljs-comment">/* 1: 使能计数信号量, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_ALTERNATIVE_API                       0                       <span class="hljs-comment">/* 已弃用!!! */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configQUEUE_REGISTRY_SIZE                       8                       <span class="hljs-comment">/* 定义可以注册的信号量和消息队列的个数, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_QUEUE_SETS                            1                       <span class="hljs-comment">/* 1: 使能队列集, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TIME_SLICING                          1                       <span class="hljs-comment">/* 1: 使能时间片调度, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_NEWLIB_REENTRANT                      0                       <span class="hljs-comment">/* 1: 任务创建时分配Newlib的重入结构体, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configENABLE_BACKWARD_COMPATIBILITY             0                       <span class="hljs-comment">/* 1: 使能兼容老版本, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configNUM_THREAD_LOCAL_STORAGE_POINTERS         0                       <span class="hljs-comment">/* 定义线程本地存储指针的个数, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSTACK_DEPTH_TYPE                          uint16_t                <span class="hljs-comment">/* 定义任务堆栈深度的数据类型, 默认: uint16_t */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMESSAGE_BUFFER_LENGTH_TYPE                size_t                  <span class="hljs-comment">/* 定义消息缓冲区中消息长度的数据类型, 默认: size_t */</span></span><br><br><span class="hljs-comment">/* 内存分配相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSUPPORT_STATIC_ALLOCATION                 0                       <span class="hljs-comment">/* 1: 支持静态申请内存, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION                1                       <span class="hljs-comment">/* 1: 支持动态申请内存, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTOTAL_HEAP_SIZE                           ((size_t)(10 * 1024))   <span class="hljs-comment">/* FreeRTOS堆中可用的RAM总量, 单位: Byte, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configAPPLICATION_ALLOCATED_HEAP                0                       <span class="hljs-comment">/* 1: 用户手动分配FreeRTOS内存堆(ucHeap), 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSTACK_ALLOCATION_FROM_SEPARATE_HEAP       0                       <span class="hljs-comment">/* 1: 用户自行实现任务创建时使用的内存申请与释放函数, 默认: 0 */</span></span><br><br><span class="hljs-comment">/* 钩子函数相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_IDLE_HOOK                             0                       <span class="hljs-comment">/* 1: 使能空闲任务钩子函数, 无默认需定义  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TICK_HOOK                             0                       <span class="hljs-comment">/* 1: 使能系统时钟节拍中断钩子函数, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configCHECK_FOR_STACK_OVERFLOW                  0                       <span class="hljs-comment">/* 1: 使能栈溢出检测方法1, 2: 使能栈溢出检测方法2, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_MALLOC_FAILED_HOOK                    0                       <span class="hljs-comment">/* 1: 使能动态内存申请失败钩子函数, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_DAEMON_TASK_STARTUP_HOOK              0                       <span class="hljs-comment">/* 1: 使能定时器服务任务首次执行前的钩子函数, 默认: 0 */</span></span><br><br><span class="hljs-comment">/* 运行时间和任务状态统计相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configGENERATE_RUN_TIME_STATS                   0                       <span class="hljs-comment">/* 1: 使能任务运行时间统计功能, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> configGENERATE_RUN_TIME_STATS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/TIMER/btim.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()        ConfigureTimeForRunTimeStats()</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> FreeRTOSRunTimeTicks;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portGET_RUN_TIME_COUNTER_VALUE()                FreeRTOSRunTimeTicks</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TRACE_FACILITY                        1                       <span class="hljs-comment">/* 1: 使能可视化跟踪调试, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS            1                       <span class="hljs-comment">/* 1: configUSE_TRACE_FACILITY为1时，会编译vTaskList()和vTaskGetRunTimeStats()函数, 默认: 0 */</span></span><br><br><span class="hljs-comment">/* 协程相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_CO_ROUTINES                           0                       <span class="hljs-comment">/* 1: 启用协程, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_CO_ROUTINE_PRIORITIES                 2                       <span class="hljs-comment">/* 定义协程的最大优先级, 最大优先级=configMAX_CO_ROUTINE_PRIORITIES-1, 无默认configUSE_CO_ROUTINES为1时需定义 */</span></span><br><br><span class="hljs-comment">/* 软件定时器相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TIMERS                                1                               <span class="hljs-comment">/* 1: 使能软件定时器, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_TASK_PRIORITY                       ( configMAX_PRIORITIES - 1 )    <span class="hljs-comment">/* 定义软件定时器任务的优先级, 无默认configUSE_TIMERS为1时需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_QUEUE_LENGTH                        5                               <span class="hljs-comment">/* 定义软件定时器命令队列的长度, 无默认configUSE_TIMERS为1时需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_TASK_STACK_DEPTH                    ( configMINIMAL_STACK_SIZE * 2) <span class="hljs-comment">/* 定义软件定时器任务的栈空间大小, 无默认configUSE_TIMERS为1时需定义 */</span></span><br><br><span class="hljs-comment">/* 可选函数, 1: 使能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskPrioritySet                        1                       <span class="hljs-comment">/* 设置任务优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_uxTaskPriorityGet                       1                       <span class="hljs-comment">/* 获取任务优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskDelete                             1                       <span class="hljs-comment">/* 删除任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskSuspend                            1                       <span class="hljs-comment">/* 挂起任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xResumeFromISR                          1                       <span class="hljs-comment">/* 恢复在中断中挂起的任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskDelayUntil                         1                       <span class="hljs-comment">/* 任务绝对延时 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskDelay                              1                       <span class="hljs-comment">/* 任务延时 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetSchedulerState                  1                       <span class="hljs-comment">/* 获取任务调度器状态 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetCurrentTaskHandle               1                       <span class="hljs-comment">/* 获取当前任务的任务句柄 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_uxTaskGetStackHighWaterMark             1                       <span class="hljs-comment">/* 获取任务堆栈历史剩余最小值 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetIdleTaskHandle                  1                       <span class="hljs-comment">/* 获取空闲任务的任务句柄 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_eTaskGetState                           1                       <span class="hljs-comment">/* 获取任务状态 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xEventGroupSetBitFromISR                1                       <span class="hljs-comment">/* 在中断中设置事件标志位 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTimerPendFunctionCall                  1                       <span class="hljs-comment">/* 将函数的执行挂到定时器服务任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskAbortDelay                         1                       <span class="hljs-comment">/* 中断任务延时 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetHandle                          1                       <span class="hljs-comment">/* 通过任务名获取任务句柄 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskResumeFromISR                      1                       <span class="hljs-comment">/* 恢复在中断中挂起的任务 */</span></span><br><br><span class="hljs-comment">/* 中断嵌套行为配置 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __NVIC_PRIO_BITS</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> configPRIO_BITS __NVIC_PRIO_BITS</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> configPRIO_BITS 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configLIBRARY_LOWEST_INTERRUPT_PRIORITY         15                  <span class="hljs-comment">/* 中断最低优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    5                   <span class="hljs-comment">/* FreeRTOS可管理的最高中断优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configKERNEL_INTERRUPT_PRIORITY                 ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_SYSCALL_INTERRUPT_PRIORITY            ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_API_CALL_INTERRUPT_PRIORITY           configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><br><span class="hljs-comment">/* FreeRTOS中断服务函数相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandler                              PendSV_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandler                                 SVC_Handler</span><br><br><span class="hljs-comment">/* 断言 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vAssertCalled(char, int) printf(<span class="hljs-string">&quot;Error: %s, %d\r\n&quot;</span>, char, int)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configASSERT( x ) <span class="hljs-keyword">if</span>( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )</span><br><br><span class="hljs-comment">/* FreeRTOS MPU 特殊定义 */</span><br><span class="hljs-comment">//#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0</span><br><span class="hljs-comment">//#define configTOTAL_MPU_REGIONS                                8</span><br><span class="hljs-comment">//#define configTEX_S_C_B_FLASH                                  0x07UL</span><br><span class="hljs-comment">//#define configTEX_S_C_B_SRAM                                   0x07UL</span><br><span class="hljs-comment">//#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY            1</span><br><span class="hljs-comment">//#define configALLOW_UNPRIVILEGED_CRITICAL_SECTIONS             1</span><br><br><span class="hljs-comment">/* ARMv8-M 安全侧端口相关定义。 */</span><br><span class="hljs-comment">//#define secureconfigMAX_SECURE_CONTEXTS         5</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* FREERTOS_CONFIG_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>FreeRTOS提供的五种内存管理算法</p><ul><li><table><thead><tr><th align="center">文件</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">heap_1.c</td><td align="center">分配简单，时间确定</td><td align="center">只分配空间，不能释放</td></tr><tr><td align="center">heap_2.c</td><td align="center">动态分配、最佳匹配</td><td align="center">内存碎片化、时间不定</td></tr><tr><td align="center">heap_3.c</td><td align="center">调用标准C库的函数</td><td align="center">速度慢、时间不定</td></tr><tr><td align="center">heap_4.c</td><td align="center">第二种方法的增强版，可以合并相邻空闲内存，解决碎片化</td><td align="center">时间不定</td></tr><tr><td align="center">heap_5.c</td><td align="center">在第四种方法上支持分隔内存块，解决碎片化</td><td align="center">时间不定</td></tr></tbody></table></li><li><p>heap_1的实现方法；它只提供分配函数，不提供释放函数，具体实现就是直接定义一个大数组如图所示：<img src="/./../photo/heap1%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89.png"></p><p>这个实现只是在要求使用 RAM 时将一个单一的数组细分为更小的块 。 数组的总大小（堆的总大小）通过 configTOTAL_HEAP_SIZE （定义于 FreeRTOSConfig.h 中）设置 。</p></li><li><p>heap_2实现方法；heap_2也是在数组上分配内存，跟heap_1不一样的地方在于heap_2使用<strong>最佳匹配算法</strong>(best fit)来分配内存，它支持vPortFree，例如有有三块空闲内存5B,25B,100B现在要申请20B的空间，那么就会将25B的空间划分为20B跟5B。但是这样可能就会造成碎片，就算释放掉申请的20B空间，它也不会把原先的5B空间合并成一个，如果5B的空间一直没人用的话，就会成碎片。</p></li><li><p>heap_3实现方法；他直接调用标准C库的malloc函数跟free函数，但是FreeRTOS中会先暂停调度器，再去调用这些函数，实现了线程安全</p></li><li><p>heap_4实现方法；heap_4使用<strong>首次适应算法</strong>(first fit)来分配内存,例如有三块空闲内存5B,100B,25B现在要申请20B的空间，那么它会找到第一个满足20B的内存，这里就是先找到100B，把它分为20B跟80B的空间，当释放掉申请的内存时候，它会把释放的20B的内存跟80B的内存从新合并成一块100B的内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。</p></li><li><p>heap_5实现方法；heap_5分配内存、释放内存的算法跟heap_4是一样的。但是heap_5不局限于管理一个大数组，可以管理很多块内存、分隔的内存。但是必须记录每块内存的地址以及大小，用结构体保存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">* <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapRegion</span></span><br><span class="hljs-class">* &#123;</span><br>*  <span class="hljs-type">uint8_t</span> *pucStartAddress; &lt;&lt; Start address of a block of memory that will be part of the heap.<br>*  <span class="hljs-type">size_t</span> xSizeInBytes;      &lt;&lt; Size of the block of memory.<br>* &#125; HeapRegion_t;<br></code></pre></td></tr></table></figure><p>如果要定义多块内存，就用该结构体数组形式来表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">* HeapRegion_t xHeapRegions[] =<br>* &#123;<br>*  &#123; ( <span class="hljs-type">uint8_t</span> * ) <span class="hljs-number">0x80000000</span>UL, <span class="hljs-number">0x10000</span> &#125;, &lt;&lt; Defines a block of <span class="hljs-number">0x10000</span> bytes starting at address <span class="hljs-number">0x80000000</span><br>*  &#123; ( <span class="hljs-type">uint8_t</span> * ) <span class="hljs-number">0x90000000</span>UL, <span class="hljs-number">0xa0000</span> &#125;, &lt;&lt; Defines a block of <span class="hljs-number">0xa0000</span> bytes starting at address of <span class="hljs-number">0x90000000</span><br>*  &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span> &#125;                &lt;&lt; Terminates the <span class="hljs-built_in">array</span>.<br>* &#125;;<br>*<br></code></pre></td></tr></table></figure></li><li><p>在实际使用的时候我们只需要选择其中一个内存管理算法就行。每个算法提供的申请内存的函数都是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( <span class="hljs-type">size_t</span> xWantedSize )</span><br>&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>释放函数都是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortFree</span><span class="hljs-params">( <span class="hljs-type">void</span> * pv )</span><br>&#123;<br>    .......<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="3、FreeRTOS源码"><a href="#3、FreeRTOS源码" class="headerlink" title="3、FreeRTOS源码"></a>3、FreeRTOS源码</h1><h2 id="3-1内核的列表"><a href="#3-1内核的列表" class="headerlink" title="3&#x2F;1内核的列表"></a>3&#x2F;1内核的列表</h2><ul><li><p>在FreeRTOS中列表是个很重要的数据结构，实质就是一个双向链表；FreeRTOS中定义了就绪列表、等待列表、挂起列表、延时列表、终止列表。任务切换等操作都是通过查找对应的列表来实现的。在list.h文件内都是有关列表的定义，以及函数的声明。</p></li><li><p>列表项的数据结构定义，及示意图；</p><ul><li><p>普通列表项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    configLIST_VOLATILE TickType_t xItemValue;          <span class="hljs-comment">/*&lt; The value being listed.  In most cases this is used to sort the list in ascending order. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxNext</span>;</span>     <span class="hljs-comment">/*&lt; Pointer to the next ListItem_t in the list. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxPrevious</span>;</span> <span class="hljs-comment">/*&lt; Pointer to the previous ListItem_t in the list. */</span><br>    <span class="hljs-type">void</span> * pvOwner;                                     <span class="hljs-comment">/*&lt; Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxContainer</span>;</span>     <span class="hljs-comment">/*&lt; Pointer to the list in which this list item is placed (if any). */</span><br>    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE          <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/./../photo/%E5%88%97%E8%A1%A8%E9%A1%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p>迷你列表项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xMINI_LIST_ITEM</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    configLIST_VOLATILE TickType_t xItemValue;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxNext</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxPrevious</span>;</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xMINI_LIST_ITEM</span> <span class="hljs-title">MiniListItem_t</span>;</span><br></code></pre></td></tr></table></figure><p><img src="/./../photo/%E8%BF%B7%E4%BD%A0%E5%88%97%E8%A1%A8%E9%A1%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li></ul></li><li><p>列表数据结构定义，及其示意图；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_INTEGRITY_CHECK_VALUE      <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    <span class="hljs-keyword">volatile</span> UBaseType_t uxNumberOfItems;<br>    ListItem_t * configLIST_VOLATILE pxIndex; <span class="hljs-comment">/*&lt; Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */</span><br>    MiniListItem_t xListEnd;                  <span class="hljs-comment">/*&lt; List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */</span><br>    listSECOND_LIST_INTEGRITY_CHECK_VALUE     <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>&#125; List_t;<br></code></pre></td></tr></table></figure><p><img src="/./../photo/%E5%88%97%E8%A1%A8%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p>切记列表里面的迷你列表项，不算做列表中的列表项的个数</p></li><li><p>FreeRTOS列表操作函数</p><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">void vListInitialise( List_t * const pxList )</td><td align="center">初始化列表头</td></tr><tr><td align="center">void vListInitialiseItem( ListItem_t * const pxItem )</td><td align="center">初始化列表项</td></tr><tr><td align="center">void vListInsert( List_t * const pxList,<br/>                  ListItem_t * const pxNewListItem )</td><td align="center">按照列表项里的列表值进行顺序插入列表</td></tr><tr><td align="center">void vListInsertEnd( List_t * const pxList,<br/>                     ListItem_t * const pxNewListItem )</td><td align="center">列表末端插入，这里特别要注意，这里并不一定是插到xListEnd后面，具体是插在pxIndex指向的列表项前面</td></tr><tr><td align="center">UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )</td><td align="center">删除列表项，返回移除后列表中列表项的多少</td></tr></tbody></table></li></ul><h2 id="3-2任务操作相关函数"><a href="#3-2任务操作相关函数" class="headerlink" title="3&#x2F;2任务操作相关函数"></a>3&#x2F;2任务操作相关函数</h2><ul><li><p>任务创建函数和删除函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*动态创建*/</span><br>BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">( </span><br><span class="hljs-params"> TaskFunction_t pxTaskCode, <span class="hljs-comment">//任务函数的函数指针</span></span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, <span class="hljs-comment">//任务名字</span></span><br><span class="hljs-params"> <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="hljs-comment">//任务堆栈大小</span></span><br><span class="hljs-params"> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters, <span class="hljs-comment">//传递给任务函数的参数</span></span><br><span class="hljs-params"> UBaseType_t uxPriority, <span class="hljs-comment">//任务优先级</span></span><br><span class="hljs-params"> TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask<span class="hljs-comment">//任务函数的函数句柄，就是任务控制块</span></span><br><span class="hljs-params">)</span>; <br><span class="hljs-comment">/*静态创建*/</span><br>TaskHandle_t <span class="hljs-title function_">xTaskCreateStatic</span><span class="hljs-params">( </span><br><span class="hljs-params"> TaskFunction_t pxTaskCode, </span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, </span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> ulStackDepth, </span><br><span class="hljs-params"> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters, </span><br><span class="hljs-params"> UBaseType_t uxPriority, </span><br><span class="hljs-params"> StackType_t * <span class="hljs-type">const</span> puxStackBuffer,<span class="hljs-comment">//任务的栈指针，内存由用户分配</span></span><br><span class="hljs-params"> StaticTask_t * <span class="hljs-type">const</span> pxTaskBuffer<span class="hljs-comment">//任务控制块的指针，内存由用户分配</span></span><br><span class="hljs-params">)</span>; <br><span class="hljs-comment">/*任务删除*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">(TaskHandle_t xTaskToDelete<span class="hljs-comment">//任务的句柄); </span></span><br></code></pre></td></tr></table></figure></li><li><p>任务挂起和恢复</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">(TaskHandle_t xTaskToSuspend)</span>;<span class="hljs-comment">//挂起任务，会阻塞任务</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskResume</span><span class="hljs-params">(TaskHandle_t xTaskToResume)</span>;<span class="hljs-comment">//恢复任务</span><br>BaseType_t <span class="hljs-title function_">xTaskResumeFromISR</span><span class="hljs-params">(TaskHandle_t xTaskToResume)</span><span class="hljs-comment">//在中断中要用这个来恢复任务</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-3任务间通信"><a href="#3-3任务间通信" class="headerlink" title="3&#x2F;3任务间通信"></a>3&#x2F;3任务间通信</h2><h3 id="3-3-1消息队列和队列集"><a href="#3-3-1消息队列和队列集" class="headerlink" title="3&#x2F;3&#x2F;1消息队列和队列集"></a>3&#x2F;3&#x2F;1消息队列和队列集</h3><ul><li><p>消息队列；是一种先进先出的存储机制，消息队列里面可以存储任何数据类型；但是要求任务在写队列的时候，要严格按照数据类型格式来写。如图所示：</p><p><img src="/./../photo/%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p>队列创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//动态创建，返回队列的起始地址</span><br>xQueueCreate(uxQueueLength，uxItemSize)<br></code></pre></td></tr></table></figure></li><li><p>队列读写函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">xQueueSend()<span class="hljs-comment">//尾部写队列</span><br>xQueueSendFromISR()<span class="hljs-comment">//中断中写</span><br>    <br>xQueueReceive()<span class="hljs-comment">//读队列</span><br>xQueueReceiveFromISR() <span class="hljs-comment">//中断中对</span><br></code></pre></td></tr></table></figure></li><li><p>注意，读写队列都可能导致任务阻塞，写的时候队列满，阻塞任务；读的时候队列空，阻塞任务；</p></li><li><p>队列集：队列集就是把存储不同数据类型的队列，管理起来；方便任务读取不同的队列。</p></li><li><p>队列集操作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">xQueueCreateSet()<span class="hljs-comment">//创建队列集</span><br>xQueueAddToSet()<span class="hljs-comment">//添加队列到队列集</span><br>xQueueRemoveFromSet()<span class="hljs-comment">//移除队列</span><br>xQueueSelectFromSet()<span class="hljs-comment">//获取队列集中有效消息的队列</span><br>xQueueSelectFromSetFromISR()<span class="hljs-comment">//在中断中获取队列集中的有效队列消息</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-3-2信号量"><a href="#3-3-2信号量" class="headerlink" title="3&#x2F;3&#x2F;2信号量"></a>3&#x2F;3&#x2F;2信号量</h3><ul><li><p>任务同步与互斥；任务同步就是一个任务要等待另一个任务操作完，才能进行下一步操作；互斥就是，两个任务在同一时间只能对某一个临界区资源进行操作；所以同步与互斥是成对出现的。</p></li><li><p>二值信号量：实质是一个队列项只有一个的队列，所以队列要么空和要么满；来解决任务间同步与互斥的问题。</p></li><li><p>计数型信号量：实质是一个多项的队列，但是这个队列，并不传递数据。仅仅是来表示可用资源数有多少；</p></li><li><p>互斥信号量：在二值信号量的基础上，加了优先级继承的机制，让获得信号量的任务优先级暂时提高，防止中等优先级任务打断，导致最高优先级任务一直阻塞。切记，不能用到中断，因为中断不是任务，没有优先级。并且中断中不能等待互斥量而被阻塞。</p></li></ul><h3 id="3-3-3空闲任务"><a href="#3-3-3空闲任务" class="headerlink" title="3&#x2F;3&#x2F;3空闲任务"></a>3&#x2F;3&#x2F;3空闲任务</h3><ul><li>在启动任务调度器的时候，内核默认创建了一个优先级最低的任务，就是空闲任务，这个任务主要在没有其他用户任务运行时，才会执行。主要作用是内存清理，以及统计任务。里面有个钩子函数，主要设置处理进入低功耗模式，这里是设置处理器；freertos有自带的低功耗区分一下。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式常见协议总结</title>
    <link href="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1、UART串口通信"><a href="#1、UART串口通信" class="headerlink" title="1、UART串口通信"></a>1、UART串口通信</h1><h2 id="1-1简介"><a href="#1-1简介" class="headerlink" title="1.1简介"></a>1.1简介</h2><ul><li><p>通用异步收发器 <strong>UART</strong>（Universal AsynchronousReceiver&#x2F;Transmitter)，是一种串行、异步、全双工的通信协议。高电平代表’1‘，低电平代表’0‘。特别注意固定格式位，起始位以0为通信起步，停止位以1作为结束位。</p></li><li><p>整体结构如图：</p><p><img src="/./../photo/%E7%BB%93%E6%9E%84%E7%AE%80%E5%9B%BE.png"></p></li></ul><h2 id="1-2参数配置"><a href="#1-2参数配置" class="headerlink" title="1.2参数配置"></a>1.2参数配置</h2><ul><li><p>数据传输格式</p><p><img src="/./../photo/UART%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.png" alt="数据格式"></p><ul><li>起始位总是以低电平有效，停止位以高电平有效。</li><li>数据位：数据位可以是5、6、7、8，9位等，构成一个字符（一般都是8位）。如ASCII码（7位），扩展BCD码（8位）。先发送<strong>最低位</strong>，最后发送<strong>最高位</strong>，使用低电平表示‘0’高电平表示‘1’完成数据位的传输。</li><li>奇偶检验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。</li></ul></li><li><p>波特率</p><ul><li>数据传输的速率用波特率来表示。通俗讲就是让通信双方知道什么时间点来采样数据。例如:通信波特率是115200bps，即代表1秒可以传输115200位的数据。</li></ul></li></ul><h2 id="1-3示例"><a href="#1-3示例" class="headerlink" title="1.3示例"></a>1.3示例</h2><ul><li><p>在stm32中如何使用串口，来实现printf函数与PC串口助手进行通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//值得的注意点：printf函数最终调用的是fputc(int ch, FILE *f)来输出字符串的，但是这个函数在stdio.h文件里面仅仅是定义了但是没有实现，所以必须重定义这个函数。</span><br>    <span class="hljs-comment">/*以下示例均以UART1来作为示例*/</span><br>    <span class="hljs-comment">/*HAL库函数版本实现串口的中断接收和发送*/</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">    &#123;</span><br>        __IO <span class="hljs-type">uint32_t</span> SR;         <span class="hljs-comment">/*!&lt; USART Status register,                   Address offset: 0x00 */</span><br>        __IO <span class="hljs-type">uint32_t</span> DR;         <span class="hljs-comment">/*!&lt; USART Data register,                     Address offset: 0x04 */</span><br>        __IO <span class="hljs-type">uint32_t</span> BRR;        <span class="hljs-comment">/*!&lt; USART Baud rate register,                Address offset: 0x08 */</span><br>        __IO <span class="hljs-type">uint32_t</span> CR1;        <span class="hljs-comment">/*!&lt; USART Control register 1,                Address offset: 0x0C */</span><br>        __IO <span class="hljs-type">uint32_t</span> CR2;        <span class="hljs-comment">/*!&lt; USART Control register 2,                Address offset: 0x10 */</span><br>        __IO <span class="hljs-type">uint32_t</span> CR3;        <span class="hljs-comment">/*!&lt; USART Control register 3,                Address offset: 0x14 */</span><br>        __IO <span class="hljs-type">uint32_t</span> GTPR;       <span class="hljs-comment">/*!&lt; USART Guard time and prescaler register, Address offset: 0x18 */</span><br>    &#125; USART_TypeDef;<span class="hljs-comment">//这是底层寄存器封装</span><br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PERIPH_BASE           0x40000000UL</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000UL)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> USART1_BASE           (APB2PERIPH_BASE + 0x00003800UL)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> USART1              ((USART_TypeDef *)USART1_BASE)</span><br>    <br>    <span class="hljs-comment">/*重定义fputc(int ch, FILE *f)*/</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> ((USART1-&gt;SR &amp; <span class="hljs-number">0X40</span>) == <span class="hljs-number">0</span>);     <span class="hljs-comment">/* 等待上一个字符发送完成 */</span><br>        USART_UX-&gt;DR = (<span class="hljs-type">uint8_t</span>)ch;           <span class="hljs-comment">/* 将要发送的字符 ch 写入到DR寄存器 */</span><br>        <span class="hljs-keyword">return</span> ch;<br>    &#125;<br>    <span class="hljs-comment">/*初始化串口1,省略大部分代码，保留核心函数*/</span><br>    UART_HandleTypeDef g_uart1_handle;  <span class="hljs-comment">/* UART句柄 */</span><br>    HAL_UART_Init(&amp;g_uart1_handle)内部调用--&gt;HAL_UART_MspInit(&amp;g_uart1_handle)--&gt; HAL_GPIO_Init()函数来配置相关引脚的复用输入输出--&gt;HAL_NVIC_EnableIRQ()使能串口中断--&gt;HAL_NVIC_SetPriority()设置中断优先级<br>    <br>        HAL_UART_Receive_IT(&amp;g_uart1_handle, (<span class="hljs-type">uint8_t</span> *)g_rx_buffer, RXBUFFERSIZE)开启串口接收中断天<br>    <br>        USART1_IRQHandler()串口<span class="hljs-number">1</span>中断服务函数--&gt;HAL_UART_IRQHandler()HAL串口中断公共服务函--&gt;HAL_UART_RxCpltCallback()中断接收回调函数 <br></code></pre></td></tr></table></figure></li></ul><h1 id="2、集成电路总线-IIC"><a href="#2、集成电路总线-IIC" class="headerlink" title="2、集成电路总线(IIC)"></a>2、集成电路总线(IIC)</h1><h2 id="2-1简介"><a href="#2-1简介" class="headerlink" title="2.1简介"></a>2.1简介</h2><ul><li>IIC使用两根信号线进行通信：一根时钟线SCL，一根数据线SDA。IIC将SCL处于高时SDA拉低的动作作为开始信号，SCL处于高时SDA拉高的动作作为结束信号；传输数据时，SDA在SCL低电平时改变数据，在SCL高电平时保持数据，每个SCL脉冲的高电平传递1位数据。IIC是半双工同步通信协议</li></ul><h2 id="2-2总线特性与硬件结构"><a href="#2-2总线特性与硬件结构" class="headerlink" title="2.2总线特性与硬件结构"></a>2.2总线特性与硬件结构</h2><ul><li><p>IIC总线上所有器件的SDA、SCL引脚输出驱动都为 <strong>开漏(OD)</strong> 结构，通过外接上拉电阻实现总线上所有节点SDA、SCL信号的<strong>线与</strong>逻辑关系；</p></li><li><p>总线上的所有设备通过软件寻址且具有唯一的地址（7位或10位）。7位“从机专用地址码”，其高4位为由生产厂家制定的<strong>设备类型地址</strong>，低3位为器件引脚定义地址（由使用者定义）；10位地址不常见；</p></li><li><p>支持多主机。在总线上存在多个主机时，通过冲突检测和仲裁机制防止多个主机同时发起数据传输时存在的冲突；</p></li><li><p>通信模式</p><ul><li><table><thead><tr><th align="center">模式</th><th align="center">速度</th></tr></thead><tbody><tr><td align="center">标准模式（Standard Mode）</td><td align="center">100kb&#x2F;s</td></tr><tr><td align="center">快速模式（Fast Mode）</td><td align="center">400kb&#x2F;s</td></tr><tr><td align="center">增强快速模式（Fast Mode Plus）</td><td align="center">1Mb&#x2F;s</td></tr><tr><td align="center">高速模式（High Speed Mode）</td><td align="center">3.4Mb&#x2F;s</td></tr><tr><td align="center">极速模式（Ultra-FastMode）</td><td align="center">5Mb&#x2F;s</td></tr></tbody></table></li></ul></li><li><p>硬件结构</p><ul><li>IIC使用两根信号线进行通信，要求两根线都使用 <strong>开漏输出接上拉电阻</strong> 的配置，以此实现总线上所有节点SDA、SCL信号的 <strong>线与</strong> 逻辑关系。</li><li><img src="/./../photo/IIC%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E4%BD%93%E5%9B%BE.png" alt="结构图"></li><li>IIC允许一对多通信，但是同一时间只能有一个丛机跟主机通信</li></ul></li></ul><h2 id="2-3工作时序"><a href="#2-3工作时序" class="headerlink" title="2.3工作时序"></a>2.3工作时序</h2><ul><li><strong>数据有效性以及采集过程</strong><ul><li>IIC 的数据读取动作都在 <strong>SCL为高</strong> 时产生，<strong>SCL为低</strong>时是数据改变的时期，无论SDA如何变化都不影响读取。所以，传输数据的过程中，当SCL为高时，数据应当保持稳定，避免数据的采集出错。</li></ul></li><li><strong>开始和结束信号</strong><ul><li><strong>开始信号：</strong>SCL为高时，SDA从高到低的跳变产生开始信号</li><li><strong>结束信号：</strong>SCL为高时，SDA从低到高的跳变产生结束信号</li></ul></li><li><strong>重复开始信号（ReSTART&#x2F;Sr）：</strong> 在结束时不给出STOP信号，而以一个时钟周期内再次给出开始信号作为替代</li><li><strong>字节格式：</strong>SDA数据线上的每个字节<strong>必须是8位</strong>，对于每次传输的<strong>字节数没有限制</strong>。每个字节（8位）数据传送完后紧跟着应答信号（ACK，第9位）。数据的先后顺序为：<strong>高位在前</strong> 。</li><li><strong>应答信号（ACK）：</strong>协议规定数据传输过程必须包含应答（ACK）。接收器通过应答告知发送的字节已被成功接收，之后发送器可以进行下一个字节的传输。<strong>主机产生数据传输过程中的所有时钟，包括用于应答的第9个时钟。发送器在应答时钟周期内释放对SDA总线的控制，</strong>这样接收器可以通过将SDA线拉低告知发送器：数据已被成功接收。（<strong>特别注意，ACK信号是主机发送完数据后，必须必须释放SDA总线后，丛机来控制SDA总线发出的信号</strong>）<ul><li>应答信号分为两种：<ul><li>当第9位(应答位)为 <strong>低电平</strong> 时，为 <strong>ACK</strong> 信号</li><li>当第9位(应答位)为 <strong>高电平</strong> 时，为 <strong>NACK</strong>信号</li></ul></li></ul></li></ul><h2 id="2-4地址设备为7位的通信过程"><a href="#2-4地址设备为7位的通信过程" class="headerlink" title="2.4地址设备为7位的通信过程"></a>2.4地址设备为7位的通信过程</h2><ul><li>完整通信示意图：<ul><li><img src="/./../photo/7bit%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E9%80%9A%E4%BF%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="示意图"></li><li><strong>START信号后，第一个字节包含设备7位地址以及1位读写位，读写位表示主机将要对丛机进行的操作。发送完这个字节之后，主机释放SDA总线等待从机给出ACK应答。如果从机给出了ACK应答，表示从机地址正确（有从机响应）并且已知晓是读还是写，便可以开始读写数据。如果从机没有给出ACK应答，则说明接收设备可能没有收到数据（如寻址的设备不存在或是设备正在忙碌）或无法解析收到的数据，如果是这样，则由主机来决定如何处理（STOP或ReSTART）。</strong><ul><li>情况一：主机写，丛机收，传输过程传输方向不变<ul><li><img src="/./../photo/%E4%B8%BB%E5%8F%91%E4%B8%9B%E6%94%B6.png" alt="示意图"></li></ul></li><li>情况二：主机收，丛机发送，传输过程传输方向改变<ul><li><img src="/./../photo/%E4%B8%BB%E6%94%B6%E4%B8%9B%E5%8F%91.png" alt="示意图"></li></ul></li></ul></li></ul></li></ul><h2 id="2-4实例操作"><a href="#2-4实例操作" class="headerlink" title="2.4实例操作"></a>2.4实例操作</h2><ul><li><p>情况一：用GPIO来模拟IIC通信过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*以F103为例子，SCL--&gt;PB6,SDA--&gt;PB7，精简代码，不是所有都列出来*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCL(x)do&#123;x? HAL_GPIO_WritePin(GPIOB,GPIO_PIN6,GPIO_PIN_SET):</span><br> \HAL_GPIO_WritePin(GPIOB,GPIO_PIN6,GPIO_PIN_RESET);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDA(x)do&#123;x? HAL_GPIO_WritePin(GPIOB,GPIO_PIN7,GPIO_PIN_SET):</span><br> \HAL_GPIO_WritePin(GPIOB,GPIO_PIN7,GPIO_PIN_RESET);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)<br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//初始化函数</span><br>&#123;<br>    GPIO_InitTypeDef gpio_init_struct;<br>    <br><span class="hljs-comment">/*首先是初始化这两个IO口，SCL配置为推挽输出，SDA配置为开漏输出（这样保证无论在哪种通信下，都不需要去切换IO口的     方向，因为开漏输出也可以读取IO的电平）*/</span><br>    <br>    ...配置省略<br>        <br>HAL_GPIO_Init(GPIOB, &amp;gpio_init_struct);<br>stop();<span class="hljs-comment">//初始化后先停止</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//起始信号</span><br>&#123;<br>    <span class="hljs-comment">/*SCL为高时，SDA从高到低的跳变产生开始信号*/</span><br>    SDA(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SDA(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    <br>    SCL(<span class="hljs-number">0</span>);<span class="hljs-comment">//这个操作是钳住IIC总线，准备接受或者发送数据</span><br>    delay_us(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//停止信号</span><br>&#123;<br>    <span class="hljs-comment">/*SCL为高时，SDA从低到高的跳变产生结束信号*/</span><br>    SDA(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SDA(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">master_ack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//主机应答信号</span><br>&#123;<br>    SDA(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    <br>    SDA(<span class="hljs-number">1</span>);<span class="hljs-comment">//释放总线</span><br>    delay_us(<span class="hljs-number">2</span>);      <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">master_nack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//主机不应答信号</span><br>&#123;<br>    SDA(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);     <br>&#125;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">slave_ack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> timeout;<br>    <span class="hljs-type">uint8_t</span> res=<span class="hljs-number">0</span>;<br>    SDA(<span class="hljs-number">1</span>);<span class="hljs-comment">//主机释放总线，此时丛机可以操作SDA线</span><br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<span class="hljs-comment">//拉高时钟线，可以传输数据了</span><br>    delay_us(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_7))<span class="hljs-comment">//等待SDA线的电平被从机拉低</span><br>    &#123;<br>        timeout++;<br>        <span class="hljs-keyword">if</span>(timeout&gt;<span class="hljs-number">250</span>)<br>        &#123;<br>            stop();<span class="hljs-comment">//超时</span><br>            res=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    SCL(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">iic_send</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span><span class="hljs-comment">//发送8位数据</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>    &#123;<br>        SDA((data&amp;<span class="hljs-number">0x80</span>)&gt;&gt;<span class="hljs-number">7</span>);<span class="hljs-comment">//因为IIC是先传输最高位的</span><br>        delay_us(<span class="hljs-number">2</span>);<br>        SCL(<span class="hljs-number">1</span>);<br>        delay_us(<span class="hljs-number">2</span>);<br>        SCL(<span class="hljs-number">0</span>);<br>        delay_us(<span class="hljs-number">2</span>);<br>        data&lt;&lt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    SDA(<span class="hljs-number">1</span>);<span class="hljs-comment">//释放总线</span><br>&#125;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">iic_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> ack)</span><span class="hljs-comment">//读取8位数据   </span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> res;<br>    <span class="hljs-type">uint8_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>    &#123;<br>        res&lt;&lt;=<span class="hljs-number">1</span>;<br>        SCL(<span class="hljs-number">1</span>);<br>        delay_us(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_7)<br>           &#123;<br>               res++;<br>           &#125;<br>        SCL(<span class="hljs-number">0</span>);<br>  delay_us(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!ack)<br>    &#123;<br>         master_nack();      <br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>         master_ack();       <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;       <br>&#125; <br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p>情况二：硬件IIC，用HAL库函数实现（F1系列HAL库硬件IIC可能会有BUG）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/////////////////////////</span><br>I2C_HandleTypeDef handle_iic<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">iic_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//硬件IIC初始化函数</span><br>&#123;<br>    <span class="hljs-comment">/*具体句柄配置省略，设置i2c速度、模式、丛机地址位数等等*/</span><br>    ...省略代码<br>        HAL_I2C_Iint(&amp;handle_iic);<span class="hljs-comment">/*这是IIC的初始化，还需要对应GPIO的初始化，这个函数内部会调用HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)这个函数*/</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_I2C_MspInit</span><span class="hljs-params">(I2C_HandleTypeDef* hi2c)</span><br>&#123;<br>    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span>(hi2c-&gt;I2C1)<br>    &#123;<br>        ...具体GPIO配置省略<br>        HAL_GPIO_Init();<br>        __HAL_RCC_I2C1_CLK_ENABLE();<br>        HAL_NVIC_SetPriority(I2C1_EV_IRQn, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);<br>        HAL_NVIC_SetPriority(I2C1_ER_IRQn, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*HAL库提供三种类型读写函（阻塞、非阻塞（其中包括中断和DMA））*/</span><br><span class="hljs-comment">//阻塞IIC发送、接受代码原型</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Transmit</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Receive</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_IsDeviceReady</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint32_t</span> Trials, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br><br><span class="hljs-comment">//非阻塞普通中断IIC发送、接受代码原型</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Transmit_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Receive_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br><br><span class="hljs-comment">//非阻塞DMA中断IIC发送、接受代码原型</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Transmit_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Receive_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p><strong>通过硬件IIC读取AT24C02代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><br><span class="hljs-comment">//AT24Cxx这是一个IIC接口的EEPROM存储芯片</span><br><span class="hljs-comment">//读写地址</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Write 0xA0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Read  0xA1</span><br><span class="hljs-comment">//三次写入的字符串</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str1[]=&#123;<span class="hljs-string">&quot;xyz666&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str2[]=&#123;<span class="hljs-string">&quot;1234567&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str3[]=&#123;<span class="hljs-string">&quot;abcdefg&quot;</span>&#125;;<br><span class="hljs-comment">//读取缓存区</span><br><span class="hljs-type">uint8_t</span> ReadBuffer[<span class="hljs-number">50</span>];<br><span class="hljs-comment">/* USER CODE END PV */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//阻塞方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str1,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>)==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>);<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_IT(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str2,<span class="hljs-keyword">sizeof</span>(str2))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_IT(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//DMA中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_DMA(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str3,<span class="hljs-keyword">sizeof</span>(str3))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_DMA(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li></ul><h1 id="3、串行外设接口（SPI）"><a href="#3、串行外设接口（SPI）" class="headerlink" title="3、串行外设接口（SPI）"></a>3、串行外设接口（SPI）</h1><h2 id="3-1简介"><a href="#3-1简介" class="headerlink" title="3.1简介"></a>3.1简介</h2><ul><li>SPI，是一<strong>种高速的，全双工，同步</strong>的通信总线，并且在芯片的管脚上只占用四根线。SPI分为主、从两种模式，一个SPI通讯系统需要包含一个（且只能是一个）主设备，一个或多个从设备。提供时钟的为主设备（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起。当存在多个从设备时，通过各自的片选信号进行管理。</li><li>4线SPI示意图<ul><li><img src="/./../photo/4%E7%BA%BFSPI%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="示意图"></li><li><strong>MISO</strong>： <strong>主设备输入&#x2F;从设备输出引脚</strong>。该引脚在从模式下发送数据，在主模式下接收数据。</li><li><strong>MOSI</strong>： <strong>主设备输出&#x2F;从设备输入引脚</strong>。该引脚在主模式下发送数据，在从模式下接收数据。</li><li><strong>SCLK</strong>：<strong>串行时钟信号</strong>，由主设备产生。</li><li><strong>CS&#x2F;SS</strong>：<strong>从设备片选信号</strong>，由主设备控制。它的功能是用来作为“片选引脚”，也<strong>就是选择指定的从设备</strong>，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。</li></ul></li><li>SPI工作原理<ul><li>在主机和从机都有一个串行移位寄存器，主机通过向它的 SPI 串行寄存 器写入一个字节来发起一次传输。串行移位寄存器通过 MOSI 信号线将字节传送给从机，从机 也将自己的串行移位寄存器中的内容通过 MISO 信号线返回给主机。这样，两个移位寄存器中 的内容就被交换。外设的写操作和读操作是同步完成的。<strong>如果只是进行写操作，主机只需忽略 接收到的字节。反之，若主机要读取从机的一个字节，就必须发送一个空字节引发从机传输。</strong></li></ul></li><li>SPI传输方式<ul><li><strong>SPI总共有三种传输方式：全双工、单工以及半双工传输方式。</strong></li></ul></li></ul><h2 id="3-2工作时序"><a href="#3-2工作时序" class="headerlink" title="3.2工作时序"></a>3.2工作时序</h2><ul><li><p>SPI四种不同工作模式由CPOL(时钟极性)和CPHA（时钟相位）来控制</p><ul><li><table><thead><tr><th align="center">SPI工作模式</th><th align="center">CPOL</th><th align="center">CPHA</th><th align="center">SCL空闲状态</th><th align="center">采样边沿</th><th align="center">采样时刻</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">低电平</td><td align="center">上升沿</td><td align="center">奇数边沿</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">低电平</td><td align="center">下降沿</td><td align="center">偶数边沿</td></tr><tr><td align="center">2</td><td align="center">1</td><td align="center">0</td><td align="center">高电平</td><td align="center">下降沿</td><td align="center">奇数边沿</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">1</td><td align="center">高电平</td><td align="center">上升沿</td><td align="center">偶数边沿</td></tr></tbody></table></li><li><p>以CPOL&#x3D;0,CPHA&#x3D;0为示例时序图，其他同理</p><ul><li><img src="/./../photo/SPI%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="时序图"></li><li>由图可以看出来，在传输开始前以及传输完成后，CPOL即SCL都为低电平，表示空闲的时候SCL为低电平状态，由于采样边沿是上升沿，即在第1、3、5、7…..等这些边沿进行采样。</li></ul></li></ul></li></ul><h2 id="3-3实例操作"><a href="#3-3实例操作" class="headerlink" title="3.3实例操作"></a>3.3实例操作</h2><ul><li><p><strong>基于stm32的HAL库配置SPI</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><br><span class="hljs-comment">//AT24Cxx这是一个IIC接口的EEPROM存储芯片</span><br><span class="hljs-comment">//读写地址</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Write 0xA0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Read  0xA1</span><br><span class="hljs-comment">//三次写入的字符串</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str1[]=&#123;<span class="hljs-string">&quot;xyz666&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str2[]=&#123;<span class="hljs-string">&quot;1234567&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str3[]=&#123;<span class="hljs-string">&quot;abcdefg&quot;</span>&#125;;<br><span class="hljs-comment">//读取缓存区</span><br><span class="hljs-type">uint8_t</span> ReadBuffer[<span class="hljs-number">50</span>];<br><span class="hljs-comment">/* USER CODE END PV */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//阻塞方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str1,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>)==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>);<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_IT(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str2,<span class="hljs-keyword">sizeof</span>(str2))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_IT(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//DMA中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_DMA(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str3,<span class="hljs-keyword">sizeof</span>(str3))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_DMA(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p><strong>SPI-&gt;norflash存储芯片的读写</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*仅仅介绍几个函数，具体的请参考完整代码*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_init</span><span class="hljs-params">()</span><br>&#123;<br>    GPIO_InitTypeDef gpio_init_struct;<span class="hljs-comment">//主要为了配置片选引脚</span><br>    ...配置代码省略<br>    HAL_GPIO_Init(GPIOX,&amp;gpio_init_struct)<br>    spi_init();<br>    spi_set_speed(SPI_SPEED_2);<span class="hljs-comment">//这个设置SPI速度的</span><br>    <span class="hljs-comment">/*有些flash芯片需要开启4字节地址模式*/</span>   <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_send_address</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> address)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (g_norflash_type == W25Q256) <span class="hljs-comment">/*  只有W25Q256支持4字节地址模式 */</span><br>    &#123;<br>        spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)((address)&gt;&gt;<span class="hljs-number">24</span>)); <span class="hljs-comment">/* 发送 bit31 ~ bit24 地址 */</span><br>    &#125; <br>    spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)((address)&gt;&gt;<span class="hljs-number">16</span>));     <span class="hljs-comment">/* 发送 bit23 ~ bit16 地址 */</span><br>    spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)((address)&gt;&gt;<span class="hljs-number">8</span>));      <span class="hljs-comment">/* 发送 bit15 ~ bit8  地址 */</span><br>    spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)address);             <span class="hljs-comment">/* 发送 bit7  ~ bit0  地址 */</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pbuf, <span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint16_t</span> datalen)</span><br>&#123;<br>    <span class="hljs-type">uint16_t</span> i;<br><br>    HAL_GPIO_WritePin(GPIOX,GPIO_PIN,GPIO_PIN_RESET);<span class="hljs-comment">//拉低片选选中芯片</span><br>    spi2_read_write_byte(FLASH_ReadData);       <span class="hljs-comment">/* 发送读取命令 */</span><br>    norflash_send_address(addr);                <span class="hljs-comment">/* 发送地址 */</span><br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;datalen;i++)<br>    &#123;<br>        pbuf[i] = spi2_read_write_byte(<span class="hljs-number">0XFF</span>);   <span class="hljs-comment">/* 循环读取 */</span><br>    &#125;<br>    <br>    HAL_GPIO_WritePin(GPIOX,GPIO_PIN,GPIO_PIN_SET);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pbuf, <span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint16_t</span> datalen)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> secpos;<br>    <span class="hljs-type">uint16_t</span> secoff;<br>    <span class="hljs-type">uint16_t</span> secremain;<br>    <span class="hljs-type">uint16_t</span> i;<br>    <span class="hljs-type">uint8_t</span> *norflash_buf;<br><br>    norflash_buf = g_norflash_buf;<br>    secpos = addr / <span class="hljs-number">4096</span>;       <span class="hljs-comment">/* 扇区地址 */</span><br>    secoff = addr % <span class="hljs-number">4096</span>;       <span class="hljs-comment">/* 在扇区内的偏移 */</span><br>    secremain = <span class="hljs-number">4096</span> - secoff;  <span class="hljs-comment">/* 扇区剩余空间大小 */</span><br>    <span class="hljs-keyword">if</span> (datalen &lt;= secremain)<br>    &#123;<br>        secremain = datalen;    <span class="hljs-comment">/* 不大于4096个字节 */</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        norflash_read(norflash_buf, secpos * <span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>);   <span class="hljs-comment">/* 读出整个扇区的内容 */</span><br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; secremain; i++)   <span class="hljs-comment">/* 校验数据 */</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (norflash_buf[secoff + i] != <span class="hljs-number">0XFF</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;      <span class="hljs-comment">/* 需要擦除, 直接退出for循环 */</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &lt; secremain)   <span class="hljs-comment">/* 需要擦除 */</span><br>        &#123;<br>            norflash_erase_sector(secpos);  <span class="hljs-comment">/* 擦除这个扇区 */</span><br><br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; secremain; i++)   <span class="hljs-comment">/* 复制 */</span><br>            &#123;<br>                norflash_buf[i + secoff] = pbuf[i];<br>            &#125;<br><br>            norflash_write_nocheck(norflash_buf, secpos * <span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>);  <span class="hljs-comment">/* 写入整个扇区 */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">/* 写已经擦除了的,直接写入扇区剩余区间. */</span><br>        &#123;<br>            norflash_write_nocheck(pbuf, addr, secremain);  <span class="hljs-comment">/* 直接写扇区 */</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (datalen == secremain)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">/* 写入结束了 */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">/* 写入未结束 */</span><br>        &#123;<br>            secpos++;               <span class="hljs-comment">/* 扇区地址增1 */</span><br>            secoff = <span class="hljs-number">0</span>;             <span class="hljs-comment">/* 偏移位置为0 */</span><br><br>            pbuf += secremain;      <span class="hljs-comment">/* 指针偏移 */</span><br>            addr += secremain;      <span class="hljs-comment">/* 写地址偏移 */</span><br>            datalen -= secremain;   <span class="hljs-comment">/* 字节数递减 */</span><br><br>            <span class="hljs-keyword">if</span> (datalen &gt; <span class="hljs-number">4096</span>)<br>            &#123;<br>                secremain = <span class="hljs-number">4096</span>;   <span class="hljs-comment">/* 下一个扇区还是写不完 */</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                secremain = datalen;<span class="hljs-comment">/* 下一个扇区可以写完了 */</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p><strong>扩展</strong></p><ul><li>SPI不仅仅只有4线的，还有6线的。多出来两根数据线，这样可以一个时钟周期传输两个字节</li></ul></li></ul><h1 id="4、控制局域网总线（CAN）"><a href="#4、控制局域网总线（CAN）" class="headerlink" title="4、控制局域网总线（CAN）"></a>4、控制局域网总线（CAN）</h1><h2 id="4-1简介"><a href="#4-1简介" class="headerlink" title="4.1简介"></a>4.1简介</h2><ul><li>控制器局域网总线（CAN，Controller Area Network）是一种用于实时应用的串行通讯协议总线，它可以使用双绞线来传输信号，是世界上应用最广泛的现场总线之一。CAN协议用于汽车中各种不同元件之间的通信，以此取代昂贵而笨重的配电线束。该协议的健壮性使其用途延伸到其他自动化和工业应用。CAN协议的特性包括完整性的串行数据通讯、提供实时支持、传输速率高达1Mb&#x2F;s、同时具有11位的寻址以及检错能力。</li></ul><h2 id="4-2CAN总线结构"><a href="#4-2CAN总线结构" class="headerlink" title="4.2CAN总线结构"></a>4.2CAN总线结构</h2><ul><li><strong>闭环总线结构</strong>：如图所示，总线两端各连接一个120欧的电阻，两根信号线形成回路。这种CAN总线网络由ISO 11898标准定义，是高速、短距离的CAN网络，通信速率为125kbit&#x2F;s到1Mbit&#x2F;s。在1Mbit&#x2F;s通讯速率时，总线长度最长达40m。<ul><li><img src="/./../photo/%E9%97%AD%E7%8E%AFCAN%E7%BB%93%E6%9E%84.png" alt="总线结构图"></li></ul></li><li><strong>开环总线结构</strong>：两根信号线独立，各自串联一个2.2k欧的电阻。这种CAN总线网络由ISO11519-2标准定义，是低速、远距离的CAN网络，通信速率最高125kbit&#x2F;s。在40kbit&#x2F;s速率时，总线最长距离可达1000m。<ul><li><img src="/./../photo/%E5%BC%80%E7%8E%AF%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="示意图"></li></ul></li><li><strong>CAN总线特性</strong>：CAN总线由两根信号线，CANH和CANL，没有时钟同步信号。所以CAN是一种异步通信方式。两根信号线的电压差CANH-CANL表示CAN总线的电平，与传输的逻辑信号1或0对应。对应于逻辑1的称为隐性（Recessive）电平，对应于逻辑0成为显性（Dominant）电平。<ul><li><img src="/./../photo/%E9%80%BB%E8%BE%91%E7%94%B5%E5%B9%B3%E4%BF%A1%E5%8F%B7.png" alt="示意图"></li><li>在开环跟闭环的结构里面，隐形电平和显型电平对应的电压值略有不同</li><li>隐性电平表示逻辑1</li><li>显性电平表示逻辑0</li></ul></li><li><strong>CAN总线特点</strong>:<ul><li><strong>实时性：</strong> CAN总线具有优越的实时性能，适用于需要及时传输数据的应用，如汽车控制系统、工业自动化等。仲裁机制和帧优先级的设计保证了低延迟和可预测性。<strong>多主机系统：</strong> CAN支持多主机系统，多个节点可以同时发送和接收数据。<strong>差分信号传输：</strong> CAN使用差分信号传输，通过两个线路（CAN_H和CAN_L）之间的电压差来传递信息。这种差分传输方式提供了良好的抗干扰性能。<strong>仲裁机制：</strong> CAN总线采用非破坏性仲裁机制，通过比较消息标识符的优先级来决定哪个节点有权继续发送数据。这种机制确保了总线上数据传输的有序性，避免了冲突。<strong>广播通信：</strong> CAN总线采用广播通信方式，即发送的数据帧可以被总线上的所有节点接收。<strong>错误检测和处理：</strong>CAN总线具有强大的错误检测和处理机制。通过CRC检查和其他错误检测手段。<strong>多种帧类型：</strong>CAN总线上的节点没有地址的概念。CAN总线上的数据是以帧为单位传输的，帧又分为数据帧、遥控帧等多种帧类型，帧包含需要传输的数据或控制信息。<strong>特定标识符</strong>：每一个帧有一个标识符（Identifier，一下简称ID）。ID不是地址，它表示传输数据的类型，也可以用于总线仲裁时确定优先级。<strong>滤波特性：</strong>每个CAN节点都接收数据，但是可以对接收的帧根据ID进行过滤。<strong>半双工：</strong>CAN总线通信时半双工的，即总线不能同时发送和接收。在多个节点竞争总线进行发送时，通过ID的优先级进行仲裁。<strong>无时钟信号：</strong>CAN总线没有用于同步的时钟信号，所以需要规定CAN总线通信的波特率，所以节点都是用同样的波特率进行通信。</li></ul></li></ul><h2 id="4-3CAN通信的重点（各种帧）"><a href="#4-3CAN通信的重点（各种帧）" class="headerlink" title="4.3CAN通信的重点（各种帧）"></a>4.3CAN通信的重点（各种帧）</h2><ul><li><p>CAN网络中通信通过5种类型的帧进行的。</p><ul><li><p>5种帧类型以及用途如下表</p><ul><li><table><thead><tr><th align="left">帧类型</th><th align="left">帧用途</th></tr></thead><tbody><tr><td align="left">数据帧（Data frame）</td><td align="left">节点发送的包含ID和数据的帧，用于发送单元向接收单元传送数据的帧。</td></tr><tr><td align="left">遥控帧（Remote frame）</td><td align="left">节点向网络上的其他节点发出的某个ID的数据请求，发送节点收到遥控帧后就可以发送相应ID的数据帧</td></tr><tr><td align="left">错误帧（Error frame）</td><td align="left">节点检测出错误时，向其他节点发送的通知错误的帧</td></tr><tr><td align="left">过载帧（Overload frame）</td><td align="left">接收单元未做好接收数据的准备时发送的帧，发送节点收到过载帧后可以暂缓发送数据帧</td></tr><tr><td align="left">帧间空间（Inter-frame space）</td><td align="left">用于将数据帧、遥控帧与前后的帧分隔开的帧</td></tr></tbody></table></li></ul></li></ul></li><li><p><strong>标准格式数据帧</strong>：由7个段构成，如下图</p><ul><li><p><img src="/./../photo/CAN%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="数据帧"></p><ul><li>帧起始:一位显性电平；</li><li>仲裁段禁止ID高7位全为隐性电平；</li><li>控制段，保留位r0必须以显性电平发送。DLC表示数据段的字节数</li><li>CRC段，根据多项式生成CRC校验码</li><li>ACK段：发送方的ACK发送2个位的隐性位，接收单元ACK，在ACK位发送一个显性位，通知接收正常</li><li>帧结束：7个隐性位构成。</li></ul></li></ul></li><li><p><strong>标准遥控帧</strong>：由6段构成，图示省略</p><ul><li>跟数据帧少了一个数据段<ul><li>遥控帧的RTR位为隐性位，没有数据段</li><li>遥控帧的数据长度码DLC以请求数据帧的数据长度码表示</li></ul></li></ul></li><li><p><strong>错误帧</strong>：用于在接收和发送消息时检测出错误通知错误的帧。错误帧由错误标志和错误界定符构成。如图所示</p><ul><li><img src="/./../photo/%E9%94%99%E8%AF%AF%E5%B8%A7.png" alt="错误帧"><ul><li>主动错误标志：6 个位的显性位。</li><li>被动错误标志：6 个位的隐性位。</li><li>错误界定符由 8 个位的隐性位构成。</li></ul></li></ul></li><li><p><strong>过载帧</strong>：过载帧是用于接收单元通知其尚未完成接收准备的帧。过载帧由过载标志和过载界定符构成。</p><ul><li>过载标志：6 个位的显性位。过载标志的构成与主动错误标志的构成相同。过载界定符：8 个位的隐性位。过载界定符的构成与错误界定符的构成相同。</li></ul></li><li><p><strong>帧间隔</strong>：帧间隔是用于分隔数据帧和遥控帧的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。</p><ul><li>间隔：3 个位的隐性位。总线空闲：隐性电平，无长度限制（0 亦可）。本状态下，可视为总线空闲，要发送的单元可开始访问总线。延迟传送（发送暂时停止）：8 个位的隐性位。只在处于被动错误状态的单元刚发送一个消息后的帧间隔中包含的段。</li></ul></li></ul><h2 id="4-4CAN总线优先级及同步"><a href="#4-4CAN总线优先级及同步" class="headerlink" title="4.4CAN总线优先级及同步"></a>4.4CAN总线优先级及同步</h2><ul><li><p><strong>优先级决定</strong>：在总线空闲态，最先开始发送消息的单元获得发送权。多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的单元可继续发送。</p></li><li><p><strong>数据帧和遥控帧的优先级</strong>：具有相同 ID 的数据帧和遥控帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权，可继续发送。</p></li><li><p><strong>CAN通信错误种类</strong>：如下表</p><ul><li><img src="/./../photo/CAN%E9%80%9A%E4%BF%A1%E9%94%99%E8%AF%AF.png" alt="错误表"></li></ul></li><li><p><strong>位时序</strong>：由发送单元在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为 4 段。同步段（SS）传播时间段（PTS）</p><p>相位缓冲段 1（PBS1）相位缓冲段 2（PBS2）这些段又由可称为 Time Quantum（以下称为 Tq）的最小时间单位构成。</p></li><li><p><strong>CAN通信同步的方法</strong>：CAN 协议的通信方法为 NRZ（Non-Return to Zero）方式。各个位的开头或者结尾都没有附加同步信号。发送单元以与位时序同步的方式开始发送数据。另外，接收单元根据总线上电平的变化进行同步并进行接收工作。但是，发送单元和接收单元存在的时钟频率误差及传输路径上的（电缆、驱动器等）相位延迟会引起同步偏差。因此接收单元通过硬件同步或者再同步的方法调整时序进行接收。</p></li></ul><h2 id="4-5CAN实例操作"><a href="#4-5CAN实例操作" class="headerlink" title="4.5CAN实例操作"></a>4.5CAN实例操作</h2><ul><li><p>基于stm32的CAN通信</p><ul><li><p>CAN 发送流程为：程序选择 1 个空置的邮箱（TME&#x3D;1）→设置标识符（ID），数据长度和 发送数据→设置 CAN_TIxR 的 TXRQ 位为 1，请求发送→邮箱挂号（等待成为最高优先级）→ 预定发送（等待总线空闲）→发送→邮箱空置。</p></li><li><p>CAN 接收到的有效报文，被存储在 3 级邮箱深度的 FIFO 中。CAN 接收流程为：FIFO 空→收到有效报文→挂号1（存入 FIFO 的一个邮箱，这个由硬件 控制，我们不需要理会）→收到有效报文→挂号2→收到有效报文→挂号_3→收到有效报文溢 出。</p></li><li><p>重点是构造发送的数据消息，跟接收的数据消息配置。</p></li><li><p>并且配置的时候有多种模式可选择，比如回环模式和正常模式</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*HAL库配置CAN控制器,简略代码，列出关键,以CAN1为例子*/</span><br>CAN_HandleTypeDef   g_canx_handler;     <span class="hljs-comment">/* CANx句柄 */</span><br>CAN_TxHeaderTypeDef g_canx_txheader;    <span class="hljs-comment">/* 发送参数句柄 */</span><br>CAN_RxHeaderTypeDef g_canx_rxheader;    <span class="hljs-comment">/* 接收参数句柄 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">can_init</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> tsjw, <span class="hljs-type">uint32_t</span> tbs2, <span class="hljs-type">uint32_t</span> tbs1, <span class="hljs-type">uint16_t</span> brp, <span class="hljs-type">uint32_t</span> mode)</span><br>&#123;<br>    <span class="hljs-comment">/*CAN的各种配置*/</span><br>    ...代码省略<br>    HAL_CAN_Init(&amp;g_canx_handler);<span class="hljs-comment">//HAL_CAN_Init()-&gt;内部调用HAL_CAN_MspInit()</span><br>    <span class="hljs-comment">/*配置CAN的过滤操作*/</span><br>    CAN_FilterTypeDef sFilterConfig;<br>    ...配置过程省略<br>    HAL_CAN_ConfigFilter(&amp;g_canx_handler, &amp;sFilterConfig)<br>    <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_CAN_MspInit</span><span class="hljs-params">(CAN_HandleTypeDef *hcan)</span><span class="hljs-comment">//用来配置CAN相关的引脚的状态</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (CAN1 == hcan-&gt;Instance)<br>    &#123;<br>        __HAL_RCC_GPIOX_CLK_ENABLE();<br>        __HAL_RCC_CAN1_CLK_ENABLE();<br>        GPIO_InitTypeDef gpio_initure;<br>        ...具体配置省略<br>        HAL_GPIO_Init(GPIOX, &amp;gpio_initure);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">can_send_msg</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> id, <span class="hljs-type">uint8_t</span> *msg, <span class="hljs-type">uint8_t</span> len)</span><br>&#123;<br>      <span class="hljs-type">uint32_t</span> TxMailbox = CAN_TX_MAILBOX0;<br>    <br>      g_canx_txheader.StdId = id;         <span class="hljs-comment">/* 标准标识符 */</span><br>      g_canx_txheader.ExtId = id;         <span class="hljs-comment">/* 扩展标识符(29位) 标准标识符情况下，该成员无效*/</span><br>      g_canx_txheader.IDE = CAN_ID_STD;   <span class="hljs-comment">/* 使用标准标识符 */</span><br>      g_canx_txheader.RTR = CAN_RTR_DATA; <span class="hljs-comment">/* 数据帧 */</span><br>      g_canx_txheader.DLC = len;<br><br>  <span class="hljs-keyword">if</span> (HAL_CAN_AddTxMessage(&amp;g_canx_handler, &amp;g_canx_txheader, msg, &amp;TxMailbox) != HAL_OK) <span class="hljs-comment">/* 发送消息 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">while</span> (HAL_CAN_GetTxMailboxesFreeLevel(&amp;g_canx_handler) != <span class="hljs-number">3</span>); <span class="hljs-comment">/* 等待发送完成,所有邮箱(有三个邮箱)为空 */</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">can_receive_msg</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> id, <span class="hljs-type">uint8_t</span> *buf)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (HAL_CAN_GetRxFifoFillLevel(&amp;g_canx_handler, CAN_RX_FIFO0) == <span class="hljs-number">0</span>)     <span class="hljs-comment">/* 没有接收到数据 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (HAL_CAN_GetRxMessage(&amp;g_canx_handler, CAN_RX_FIFO0, &amp;g_canx_rxheader, buf) != HAL_OK)  <span class="hljs-comment">/* 读取数据 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (g_canx_rxheader.StdId!= id || g_canx_rxheader.IDE != CAN_ID_STD || g_canx_rxheader.RTR != CAN_RTR_DATA)       <span class="hljs-comment">/* 接收到的ID不对 / 不是标准帧 / 不是数据帧 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>  &#125;<br><br>  <span class="hljs-keyword">return</span> g_canx_rxheader.DLC;<br>&#125;<br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
