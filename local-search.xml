<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ARM体系架构</title>
    <link href="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容部分摘录自《ARM Cortex-M3 权威指南》、《ARM Cortex-M3与Cortex-M4权威指南》、《ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition》、韦东山老师的课程《深入理解ARM架构》，仅用于个人交流与学习，如涉及侵权请联系站长删除！</p></blockquote><h1 id="第一章-ARM架构版本及处理器系列介绍"><a href="#第一章-ARM架构版本及处理器系列介绍" class="headerlink" title="第一章 ARM架构版本及处理器系列介绍"></a>第一章 ARM架构版本及处理器系列介绍</h1><h2 id="1-ARM背景"><a href="#1-ARM背景" class="headerlink" title="1.ARM背景"></a>1.ARM背景</h2><p>ARM在1990年成立，当初的名字是“Advanced RISC Machines Ltd.,”，当时它是三家公司的合资——它们分别是苹果电脑，Acorn电脑公司，以及VLSI技术（公司）。</p><p>ARM的版本分为两类，一个是内核版本，一个处理器版本。</p><ul><li>内核版本也就是ARM架构，如ARMv1、ARMv2、ARMv3、ARMv4、ARMv5、ARMv6、ARMv7、ARMv8等。</li><li>处理器版本也就是ARM处理器，如ARM1、ARM9、ARM11、ARM Cortex-A（A7、A9、A15），ARM Cortex-M（M1、M3、M4）、ARM Cortex-R，这个也是我们通常意义上所指的ARM版本。</li></ul><h2 id="2-ARM架构与处理器的关系"><a href="#2-ARM架构与处理器的关系" class="headerlink" title="2.ARM架构与处理器的关系"></a>2.ARM架构与处理器的关系</h2><p>基于不同的ARM架构可以设计出不同特点的ARM处理器。比如基于ARMv3架构设计出的处理器ARM6、ARM7，这两款处理器适用于不同的场景，硬件可能不同，但是架构指令集是一样的。</p><p>举个例子，比如说盖房子，早期因为发展落后，盖的都是平房，这就是一种架构(ARMv5)，然后这种平房架构你可以设计出一款三室一厅的款式， 这叫ARM7处理器。 然后其他人(芯片设计公司)想盖房子的就买你这个款式去盖，接着过一段时间，有人觉得光三室一厅的不好， 我还想每个房间有独立卫! 于是，ARM就满足你们的要求，出个独卫的款式(ARM9)。</p><p>即ARMv5等是指令集的架构，ARM7&#x2F;9等是基于架构设计出的内核处理器。ARM的架构都是基于RISC指令集而设计的，内核处理器是实现这一指令集的硬件架构的基础。</p><h2 id="3-ARM版本"><a href="#3-ARM版本" class="headerlink" title="3.ARM版本"></a>3.ARM版本</h2><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/a.png"></p><p>最近的几年，基于从ARMv6开始的新设计理念，ARM进一步扩展了它的CPU设计，成果 就是ARMv7架构的闪亮登场。在这个版本中，内核架构首次从单一款式变成3种款式。 </p><ul><li><p>款式A：设计用于高性能的“开放应用平台”——越来越接近电脑了 </p></li><li><p>款式R：用于高端的嵌入式系统，尤其是那些带有实时要求的——又要快又要实时。 </p></li><li><p>款式M：用于深度嵌入的，单片机风格的系统中——本文章主要讲解的知识。</p></li></ul><p>让我们再进距离地考察这3种款式： </p><ul><li>款式A（ARMv7‐A）：需要运行复杂应用程序的“应用处理器” 。支持大型嵌入式操作系统，比如Symbian（诺基亚智能手机用），Linux，以及微软 的Windows CE和智能手机操作系统Windows Mobile。这些应用需要劲爆的处理性能，并 且需要硬件MMU实现的完整而强大的虚拟内存机制，还基本上会配有Java支持，有时 还要求一个安全程序执行环境。典型的产品包括高端手机和手持仪器，电子钱包以及金融事务处理机。 </li><li>款式R（ARMv7‐R）：硬实时且高性能的处理器。标的是高端实时市场。那些高级的玩意，像高档轿车的组件，大型发电机控制器，机器手臂控制器等，它们使用的处理 器不但要很好很强大，还要极其可靠，对事件的反应也要极其敏捷。 </li><li>款式M（ARMv7‐M）：认准了旧世代单片机的应用而量身定制。在这些应用中，尤其是 对于实时控制系统，低成本、低功耗、极速中断反应以及高处理效率，都是至关重要的。  Cortex系列是v7架构的第一次亮相，其中Cortex‐M3就是按款式M设计的。</li></ul><h1 id="第二章-ARM基础知识"><a href="#第二章-ARM基础知识" class="headerlink" title="第二章 ARM基础知识"></a>第二章 ARM基础知识</h1><h2 id="1-哈弗架构与冯诺伊曼架构"><a href="#1-哈弗架构与冯诺伊曼架构" class="headerlink" title="1.哈弗架构与冯诺伊曼架构"></a>1.<strong>哈弗架构与冯诺伊曼架构</strong></h2><p>CPU架构可以分为哈弗架构与冯诺伊曼架构，如下图所示。</p><ul><li><p><strong>哈弗架构</strong>中指令与数据分开存放，CPU可以同时读入指令、读写数据。</p><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/b.png"></p></li><li><p><strong>冯诺伊曼架构</strong>中指令、数据混合存放，CPU依次读取指令、读写数据，不可同时操作指令和数据。</p><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/c.png"></p></li></ul><blockquote><p>Cortex‐M3采用了哈佛结构，拥有独立的指令总线和数据总线，可以让取指与数据访问 并行不悖。</p></blockquote><h2 id="2-RISC与CISC"><a href="#2-RISC与CISC" class="headerlink" title="2. RISC与CISC"></a>2. RISC与CISC</h2><ul><li><strong>复杂指令集CISC</strong>:   以Intel、AMD的X86 CPU为代表，CISC也是要通过操作内存、寄存器、运算器来完成复杂指令的。它在实现时，是将复杂指令转换成了一个微程序，微程序在制造CPU时就已存储于微服务存储器。一个微程序包含若干条微指令（也称微码），执行复杂指令时，实际上是在执行一个微程序。这也带来两种指令集的一个差别，微程序的执行是不可被打断的，而RISC指令之间可以被打断，所以理论上RISC可更快响应中断。特点：</li><li><strong>精简指令集RISC</strong>：以ARM、IBM Power为代表，设计初衷针对CISC CPU复杂的弊端，选择一些可以在单个CPU周期完成的指令，以降低CPU的复杂度，将复杂性交给编译器</li></ul><blockquote><p><strong>ARM公司的芯片都使用RISC指令集，对内存只有load&#x2F;store操作，数据的处理是在CPU寄存器上进行。</strong></p></blockquote><ul><li>二者的比较：<ul><li>CISC的指令能力强，单多数指令使用率低却增加了CPU的复杂度，指令是可变长格式；</li><li>RISC的指令大部分为单周期指令，指令长度固定，操作寄存器，对于内存只有Load&#x2F;Store操作</li><li>CISC支持多种寻址方式；RISC支持的寻址方式</li><li>CISC通过微程序控制技术实现；</li><li>RISC增加了通用寄存器，硬布线逻辑控制为主，采用流水线</li><li>CISC的研制周期长</li><li>RISC优化编译，有效支持高级语言</li></ul></li></ul><h1 id="第三章-ARM-寄存器"><a href="#第三章-ARM-寄存器" class="headerlink" title="第三章 ARM 寄存器"></a>第三章 ARM 寄存器</h1><p>这里以Cortex‐M3 &#x2F;Cortex‐M4&#x2F;Cortex‐A7处理器为例，他们拥有 R0‐R15 的寄存器组。其中 R13 作为堆栈指针 SP。SP 有两个，但在同一 时刻只能有一个可以看到，这也就是所谓的“banked”寄存器。</p><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20231021162714042.png" alt="image-20231021162714042"></p><ul><li>R0-R12：通用寄存器 ，R0‐R12 都是 32 位通用寄存器，用于数据操作。但是注意：绝大多数 16 位 Thumb 指令只能访 问 R0‐R7，而 32 位 Thumb‐2 指令可以访问所有寄存器。</li><li>Banked R13: 两个堆栈指针 <ul><li>主堆栈指针（MSP）：复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程（包 括中断服务例程） </li><li>进程堆栈指针（PSP）：由用户的应用程序代码使用。</li></ul></li><li>R14：连接寄存器，当呼叫一个子程序时，由 R14 存储返回地址 </li><li>R15：程序计数寄存器 ，指向当前的程序地址。如果修改它的值，就能改变程序的执行流</li><li>特殊功能寄存器 <ul><li>程序状态字寄存器组（PSRs）  </li><li>中断屏蔽寄存器组（PRIMASK, FAULTMASK, BASEPRI）  </li><li>控制寄存器（CONTROL）</li></ul></li></ul><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20231021163136833.png" alt="image-20231021163136833"></p><p>功能如下表：</p><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20231021163233661.png" alt="image-20231021163233661"></p><h1 id="第四章-ARM汇编"><a href="#第四章-ARM汇编" class="headerlink" title="第四章 ARM汇编"></a>第四章 ARM汇编</h1><h2 id="1-ARM汇编概述"><a href="#1-ARM汇编概述" class="headerlink" title="1.ARM汇编概述"></a>1.ARM汇编概述</h2><p>①最初，ARM公司发布两类指令集：</p><ul><li><p><strong>Thumb指令集：</strong>这是16位的，每条指令占据16位，节省空间</p></li><li><p><strong>ARM指令集：</strong>这是32位的，每条指令占据32位，高效，但是太占空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV R1, #1;Thumb指令：len(mov) + len(r1) + len(立即数) = 16bit<br>MOV R1, #1;ARM指令：len(mov) + len(r1) + len(立即数) = 32bit<br></code></pre></td></tr></table></figure></li></ul><p>要节省空间时用Thumb指令，要效率时用ARM指令</p><p>②一个CPU既可以运行Thumb指令，也能运行ARM指令。怎么区分当前指令是Thumb还是ARM指令呢？</p><p>​程序状态寄存器中有一位，名为“T”，它等于1时表示当前运行的是Thumb指令。</p><p>③假设函数A是使用Thumb指令写的，函数B是使用ARM指令写的，怎么调用A&#x2F;B？</p><p>​我们可以往PC寄存器里写入函数A或B的地址，就可以调用A或B，</p><p>④但是怎么让CPU在执行A函数是进入Thumb状态，在执行B函数时进入ARM状态？</p><p>​做个手脚：</p><p>​调用函数A时，让PC寄存器的BIT0等于1，即：PC&#x3D;函数A地址+(1&lt;&lt;0)；</p><p>​调用函数B时，让PC寄存器的BIT0等于0:，即：PC&#x3D;函数B地址</p><p>⑤但是这样做太麻烦，于是引入Thumb2指令集</p><ul><li><strong>Thumb2指令集：</strong>它支持16位指令、32位指令混合编程。</li></ul><h2 id="2-区分指令集"><a href="#2-区分指令集" class="headerlink" title="2.区分指令集"></a>2.区分指令集</h2><p>ARM公司推出了： Unified Assembly Language UAL，统一汇编语言，我们不需要去区分这些指令集</p><p>我们只需要在程序前面用CODE32&#x2F;CODE16&#x2F;THUMB表示指令集:ARM&#x2F;Thumb&#x2F;Thumb2</p><h2 id="3-汇编指令格式"><a href="#3-汇编指令格式" class="headerlink" title="3.汇编指令格式"></a>3.汇编指令格式</h2><blockquote><p>参考《DEN0013D_cortex_a_series_PG.pdf》P70</p><p>《ARM Cortex-M3与Cortex-M4权威指南.pdf》第5章汇编指令可以分为几大类：数据处理、内存访问、跳转、饱和运算、其他指令</p></blockquote><p>以“数据处理”指令为例，UAL汇编格式为：</p><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/image-20231021175310394.png" alt="image-20231021175310394"></p><ul><li><p>Operation表示各类汇编指令，比如ADD、MOV；</p></li><li><p>cond表示conditon，即该指令执行的条件；</p></li><li><p>S表示该指令执行后，会去修改程序状态寄存器；</p></li><li><p>Rd为目的寄存器，用来存储运算的结果；</p></li><li><p>Rn、Operand2是两个源操作数</p></li></ul><h2 id="4-常用汇编指令"><a href="#4-常用汇编指令" class="headerlink" title="4.常用汇编指令"></a>4.常用汇编指令</h2><h3 id="1-内存访问指令"><a href="#1-内存访问指令" class="headerlink" title="1.内存访问指令"></a>1.内存访问指令</h3><p>加载指令LDR：Load Register</p><p>读多个寄存器</p><p>存储指令STR：Store Register</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0X20000<br>LDR R1, =0X1234<br>STR R1,[R0]      ;将R1里面的值写入到R0指向的地址里<br><br>LDMIA R0!, &#123; R4-R11 &#125;;lrmia: ldr mutiple inc after<br>;ldr r0 [r4]   r0 = r0 + 4<br>;ldr r0 [r5]   r0 = r0 + 4<br></code></pre></td></tr></table></figure><h3 id="2-数据处理指令"><a href="#2-数据处理指令" class="headerlink" title="2.数据处理指令"></a>2.数据处理指令</h3><p>加法指令ADD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV R2,#1<br>MOV R3,#2<br>ADD R1,R2,R3;R1 = R2 + R3<br></code></pre></td></tr></table></figure><p>减法指令SUB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV R2,#1<br>MOV R3,#2<br>ADD R1,R3,R2;R1 = R3 - R2<br></code></pre></td></tr></table></figure><p>位操作指令AND&#x2F;BIC&#x2F;ORR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0XFFFFFFFF<br>AND R0,R0,#(1&lt;&lt;4);与：只保留第四位<br>LDR R0, =0XFFFFFFFF<br>BIC R0,R0,#(1&lt;&lt;4);位清除：清除第四位<br>LDR R0, =0<br>ORR R0,#(1&lt;&lt;2|1&lt;&lt;3);或：设置第2、3位为1<br></code></pre></td></tr></table></figure><p>比较指令CMP&#x2F;TST</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0X12<br>LDR R1, =0X12<br>CMP R0,R1;比较R0-R1里面的结果，结果存放在程序装载寄存器<br>MOVEQ R0, #2；如果相等，执行这条指令，R0=2<br><br>TST R0,R1;测试R0&amp;R1的结果<br></code></pre></td></tr></table></figure><h3 id="3-跳转指令"><a href="#3-跳转指令" class="headerlink" title="3.跳转指令"></a>3.跳转指令</h3><ul><li><p>B：Branch，跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">B Delay<br>Delay<br>MOV R0, #5<br>Loop<br>SUBS R0,R0,#1<br>BNE Loop;不等于0就一直循环<br>MOV PC, LR;结束，将LR值返回给PC<br></code></pre></td></tr></table></figure></li><li><p>BL：Branch with Link，跳转前先把返回地址保持在LR寄存器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">BL Delay<br>MOV R1, #1;执行完之后会直接跳转到这条指令 PC=LR+4<br>Delay<br>MOV R0, #5<br>Loop<br>SUBS R0,R0,#1<br>BNE Loop;不等于0就一直循环<br>MOV PC, LR;结束，将LR值返回给PC<br></code></pre></td></tr></table></figure></li><li><p>BX：Branch and eXchange，根据跳转地址的BIT0切换为ARM或Thumb状态(0：ARM状态，1：Thumb状态)</p></li><li><p>BLX：Branch with Link and eXchange ，根据跳转地址的BIT0切换为ARM或Thumb状态(0：ARM状态，1：Thumb状态)#</p></li></ul><h3 id="4-CPU操作指令"><a href="#4-CPU操作指令" class="headerlink" title="4.CPU操作指令"></a>4.CPU操作指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">;开启CPU接收中断<br>cpsie i<br>cpsie f<br><br>;存储器屏蔽指令:确保前面的指令和数据都处理完成<br>dsb;数据同步屏蔽<br>isb;指令同步屏蔽<br></code></pre></td></tr></table></figure><h1 id="五、异常与中断"><a href="#五、异常与中断" class="headerlink" title="五、异常与中断"></a>五、异常与中断</h1><h2 id="1-异常与中断的概念引入与处理流程"><a href="#1-异常与中断的概念引入与处理流程" class="headerlink" title="1.异常与中断的概念引入与处理流程"></a>1.异常与中断的概念引入与处理流程</h2><h3 id="1-1-使用生活实例引入中断"><a href="#1-1-使用生活实例引入中断" class="headerlink" title="1.1 使用生活实例引入中断"></a>1.1 使用生活实例引入中断</h3><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/001_mother_son.png"></p><p>假设有个大房间里面有小房间，婴儿正在睡觉，他的妈妈在外面看书。<br>问：这个母亲怎么才能知道这个小孩醒？</p><ol><li>过一会打开一次房门，看婴儿是否睡醒，然后接着看书</li><li>一直等到婴儿发出声音以后再过去查看，期间都在读书</li></ol><p>第一种方法叫做<strong>查询方式</strong>：</p><ul><li>优点：简单 </li><li>缺点： 累</li></ul><p>如何写程序？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-number">1</span> read <span class="hljs-title function_">book</span><span class="hljs-params">(读书)</span><br>2 open <span class="hljs-title function_">door</span><span class="hljs-params">(开门)</span><br>  <span class="hljs-title function_">if</span><span class="hljs-params">(小孩还在睡)</span><br> <span class="hljs-title function_">return</span><span class="hljs-params">(继续读书)</span><br>   <span class="hljs-keyword">else</span><br> 照顾小孩<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方法叫<strong>中断方式</strong>：</p><ul><li>优点：不累</li><li>缺点：复杂</li></ul><p>如何写程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>read book<br>&#125;<br>中断服务程序() <span class="hljs-comment">//核心问题：如何被调用？</span><br>&#123;<br>处理照顾小孩<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-母亲如何处理中断"><a href="#1-2-母亲如何处理中断" class="headerlink" title="1.2 母亲如何处理中断"></a>1.2 母亲如何处理中断</h3><p>我们还是看看母亲被小孩哭声打断如何照顾小孩？</p><p>母亲的处理过程</p><ul><li>平时看书</li><li>发生了各种声音，如何处理这些声音<ul><li>有远处的猫叫（听而不闻，忽略）</li><li>门铃声有快递（开门收快递）</li><li>小孩哭声（打开房门，照顾小孩）</li></ul></li><li>母亲的处理<ul><li>只会处理门铃声和小孩哭声<ul><li>先在书中放入书签，合上书(保存现场)</li><li>去处理 (调用对应的中断服务程序)</li><li>继续看书(恢复现场)</li></ul></li></ul></li></ul><p>不同情况，不同处理</p><ul><li>对于门铃：开门取快件</li><li>对于哭声:照顾小孩</li></ul><h3 id="1-3-ARM系统中异常与中断处理流程"><a href="#1-3-ARM系统中异常与中断处理流程" class="headerlink" title="1.3 ARM系统中异常与中断处理流程"></a>1.3 ARM系统中异常与中断处理流程</h3><p>我们将母亲的处理过程抽象化：</p><ul><li>母亲的头脑相当于CPU<ul><li>耳朵听到声音会发送信号给脑袋</li><li>声音来源有很多种<ul><li>有远处的猫叫，门铃声，小孩哭声</li></ul></li><li>这些声音传入耳朵，再由耳朵传给大脑</li><li>除了这些可以中断母亲的看书，还有其他情况，比如：<ul><li>身体不舒服</li><li>有只蜘蛛掉下来</li><li>对于特殊情况无法回避，必须立即处理</li></ul></li></ul></li></ul><p>对于arm系统，异常与中断的硬件框图如下：</p><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/002_exception_on_arm.png"></p><p>所有的中断源(按键、定时器等)，它们发出的中断汇聚到<strong>中断控制器</strong>，<br>再由中断控制器发信号给CPU，告诉它发生了那些紧急情况。</p><p>除了这些中断，还有什么可以打断CPU的运行？</p><ul><li>指令不对</li><li>数据访问有问题</li><li>reset信号</li><li>等等，这些都可以打断断CPU，这些被称为<strong>异常</strong></li><li>中断属于一种异常</li></ul><p>ARM系统中如何处理异常与中断？重点在于<strong>保存现场</strong>以及<strong>恢复现场</strong>，<br>处理过程如下：</p><ul><li>保存现场(各种寄存器)</li><li>处理异常(中断属于一种异常)</li><li>恢复现场</li></ul><p>细化一下，在ARM系统中如何使用异常(中断)？</p><ul><li><p>初始化</p><ul><li>设置中断源，让它可以产生中断</li><li>设置中断控制器(可以屏蔽某个中断，优先级)</li><li>设置CPU总开关，使能中断</li></ul></li><li><p>执行其他程序：正常程序</p></li><li><p>产生中断，举例：按下按键—&gt;中断控制器—&gt;CPU</p></li><li><p>cpu每执行完一条指令都会检查有无中断&#x2F;异常产生</p></li><li><p>发现有中断&#x2F;异常产生，开始处理：</p><ul><li>保存现场</li><li>分辨异常&#x2F;中断，调用对于异常&#x2F;中断的处理函数</li><li>恢复现场</li></ul></li></ul><p>不同的芯片，不同的架构，在这方面的处理稍有差别：</p><ul><li><p>保存&#x2F;恢复现场：cortex M3&#x2F;M4是硬件实现的，cortex A7是软件实现的</p></li><li><p>CPU中止当前执行，跳转去执行处理异常的代码：也有差异</p><ul><li><p>cortex M3&#x2F;M4在向量表上放置的是函数地址</p></li><li><p>cortex A7在向量表上放置的是跳转指令</p></li></ul></li></ul><h2 id="2-ARM架构中异常与中断的处理"><a href="#2-ARM架构中异常与中断的处理" class="headerlink" title="2.ARM架构中异常与中断的处理"></a>2.ARM架构中异常与中断的处理</h2><h3 id="1-1-处理流程是一样的"><a href="#1-1-处理流程是一样的" class="headerlink" title="1.1 处理流程是一样的"></a>1.1 处理流程是一样的</h3><ul><li>每执行完一条指令都会检查有无中断&#x2F;异常产生</li><li>发现有中断&#x2F;异常产生，开始处理：<ul><li>保存现场</li><li>分辨异常&#x2F;中断，调用对应的异常&#x2F;中断处理函数</li><li>恢复现场</li></ul></li></ul><p>不同的芯片，不同的架构，在这方面的处理稍有差别：</p><ul><li><p>CPU中止当前执行，跳转去执行处理异常的代码：也有差异</p><ul><li>cortex M3&#x2F;M4在向量表上放置的是函数地址</li><li>cortex A7在向量表上放置的是跳转指令</li></ul></li><li><p>保存&#x2F;恢复现场：cortex M3&#x2F;M4是硬件实现的，cortex A7是软件实现的</p></li></ul><h3 id="1-2-cortex-M3-M4"><a href="#1-2-cortex-M3-M4" class="headerlink" title="1.2 cortex M3&#x2F;M4"></a>1.2 cortex M3&#x2F;M4</h3><p>参考资料：<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>PM0056.pdf</code></p><p>要想理解这个处理流程，需要从向量表说起。<br>向量，在数学定义里是<strong>有方向的量</strong>，在程序里可以认为向量就是一个数组，里面有多个项。<br>在ARM架构里，对于异常&#x2F;中断，它们的<strong>处理入口</strong>会整齐地排放在一起。</p><h4 id="1-2-1-M3-M4的向量表"><a href="#1-2-1-M3-M4的向量表" class="headerlink" title="1.2.1 M3&#x2F;M4的向量表"></a>1.2.1 M3&#x2F;M4的向量表</h4><p>M3&#x2F;M4的向量表中，放置的是具体异常&#x2F;中断的处理函数的地址。<br>比如发生<code>Reset</code>异常时，CPU就会从向量表里找到第1项，得到Reset_Handler函数的地址，跳转去执行。<br>比如发生<code>EXTI Line 0</code>中断时，CPU就会从向量表里找到第22项，得到EXTI0_IRQHandler函数的地址，跳转去执行。</p><ul><li>跳转之前，硬件会保存现场</li><li>函数执行完毕，返回之后，硬件会恢复现场</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">; Vector Table Mapped to Address 0 at Reset</span><br>                AREA    RESET, DATA, READONLY<br>                EXPORT  __Vectors<br>                EXPORT  __Vectors_End<br>                EXPORT  __Vectors_Size<br><br>__Vectors       DCD     __initial_sp               <span class="hljs-comment">; Top of Stack</span><br>                DCD     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><br>                DCD     NMI_Handler                <span class="hljs-comment">; NMI Handler</span><br>                DCD     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                DCD     MemManage_Handler          <span class="hljs-comment">; MPU Fault Handler</span><br>                DCD     <span class="hljs-keyword">BusFault_Handler </span>          <span class="hljs-comment">; Bus Fault Handler</span><br>                DCD     UsageFault_Handler         <span class="hljs-comment">; Usage Fault Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     SVC_Handler                <span class="hljs-comment">; SVCall Handler</span><br>                DCD     DebugMon_Handler           <span class="hljs-comment">; Debug Monitor Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     PendSV_Handler             <span class="hljs-comment">; PendSV Handler</span><br>                DCD     SysTick_Handler            <span class="hljs-comment">; SysTick Handler</span><br><br>                <span class="hljs-comment">; External Interrupts</span><br>                DCD     WWDG_IRQHandler            <span class="hljs-comment">; Window Watchdog</span><br>                DCD     PVD_IRQHandler             <span class="hljs-comment">; PVD through EXTI Line detect</span><br>                DCD     TAMPER_IRQHandler          <span class="hljs-comment">; Tamper</span><br>                DCD     RTC_IRQHandler             <span class="hljs-comment">; RTC</span><br>                DCD     FLASH_IRQHandler           <span class="hljs-comment">; Flash</span><br>                DCD     RCC_IRQHandler             <span class="hljs-comment">; RCC</span><br>                DCD     <span class="hljs-keyword">EXTI0_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 0</span><br>                DCD     <span class="hljs-keyword">EXTI1_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 1</span><br>                DCD     <span class="hljs-keyword">EXTI2_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 2</span><br>                DCD     <span class="hljs-keyword">EXTI3_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 3</span><br>                DCD     <span class="hljs-keyword">EXTI4_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 4</span><br>                DCD     DMA1_Channel1_IRQHandler   <span class="hljs-comment">; DMA1 Channel 1</span><br>                DCD     DMA1_Channel2_IRQHandler   <span class="hljs-comment">; DMA1 Channel 2</span><br>                DCD     DMA1_Channel3_IRQHandler   <span class="hljs-comment">; DMA1 Channel 3</span><br>                DCD     DMA1_Channel4_IRQHandler   <span class="hljs-comment">; DMA1 Channel 4</span><br>                DCD     DMA1_Channel5_IRQHandler   <span class="hljs-comment">; DMA1 Channel 5</span><br>                DCD     DMA1_Channel6_IRQHandler   <span class="hljs-comment">; DMA1 Channel 6</span><br>                DCD     DMA1_Channel7_IRQHandler   <span class="hljs-comment">; DMA1 Channel 7</span><br>                DCD     ADC1_2_IRQHandler          <span class="hljs-comment">; ADC1 &amp; ADC2</span><br>                DCD     USB_HP_CAN1_TX_IRQHandler  <span class="hljs-comment">; USB High Priority or CAN1 TX</span><br>                DCD     USB_LP_CAN1_RX0_IRQHandler <span class="hljs-comment">; USB Low  Priority or CAN1 RX0</span><br>                DCD     CAN1_RX1_IRQHandler        <span class="hljs-comment">; CAN1 RX1</span><br>                DCD     CAN1_SCE_IRQHandler        <span class="hljs-comment">; CAN1 SCE</span><br>                DCD     <span class="hljs-keyword">EXTI9_5_IRQHandler </span>        <span class="hljs-comment">; EXTI Line 9..5</span><br>                DCD     TIM1_BRK_IRQHandler        <span class="hljs-comment">; TIM1 Break</span><br>                DCD     TIM1_UP_IRQHandler         <span class="hljs-comment">; TIM1 Update</span><br>                DCD     TIM1_TRG_COM_IRQHandler    <span class="hljs-comment">; TIM1 Trigger and Commutation</span><br>                DCD     TIM1_CC_IRQHandler         <span class="hljs-comment">; TIM1 Capture Compare</span><br>                DCD     TIM2_IRQHandler            <span class="hljs-comment">; TIM2</span><br>                DCD     TIM3_IRQHandler            <span class="hljs-comment">; TIM3</span><br>                DCD     TIM4_IRQHandler            <span class="hljs-comment">; TIM4</span><br>                DCD     I2C1_EV_IRQHandler         <span class="hljs-comment">; I2C1 Event</span><br>                DCD     I2C1_ER_IRQHandler         <span class="hljs-comment">; I2C1 Error</span><br>                DCD     I2C2_EV_IRQHandler         <span class="hljs-comment">; I2C2 Event</span><br>                DCD     I2C2_ER_IRQHandler         <span class="hljs-comment">; I2C2 Error</span><br>                DCD     SPI1_IRQHandler            <span class="hljs-comment">; SPI1</span><br>                DCD     SPI2_IRQHandler            <span class="hljs-comment">; SPI2</span><br>                DCD     USART1_IRQHandler          <span class="hljs-comment">; USART1</span><br>                DCD     USART2_IRQHandler          <span class="hljs-comment">; USART2</span><br>                DCD     USART3_IRQHandler          <span class="hljs-comment">; USART3</span><br>                DCD     <span class="hljs-keyword">EXTI15_10_IRQHandler </span>      <span class="hljs-comment">; EXTI Line 15..10</span><br>                DCD     RTCAlarm_IRQHandler        <span class="hljs-comment">; RTC Alarm through EXTI Line</span><br>                DCD     USBWakeUp_IRQHandler       <span class="hljs-comment">; USB Wakeup from suspend</span><br>                DCD     TIM8_BRK_IRQHandler        <span class="hljs-comment">; TIM8 Break</span><br>                DCD     TIM8_UP_IRQHandler         <span class="hljs-comment">; TIM8 Update</span><br>                DCD     TIM8_TRG_COM_IRQHandler    <span class="hljs-comment">; TIM8 Trigger and Commutation</span><br>                DCD     TIM8_CC_IRQHandler         <span class="hljs-comment">; TIM8 Capture Compare</span><br>                DCD     ADC3_IRQHandler            <span class="hljs-comment">; ADC3</span><br>                DCD     FSMC_IRQHandler            <span class="hljs-comment">; FSMC</span><br>                DCD     SDIO_IRQHandler            <span class="hljs-comment">; SDIO</span><br>                DCD     TIM5_IRQHandler            <span class="hljs-comment">; TIM5</span><br>                DCD     SPI3_IRQHandler            <span class="hljs-comment">; SPI3</span><br>                DCD     UART4_IRQHandler           <span class="hljs-comment">; UART4</span><br>                DCD     UART5_IRQHandler           <span class="hljs-comment">; UART5</span><br>                DCD     TIM6_IRQHandler            <span class="hljs-comment">; TIM6</span><br>                DCD     TIM7_IRQHandler            <span class="hljs-comment">; TIM7</span><br>                DCD     DMA2_Channel1_IRQHandler   <span class="hljs-comment">; DMA2 Channel1</span><br>                DCD     DMA2_Channel2_IRQHandler   <span class="hljs-comment">; DMA2 Channel2</span><br>                DCD     DMA2_Channel3_IRQHandler   <span class="hljs-comment">; DMA2 Channel3</span><br>                DCD     DMA2_Channel4_5_IRQHandler <span class="hljs-comment">; DMA2 Channel4 &amp; Channel5</span><br>__Vectors_End<br></code></pre></td></tr></table></figure><h4 id="1-2-2-M3-M4的异常-中断处理流程"><a href="#1-2-2-M3-M4的异常-中断处理流程" class="headerlink" title="1.2.2 M3&#x2F;M4的异常&#x2F;中断处理流程"></a>1.2.2 M3&#x2F;M4的异常&#x2F;中断处理流程</h4><p>发生异常&#x2F;中断时，硬件上实现了这些事情：</p><ul><li><p>保存现场：把被中断瞬间的寄存器的值保存进栈里</p></li><li><p>根据异常&#x2F;中断号，从向量表中得到<strong>函数地址</strong>，跳转过去执行</p></li><li><p>函数执行完后，从栈中恢复现场</p></li></ul><p>保存现场、分辨异常&#x2F;中断、跳转执行，都是硬件实现的。<br>我们只需要在向量表中，把处理函数的地址填进去就可以了。</p><p><strong>硬件</strong>承包了大部分的工作。</p><p>M3&#x2F;M4的向量表中，存放的是<strong>函数地址</strong>。</p><h3 id="1-3-cortex-A7"><a href="#1-3-cortex-A7" class="headerlink" title="1.3 cortex A7"></a>1.3 cortex A7</h3><p>参考资料：<code>ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf</code></p><p>实际上，以前的S3C2440属于ARM9处理器，它的异常&#x2F;中断处理流程给cortex A7是一样的。</p><h4 id="1-3-1-A7的向量表"><a href="#1-3-1-A7的向量表" class="headerlink" title="1.3.1 A7的向量表"></a>1.3.1 A7的向量表</h4><p>A7的向量表中，放置的是某类异常的<strong>跳转指令</strong>。<br>比如发生<code>Reset</code>异常时，CPU就会从向量表里找到第0项，得到<code>b reset</code>指令，执行后就跳转到reset函数。<br>比如发生任何的中断时，CPU就会从向量表里找到第6项，得到<code>ldrpc, _irq</code>指令，执行后就跳转到_irq函数。</p><ul><li>跳转之前，硬件只会保存CPSR寄存器</li><li>跳转之后，软件要保存现场</li><li>函数执行完毕，返回之前，软件恢复现场</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">_start:</span> <br>    <span class="hljs-keyword">b</span>reset<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _undefined_instruction<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _software_interrupt<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _prefetch_abort<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _data_abort<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _not_used<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _irq<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _fiq<br></code></pre></td></tr></table></figure><h4 id="1-3-2-A7的异常-中断处理流程"><a href="#1-3-2-A7的异常-中断处理流程" class="headerlink" title="1.3.2 A7的异常&#x2F;中断处理流程"></a>1.3.2 A7的异常&#x2F;中断处理流程</h4><p>发生异常&#x2F;中断时，硬件上实现了这些事情：</p><ul><li><p>CPU切换到对应的异常模式，比如IRQ模式、未定义模式、SVC模式</p></li><li><p>保存被中断时的CPSR到SPSR</p><ul><li>CPSR：current program status register，当前程序状态寄存器</li><li>SRSR：saved program status register，保存的程序状态寄存器</li></ul></li><li><p>跳到这个异常的入口地址去，执行<strong>指令</strong>，这通常是一条跳转指令</p></li></ul><p>软件要做的事情就比较多了：</p><ul><li>保存现场</li><li>分辨异常&#x2F;中断</li><li>调用对应的处理函数</li><li>恢复现场</li></ul><p>A7的向量表中，存放的是<strong>跳转指令</strong>。</p><h2 id="3-异常处理深入分析-保存现场"><a href="#3-异常处理深入分析-保存现场" class="headerlink" title="3.异常处理深入分析_保存现场"></a>3.异常处理深入分析_保存现场</h2><h3 id="1-1-回顾一下处理流程"><a href="#1-1-回顾一下处理流程" class="headerlink" title="1.1 回顾一下处理流程"></a>1.1 回顾一下处理流程</h3><p>CPU每执行完一条指令都会检查有无中断&#x2F;异常产生，发现有中断&#x2F;异常产生，开始处理：</p><ul><li>保存现场</li><li>分辨异常&#x2F;中断，调用对应的异常&#x2F;中断处理函数</li><li>恢复现场</li></ul><p>对于不用的处理器，具体的处理工作有差别：</p><ul><li>保存现场：cortex M3&#x2F;M4里是硬件完成，cortex A7等是软件实现</li><li>分辨异常&#x2F;中断：cortex M3&#x2F;M4里是硬件完成，cortex A7等是软件实现</li><li>调用处理函数：cortex M3&#x2F;M4里是硬件来调用，cortex A7等是软件自己去调用</li><li>恢复现场：cortex M3&#x2F;M4里是软件触发、硬件实现，cortex A7等是软件实现</li></ul><p>不管是硬件还是软件实现，第一步都是<strong>保存现场</strong>。</p><h3 id="1-2-为什么要保存现场"><a href="#1-2-为什么要保存现场" class="headerlink" title="1.2 为什么要保存现场"></a>1.2 为什么要保存现场</h3><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/008_save_register.png"></p><p>任何程序，最终都会转换为机器码，上述C代码可以转换为右边的汇编指令。<br>对于这4条指令，它们可能随时被异常打断，怎么保证异常处理完后，被打断的程序还能正确运行？</p><ul><li><p>这4条指令涉及R0、R1寄存器，程序被打断时、恢复运行时，R0、R1要保持不变</p></li><li><p>执行完第3条指令时，比较结果保存在<strong>程序状态寄存器</strong>里，程序被打断时、恢复运行时，程序状态寄存器保持不变</p></li><li><p>这4条指令，读取a、b内存，程序被打断时、恢复运行时，a、b内存保持不变</p></li></ul><p>内存保持不变，这很容易实现，程序不越界就可以。<br>所以，关键在于R0、R1、程序状态寄存器要保持不变(当然不止这些寄存器)：</p><ul><li>在处理异常前，把这些寄存器保存在栈中，这称为<strong>保存现场</strong></li><li>在处理完异常后，从栈中恢复这些寄存器，这称为<strong>恢复现场</strong></li></ul><h3 id="1-3-保存现场"><a href="#1-3-保存现场" class="headerlink" title="1.3 保存现场"></a>1.3 保存现场</h3><p>ARM处理器中有这些寄存器：<br><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/003_cpu_register.png"></p><p>在arm中有个ATPCS规则(ARM-THUMB procedure call standard（ARM-Thumb过程调用标准）。<br>约定R0-R15寄存器的用途：</p><ul><li><p>R0-R3</p><p>调用者和被调用者之间传参数</p></li><li><p>R4-R11</p><p>函数可能被使用，所以在函数的入口保存它们，在函数的出口恢复它们。</p></li></ul><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/004_atpcs.png"></p><p>还有一个<strong>程序状态寄存器</strong>，对于M3&#x2F;M4它被称为<strong>XPSR</strong>，对于A7它被称为<strong>CPSR</strong>，我们简称为PSR。<br>R0-R15、PSR，就是所谓的<strong>现场</strong>。<br>发生异常&#x2F;中断后，在处理异常&#x2F;中断前，需要<strong>保存现场</strong>，难道需要保存所有这些寄存器吗？<br>不需要！<br>在C函数中，可以修改R0-R3、R12、R14(LR)以及PSR。如果C函数要用到这些寄存器，就要把它们保存到栈里，在函数结束前在从栈中恢复它们。<br>这些寄存器被拆分成2部分：**调用者保存的寄存器(R0-R3,R12,LR,PSR)<strong>、</strong>被调用者保存的寄存器(R4-R11)**。<br>比如函数A调用函数B，函数A应该知道：</p><ul><li>R0-R3是用来传参数给函数B的</li><li>函数B可以肆意修改R0-R3</li><li>函数A不要指望函数B帮你保存R0-R3</li><li>保存R0-R3，是函数A的事情</li><li>对于LR、PSR也是同样的道理，保存它们是函数A的责任</li></ul><p>对于函数B：</p><ul><li>我用到R4-R11中的某一个，我都会在函数入口保存、在函数返回前恢复</li><li>保证在B函数调用前后，函数A看到的R4-R11保存不变</li></ul><p>假设函数B就是异常&#x2F;中断处理函数，函数B本身能保证R4-R11不变，那么保存现场时，只需要保存这些：</p><ul><li>调用者保存的寄存器(R0-R3,R12,LR,PSR)</li><li>PC</li></ul><h3 id="1-4-对于M3-M4"><a href="#1-4-对于M3-M4" class="headerlink" title="1.4 对于M3&#x2F;M4"></a>1.4 对于M3&#x2F;M4</h3><p>参考资料：<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>PM0056.pdf</code></p><h4 id="1-4-1-硬件保存现场"><a href="#1-4-1-硬件保存现场" class="headerlink" title="1.4.1 硬件保存现场"></a>1.4.1 硬件保存现场</h4><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/005_saved_register_for_exception.png"></p><h4 id="1-4-2-然后调用C函数"><a href="#1-4-2-然后调用C函数" class="headerlink" title="1.4.2 然后调用C函数"></a>1.4.2 然后调用C函数</h4><p>C函数执行完后，它返回LR所指示的位置。<br>难道把LR设置为被中断的程序的地址就行了吗？<br>如果只是返回LR所指示的地方，硬件帮我们保存在栈里的寄存器，怎么恢复？<br>M3&#x2F;M4在调用异常处理函数前，把LR设置为一个特殊的值，转给特殊的值被称为<strong>EXC_RETURN</strong>。<br>当PC寄存器的值等于<strong>EXC_RETURN</strong>时，会触发异常返回机制，简单地说：会从栈里恢复R0-R3,R12,LR,PC,PSR等寄存器。<br><strong>EXC_RETURN</strong>的值，请参考<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>，截图如下：<br><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/006_exc_return.png"></p><p>补充2个知识点：</p><ul><li><p>操作模式：M3&#x2F;M4有两个操作模式</p><ul><li>处理模式：执行中断服务程序等异常处理时，处于<strong>处理模式</strong></li><li>线程模式：执行普通应用程序代码时，处于<strong>线程模式</strong></li></ul></li><li><p>M3&#x2F;M4有连个SP寄存器：SP_process、SP_main</p><ul><li>有些RTOS在运行用户程序时会使用SP_process，默认使用SP_main。</li></ul></li></ul><h3 id="1-5-对于A7"><a href="#1-5-对于A7" class="headerlink" title="1.5 对于A7"></a>1.5 对于A7</h3><p>它寄存器如下：<br><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/007_bank_register.png"></p><p>处理器有9中模式：User、Sys、FIQ、IRQ、ABT、SVC、UND、MON、HYP。<br>上图中深色的寄存器，表示该模式下的”Banked”寄存器，比如SPSR寄存器，在很多模式下都有自己的、单独的寄存器。<br>比如IRQ模式下访问SPSR时，访问到的是IRQ模式下自己的SPSR_irq，别的模式下无法访问SPSR_irq。</p><p>比较值得关注的是FIQ模式，名为”快中断”，它有很多”Banked”寄存器：R8-R12,SP,LR。<br>在FIQ模式下，它既然能使用自己的R8-R12,SP,LR，自然不需要去保存被中断的程序的”R8-R12,SP,LR”了。<br>省去保存这几个寄存器的时间，处理中断时自然就快很多，所以被称为”FIQ”。</p><p>从上图也看到，几乎每个模式下都有自己是SP寄存器，意味着这些模式下有自己的栈。</p><p>当发生异常时，以IRQ为例：</p><ul><li>CPU会自动切换进入对应的模式，比如进入IRQ模式</li><li>并且会把被中断是的CPSR保存到SPSR_irq里</li></ul><p>所以发生异常&#x2F;中断时，在保存现场时，只需要保存：</p><ul><li>调用者保存的寄存器(R0-R3,R12,LR)</li><li>PC</li></ul><h2 id="4-实战-未定义指令异常"><a href="#4-实战-未定义指令异常" class="headerlink" title="4.实战_未定义指令异常"></a>4.实战_未定义指令异常</h2><p>参考资料：<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>PM0056.pdf</code></p><h3 id="1-1-M3-M4支持哪些异常"><a href="#1-1-M3-M4支持哪些异常" class="headerlink" title="1.1 M3_M4支持哪些异常"></a>1.1 M3_M4支持哪些异常</h3><p>从向量表可以看出，M3&#x2F;M4支持哪些异常：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">__Vectors       DCD     __initial_sp               <span class="hljs-comment">; Top of Stack</span><br>                DCD     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><br>                DCD     NMI_Handler                <span class="hljs-comment">; NMI Handler</span><br>                DCD     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                DCD     MemManage_Handler          <span class="hljs-comment">; MPU Fault Handler</span><br>                DCD     <span class="hljs-keyword">BusFault_Handler </span>          <span class="hljs-comment">; Bus Fault Handler</span><br>                DCD     UsageFault_Handler         <span class="hljs-comment">; Usage Fault Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     SVC_Handler                <span class="hljs-comment">; SVCall Handler</span><br>                DCD     DebugMon_Handler           <span class="hljs-comment">; Debug Monitor Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     PendSV_Handler             <span class="hljs-comment">; PendSV Handler</span><br>                DCD     SysTick_Handler            <span class="hljs-comment">; SysTick Handler</span><br>                <br>                <span class="hljs-comment">; External Interrupts</span><br>                DCD     WWDG_IRQHandler            <span class="hljs-comment">; Window Watchdog</span><br>                DCD     PVD_IRQHandler             <span class="hljs-comment">; PVD through EXTI Line detect   </span><br></code></pre></td></tr></table></figure><p>前面几个对应各类错误：</p><ul><li>Hard Fault</li><li>MPU Fault</li><li>Bus Fault</li><li>Usage Fault</li></ul><p>这几类错误产生的原因入下图所示，这个图来自<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>:<br><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/009_m3m4_fault.png"></p><p>以未定义指令为例，它属于”处理器操作相关的错误”，如果没有使能”Usage Fault”，发就会触发”Hard Fault”。</p><h3 id="1-2-什么是未定义指令？"><a href="#1-2-什么是未定义指令？" class="headerlink" title="1.2 什么是未定义指令？"></a>1.2 什么是未定义指令？</h3><p>未定义指令，即使”还没有定义的指令”，也就是CPU不认识的指令。<br>很多时候，我们故意在代码里插入一些伪造的指令，故意让CPU执行到它时触发错误。<br>这在调试时很有用，比如想打断点：怎么实现呢？<br>有很多种方法：硬件监视点(watch point，数量有限)、软件断点(数量无限)。<br>软件断点就是使用<code>未定义指令</code>来实现的，比如想让程序执行到某个地址A时停下来，可以这样做：</p><ul><li>地址A上原来的指令是<code>xxx</code></li><li>我们故意把它改成<code>yyy</code>，改成一条CPU无法识别的指令</li><li>当CPU执行到地址A上的<code>yyy</code>指令时，触发异常</li><li>在异常处理函数里，打印更多调试信息</li><li>调试完毕后，恢复地址A上的指令为<code>xxx</code></li><li>从地址A重新执行程序</li></ul><p>本节教程并不打算制作调试器，这里只是讲述一下未定义指令的作用，使用它来深入理解异常处理流程。</p><h3 id="1-3-在汇编代码里插入未定义指令"><a href="#1-3-在汇编代码里插入未定义指令" class="headerlink" title="1.3 在汇编代码里插入未定义指令"></a>1.3 在汇编代码里插入未定义指令</h3><p>在代码中插入：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">DCD</span>  <span class="hljs-number">0xffffffff</span>；在main函数之前插入<br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">PC</span>,<span class="hljs-symbol">=mymain</span><span class="hljs-comment">;绝对跳转</span><br></code></pre></td></tr></table></figure><h4 id="1-3-1-先不使能”HardFault”、”Usage-Fault”"><a href="#1-3-1-先不使能”HardFault”、”Usage-Fault”" class="headerlink" title="1.3.1 先不使能”HardFault”、”Usage Fault”"></a>1.3.1 先不使能”HardFault”、”Usage Fault”</h4><p> 结果：不会进入main函数</p><h4 id="1-3-2-使能”HardFault”"><a href="#1-3-2-使能”HardFault”" class="headerlink" title="1.3.2 使能”HardFault”"></a>1.3.2 使能”HardFault”</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">__Vectors</span><span class="hljs-meta">DCD</span>(<span class="hljs-number">0X20000000</span>+<span class="hljs-number">0X10000</span>)<span class="hljs-comment">;设置栈大小</span><br><span class="hljs-meta">DCD</span>Reset_Handler<span class="hljs-comment">;Reset_Handler 伪指令,一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化</span><br><span class="hljs-meta">DCD</span>     <span class="hljs-number">0</span>                   <span class="hljs-comment">; NMI Handler</span><br>                <span class="hljs-meta">DCD</span>     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HardFault_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;HardFault!\r\n&quot;</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：只打印异常处理函数HardFault_Handler（）里面实现的 <strong>HardFault!</strong></p><h4 id="1-3-3-使能”Usage-Fault”"><a href="#1-3-3-使能”Usage-Fault”" class="headerlink" title="1.3.3 使能”Usage Fault”"></a>1.3.3 使能”Usage Fault”</h4><ul><li><p>设置SCB寄存器的第18位，才能使能Usage Fault</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">__VectorsDCD(0X20000000+0X10000);设置栈大小<br>DCDReset_Handler;Reset_Handler 伪指令,一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化<br>DCD     0                ; NMI Handler<br>                DCD     HardFault_Handler          ; Hard Fault Handler<br>                DCD     0          ; MPU Fault Handler<br>                DCD     0           ; Bus Fault Handler<br>                DCD     UsageFault_Handler         ; Usage Fault Handler<br></code></pre></td></tr></table></figure></li><li><p>初始化UsageFault，实现对应的异常处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">UsageFaultInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>SCB_Type * SCB = (SCB_Type *)SCB_BASE_ADDR;<br>SCB-&gt;SHCSR |= (SCB_SHCSR_USGFAULTENA_Msk);  <span class="hljs-comment">//UsageFault Enable</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">UsageFault_Handler</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> * <span class="hljs-built_in">stack</span>)</span><br>&#123;<br>SCB_Type * SCB = (SCB_Type *)SCB_BASE_ADDR;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;UsageFault!\r\n&quot;</span>);<br>SCB-&gt;CFSR = SCB-&gt;CFSR;    <span class="hljs-comment">//1.清除标志位，否则会一直触发</span><br><span class="hljs-built_in">stack</span>[<span class="hljs-number">6</span>] += <span class="hljs-number">4</span>;  <span class="hljs-comment">//2.设置返回地址，指向下一条指令,否则返回之后又会执行这条指令，还是会一直触发</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果：打印异常处理函数UsageFault_Handler（）里面实现的 <strong>UsageFault!<strong>之后，紧接着</strong>进去main函数中去</strong></p></li></ul><h2 id="5-实战-SVC异常"><a href="#5-实战-SVC异常" class="headerlink" title="5.实战_SVC异常"></a>5.实战_SVC异常</h2><p>参考资料：<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>PM0056.pdf</code></p><h3 id="1-1-M3-M4支持哪些异常-1"><a href="#1-1-M3-M4支持哪些异常-1" class="headerlink" title="1.1 M3_M4支持哪些异常"></a>1.1 M3_M4支持哪些异常</h3><p>从向量表可以看出，M3&#x2F;M4支持哪些异常：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">__Vectors       DCD     __initial_sp               <span class="hljs-comment">; Top of Stack</span><br>                DCD     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><br>                DCD     NMI_Handler                <span class="hljs-comment">; NMI Handler</span><br>                DCD     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                DCD     MemManage_Handler          <span class="hljs-comment">; MPU Fault Handler</span><br>                DCD     <span class="hljs-keyword">BusFault_Handler </span>          <span class="hljs-comment">; Bus Fault Handler</span><br>                DCD     UsageFault_Handler         <span class="hljs-comment">; Usage Fault Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     SVC_Handler                <span class="hljs-comment">; SVCall Handler</span><br>                DCD     DebugMon_Handler           <span class="hljs-comment">; Debug Monitor Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     PendSV_Handler             <span class="hljs-comment">; PendSV Handler</span><br>                DCD     SysTick_Handler            <span class="hljs-comment">; SysTick Handler</span><br>                <br>                <span class="hljs-comment">; External Interrupts</span><br>                DCD     WWDG_IRQHandler            <span class="hljs-comment">; Window Watchdog</span><br>                DCD     PVD_IRQHandler             <span class="hljs-comment">; PVD through EXTI Line detect   </span><br></code></pre></td></tr></table></figure><p>在上述代码中，可以看到<code>SVC_Handler</code>，它对应SVC异常，当执行<code>SVC</code>指令时，会导致<code>SVC_Handler</code>被调用。</p><h3 id="1-2-什么是SVC指令？"><a href="#1-2-什么是SVC指令？" class="headerlink" title="1.2 什么是SVC指令？"></a>1.2 什么是SVC指令？</h3><p>在ARM指令中，有一条指令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SVC</span> <span class="hljs-comment">#VAL</span><br></code></pre></td></tr></table></figure><p>它会触发一个异常。<br>在操作系统中，比如各类RTOS或者Linux，都会使用<code>SVC</code>指令故意触发异常，从而导致内核的异常处理函数被调用，进而去使用内核的服务。<br>比如Linux中，各类文件操作的函数<code>open</code>、<code>read</code>、<code>write</code>，它的实质都是<code>SVC</code>指令。<br>本节课程不讲解<code>SVC</code>在内核中的使用，我们只是看看如何处理<code>SVC</code>触发的异常。</p><h3 id="1-3-在汇编代码里插入SVC指令"><a href="#1-3-在汇编代码里插入SVC指令" class="headerlink" title="1.3 在汇编代码里插入SVC指令"></a>1.3 在汇编代码里插入SVC指令</h3><p>在代码中插入：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SVC</span> <span class="hljs-comment">#1</span><br></code></pre></td></tr></table></figure><p>看看会发生什么事情。</p><p> 结果：只打印异常处理函数HardFault_Handler（）里面实现的 <strong>HardFault!</strong></p><h4 id="1-3-1-提供SVC异常处理函数"><a href="#1-3-1-提供SVC异常处理函数" class="headerlink" title="1.3.1 提供SVC异常处理函数"></a>1.3.1 提供SVC异常处理函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SVC_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;SVC!\r\n&quot;</span>);  <span class="hljs-comment">//执行完这条指令，会自动执行下一条指令</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果：只打印异常处理函数SVC_Handler（）里面实现的 <strong>HardFault!<strong>之后，紧接着</strong>进去main函数中去</strong></p><h2 id="6-实战-SysTick异常"><a href="#6-实战-SysTick异常" class="headerlink" title="6.实战_SysTick异常"></a>6.实战_SysTick异常</h2><p>使用CPU自带的SysTick定时器，让它产生周期性的中断，用来操作LED。</p><p>参考资料：<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>PM0056.pdf</code></p><h3 id="1-1-M3-M4支持哪些异常-2"><a href="#1-1-M3-M4支持哪些异常-2" class="headerlink" title="1.1 M3_M4支持哪些异常"></a>1.1 M3_M4支持哪些异常</h3><p>从向量表可以看出，M3&#x2F;M4支持哪些异常：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">__Vectors       DCD     __initial_sp               <span class="hljs-comment">; Top of Stack</span><br>                DCD     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><br>                DCD     NMI_Handler                <span class="hljs-comment">; NMI Handler</span><br>                DCD     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                DCD     MemManage_Handler          <span class="hljs-comment">; MPU Fault Handler</span><br>                DCD     <span class="hljs-keyword">BusFault_Handler </span>          <span class="hljs-comment">; Bus Fault Handler</span><br>                DCD     UsageFault_Handler         <span class="hljs-comment">; Usage Fault Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     SVC_Handler                <span class="hljs-comment">; SVCall Handler</span><br>                DCD     DebugMon_Handler           <span class="hljs-comment">; Debug Monitor Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     PendSV_Handler             <span class="hljs-comment">; PendSV Handler</span><br>                DCD     SysTick_Handler            <span class="hljs-comment">; SysTick Handler</span><br>                <br>                <span class="hljs-comment">; External Interrupts</span><br>                DCD     WWDG_IRQHandler            <span class="hljs-comment">; Window Watchdog</span><br>                DCD     PVD_IRQHandler             <span class="hljs-comment">; PVD through EXTI Line detect   </span><br></code></pre></td></tr></table></figure><h3 id="1-2-SysTick操作"><a href="#1-2-SysTick操作" class="headerlink" title="1.2 SysTick操作"></a>1.2 SysTick操作</h3><p>Cortex-M处理器内部集成了一个小型的、名为SysTick的定时器。可以使用它来为操作系统提供系统时钟，也可以把它当做一般的定时器。<br>之所以在处理器内增加这样的定时器，是为了提高软件的可以移植性。<br>它是一个24位的定时器，向下计数。<br>在时钟源的驱动下，计数值到达0时，可以触发异常。<br>它的框图如下：<br><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/010_systick.png"></p><p>在本程序中，只需要设置这几个寄存器：</p><h4 id="1-2-1-SysTick-CTRL"><a href="#1-2-1-SysTick-CTRL" class="headerlink" title="1.2.1 SysTick-&gt;CTRL"></a>1.2.1 SysTick-&gt;CTRL</h4><p>  <img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/011_stk_ctrl.png"></p><h4 id="1-2-2-SysTick-VAL"><a href="#1-2-2-SysTick-VAL" class="headerlink" title="1.2.2 SysTick-&gt;VAL"></a>1.2.2 SysTick-&gt;VAL</h4><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/012_stk_val.png"></p><h4 id="1-2-3-SysTick-LOAD"><a href="#1-2-3-SysTick-LOAD" class="headerlink" title="1.2.3 SysTick-&gt;LOAD"></a>1.2.3 SysTick-&gt;LOAD</h4><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/013_stk_load.png"></p><h3 id="1-3-清除SysTick异常"><a href="#1-3-清除SysTick异常" class="headerlink" title="1.3 清除SysTick异常"></a>1.3 清除SysTick异常</h3><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/014_clear_systick_pending.png"></p><h1 id="第六章-操作模式和特权等级"><a href="#第六章-操作模式和特权等级" class="headerlink" title="第六章 操作模式和特权等级"></a>第六章 操作模式和特权等级</h1><h2 id="1-CPU模式和状态以及栈寄存器"><a href="#1-CPU模式和状态以及栈寄存器" class="headerlink" title="1.CPU模式和状态以及栈寄存器"></a>1.CPU模式和状态以及栈寄存器</h2><h3 id="1-模式和状态"><a href="#1-模式和状态" class="headerlink" title="1. 模式和状态"></a>1. 模式和状态</h3><h4 id="1-1-状态"><a href="#1-1-状态" class="headerlink" title="1.1 状态"></a>1.1 状态</h4><p>ARM芯片支持Thumb指令集、ARM指令集，处理器运行Thumb指令时处于Thumb状态，运行ARM指令时处于ARM状态。</p><p>CortexM3&#x2F;M4只支持Thumb指令集，所以处理器运行时只有Thumb状态。除此之外，还有一个调试状态：比如通过调试器或触发断点后，处理器就会进入调试状态并停止指令执行。</p><p>本课程不涉及调试状态，所以处理器只处于Thumb状态。</p><h4 id="1-2-模式-访问等级-栈"><a href="#1-2-模式-访问等级-栈" class="headerlink" title="1.2 模式&#x2F;访问等级&#x2F;栈"></a>1.2 模式&#x2F;访问等级&#x2F;栈</h4><p>CortexM3&#x2F;M4处理器有两种模式：</p><ul><li>处理模式：执行中断服务程序等异常处理，在处理模式下，处理器有最大权限(具有特权访问等级)</li><li>线程模式：执行普通程序。这是处理器可以处于特权访问等级，也可以处于非特权访问等级。</li></ul><p>不同模式下，处理权限可能不同，最大的不同就是：栈寄存器可能也不同。</p><p>ARM处理器的通用寄存器有R0、R1、……、R15，其中的R13也被称为SP，即栈寄存器。对于SP，它有两个实体：MSP(Main SP)、PSP(Process SP)。</p><p>在处理模式下，使用MSP，也就是说指令中使用SP时，它对应的物理寄存器是MSP。</p><p>在线程模式下，根据CONTROL寄存器的设置，处理器可能用的是MSP，也可能用的是PSP。</p><p>图示如下：</p><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/06_spsel.png" alt="image-20220326170811105"></p><p>栈寄存器的选择：</p><ul><li>① 启动时，CONTROL寄存器的SPSEL等于0，默认使用MSP。注意：启动时是线程模式，使用的仍然是MSP</li><li>② 程序可以修改CONTROL寄存器让SPSEL等于1，以使用PSP</li><li>③ 发生异常时，异常处理函数中使用的必定是MSP</li><li>④ 异常返回时，可以控制返回之后使用MSP还是PSP</li></ul><p>所谓访问等级，有两种：</p><ul><li>特权访问等级：可以访问所有寄存器、所有存储器。</li><li>非特权访问等级：无法访问某些寄存器，比如无法访问NVIC寄存器(嵌套向量中断控制器)。</li></ul><p>在一般的单片机系统中，RTOS、各类应用之间是无法隔离的：某个应用程序崩溃了，整个系统也就崩溃了。如果能让RTOS、各类应用程序彼此之间隔离开，那么可以增强系统的健壮性。这需要硬件的支持，比如需要有MPU(Memory Protection Unit)。</p><p>没有MPU时，访问等级的用处不大，只能用来限制应用程序无法访问某些寄存器。</p><h4 id="1-3-转换图"><a href="#1-3-转换图" class="headerlink" title="1.3 转换图"></a>1.3 转换图</h4><p>处理器状态和模式转换图如下：</p><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/04_mode_status.png" alt="image-20220326164725625"></p><p>注意：</p><ul><li>① 上电启动时，处理处于线程模式，处于特权访问等级</li><li>② 在特权模式下，它自然可以设置某些寄存器降低自己的等级，进入非特权访问等级</li><li>③ 在非特权模式下，无法自行提升自己的等级</li><li>④ 发生异常时，处理器进入处理模式</li><li>⑤ 在处理模式下永远都是特权访问等级</li><li>⑥ 异常放回时，可以返回到特权访问等级，也可以返回到非特权访问等级</li></ul><h4 id="1-4-CONTROL寄存器"><a href="#1-4-CONTROL寄存器" class="headerlink" title="1.4 CONTROL寄存器"></a>1.4 CONTROL寄存器</h4><p>上图中，第②那里，怎么从特权访问等级降级为非特权访问等级？通过设置CONTROL寄存器。</p><p>CONTROL寄存器定义如下：</p><ul><li>SPSEL：用来选择线程模式使用的是MSP还是PSP</li><li>nPRIV：用来设置线程模式的访问等级(特权&#x2F;非特权)</li></ul><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/07_control_reg.png" alt="image-20220326171250026"></p><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/08_control_reg_bits.png" alt="image-20220326171338515"></p><p>两种等级、两种栈，组合起来就有4种情况：</p><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/13_control_bit_table.png" alt="image-20220326162610884"></p><p>怎么读写CONTROL寄存器？使用如下汇编指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">MRS r0, CONTROL  ; 将CONTROL寄存器的值读入R0<br>MSR CONTROL, r0  ; 将R0写入CONTROL寄存器<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/10_process_mode_switch.png" alt="image-20220326180056270"></p><h4 id="1-5-EXC-RETURN"><a href="#1-5-EXC-RETURN" class="headerlink" title="1.5 EXC_RETURN"></a>1.5 EXC_RETURN</h4><p>通过设置CONTROL寄存器，可以选择MSP或PSP，可以把特权访问等级降为非特权访问等级。</p><p>但是无法把非特权等级提升为特权访问等级，为什么？如果可以这样简单地提升等级的话，等级也就失去了意义。</p><p>线程模式下无法自行提升等级，只能借助异常处理来提升等级：</p><ul><li>在异常的处理函数中，LR等于一个特殊的值EXC_RETURN</li><li>EXC_RETURN决定里异常返回后，处理器处于什么模式、使用什么栈</li></ul><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/09_exc_return.png" alt="image-20220326174011909"></p><h3 id="2-编程"><a href="#2-编程" class="headerlink" title="2. 编程"></a>2. 编程</h3><p>调试本节程序时，在Keil自带的模拟器上调试，这样更容易看清楚。</p><p>工程需要如下设置：</p><p><img src="/2024/06/27/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/01_use_emulator.png" alt="image-20220326183856624"></p><h2 id="2-提升访问等级"><a href="#2-提升访问等级" class="headerlink" title="2.提升访问等级"></a>2.提升访问等级</h2><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="3-MSP和PSP"><a href="#3-MSP和PSP" class="headerlink" title="3.MSP和PSP"></a>3.MSP和PSP</h2>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
      <tag>汇编</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC编译器详解</title>
    <link href="/2024/06/27/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/06/27/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-GCC编译器的介绍"><a href="#1-GCC编译器的介绍" class="headerlink" title="1 GCC编译器的介绍"></a>1 GCC编译器的介绍</h1><p>源文件需要经过编译才能生成可执行文件。在 Windows 下进行开发时，只需要点几个按钮即可编译，集成开发环境(比如 Visual studio)已经将各种编译工具的使用封装好了。Linux 下也有很优秀的集成开发工具，但是更多的时候是 直接使用编译工具；即使使用集成开发工具，也需要掌握一些编译选项。  PC 机上的编译工具链为 gcc、ld、objcopy、objdump 等，它们编译出来的程序在 x86 平台上运行。要编译出能在 ARM 平台上运行的程序，必须使用交叉编 译工具 xxx-gcc、xxx-ld 等(不同版本的编译器的前缀不一样，比如 arm-linuxgcc)，下面分别介绍。</p><h1 id="2-GCC编译过程"><a href="#2-GCC编译过程" class="headerlink" title="2 GCC编译过程"></a>2 GCC编译过程</h1><p>一个 C&#x2F;C++文件要经过预处理(preprocessing)、编译(compilation)、汇 编(assembly)和链接(linking)等 4 步才能变成可执行文件。</p><p><img src="/2024/06/27/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106151713868.png" alt="image-20231106151713868"></p><p>通过不同的 gcc 选项可以控制这些过程： </p><p><img src="/2024/06/27/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106151728007.png" alt="image-20231106151728007"></p><h2 id="2-1-预处理"><a href="#2-1-预处理" class="headerlink" title="2.1 预处理"></a>2.1 预处理</h2><p>C&#x2F;C++源文件中，以“#”开头的命令被称为预处理命令，如包含命令 “#include”、宏定义命令“#define”、条件编译命令“#if”、“#ifdef”等。 预处理就是将要包含(include)的文件插入原文件中、将宏定义展开、根据条件 编译命令选择要使用的代码，最后将这些东西输出到一个“.i”文件中等待进一 步处理。 </p><h2 id="2-2-编译"><a href="#2-2-编译" class="headerlink" title="2.2 编译"></a>2.2 编译</h2><p>编译就是把 C&#x2F;C++代码(比如上述的“.i”文件)“翻译”成汇编代码，所用 到的工具为 cc1(它的名字就是 cc1，x86 有自己的 cc1 命令，ARM 板也有自己的cc1 命令)。 </p><h2 id="2-3-汇编"><a href="#2-3-汇编" class="headerlink" title="2.3 汇编"></a>2.3 汇编</h2><p>汇编就是将第二步输出的汇编代码翻译成符合一定格式的机器代码，在Linux 系统上一般表现为 ELF 目标文件(OBJ 文件)，用到的工具为 as。x86 有 自己的 as 命令，ARM 版也有自己的 as 命令，也可能是 xxxx-as（比如 armlinux-as）。</p><p><strong>“反汇编”</strong>是指将机器代码转换为汇编代码，这在调试程序时常常用到。</p><h2 id="2-4-链接"><a href="#2-4-链接" class="headerlink" title="2.4 链接"></a>2.4 链接</h2><p>链接就是将上步生成的 OBJ 文件和系统库的 OBJ 文件、库文件链接起来，最 终生成了可以在特定平台运行的可执行文件，用到的工具为 ld 或 collect2。 </p><h2 id="2-5-gcc使用示例："><a href="#2-5-gcc使用示例：" class="headerlink" title="2.5 gcc使用示例："></a>2.5 gcc使用示例：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc hello.c<span class="hljs-comment">//输出一个名为 a.out 的可执行程序，然后可以执行./a.out </span><br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106152210408.png" alt="image-20231106152210408"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -o hello hello.c<span class="hljs-comment">// 输出名为 hello 的可执行程序，然后可以执行./hello </span><br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106152418847.png" alt="image-20231106152418847"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -o hello hello.c -<span class="hljs-type">static</span> <span class="hljs-comment">// 静态链接 </span><br>gcc -c -o hello.o hello.c <span class="hljs-comment">// 先编译(不链接) </span><br>gcc -o hello hello.o <span class="hljs-comment">// 再链接</span><br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106152738286.png" alt="image-20231106152738286"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -o hello hello.c -v<span class="hljs-comment">//可以查看编译信息</span><br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106152934785.png" alt="image-20231106152934785"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -E -o hello.i hello.c   <span class="hljs-comment">//预处理</span><br>gcc -S -o hello.s hello.i<span class="hljs-comment">//编译</span><br>gcc -c -o hello.o hello.s<span class="hljs-comment">//汇编</span><br>gcc -o hello hello.o<span class="hljs-comment">//链接</span><br></code></pre></td></tr></table></figure><h1 id="3-常用编译选项"><a href="#3-常用编译选项" class="headerlink" title="3 常用编译选项"></a>3 常用编译选项</h1><table><thead><tr><th><strong>常用选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-E</td><td>预处理，开发过程中想快速确定某个宏可以使用“-E -dM”</td></tr><tr><td>-c</td><td>把预处理、编译、汇编都做了，但是不链接</td></tr><tr><td>-o</td><td>指定输出文件</td></tr><tr><td>-I（i）</td><td>指定头文件目录</td></tr><tr><td>-L</td><td>指定链接时库文件目录</td></tr><tr><td>-v</td><td>显示制作 GCC 工具自身时的配置命令；同时显示编译器驱动程序、预处理器、 编译器的版本号</td></tr><tr><td>-l</td><td>指定链接哪一个库文件</td></tr><tr><td>-S</td><td>编译后即停止，不进行汇编</td></tr></tbody></table><h1 id="4-头文件-与“-”区别"><a href="#4-头文件-与“-”区别" class="headerlink" title="4 头文件&lt; &gt;与“ ”区别"></a>4 头文件&lt; &gt;与“ ”区别</h1><ul><li>&lt;&gt;:在库文件目录下查找头文件</li><li>“ ”:     在当前目录下查找头文件</li></ul><p>举个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sub.h&quot;</span></span><br> <span class="hljs-number">3</span><br> <span class="hljs-number">4</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br> 5 &#123;<br> <span class="hljs-number">6</span>        <span class="hljs-type">int</span> i;<br> <span class="hljs-number">7</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Main fun!\n&quot;</span>);<br> <span class="hljs-number">8</span>        sub_fun();<br> <span class="hljs-number">9</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">10</span> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -o test main.c sub.c<span class="hljs-comment">//编译成功，不会出现任何错误</span><br></code></pre></td></tr></table></figure><p>将上述代码中的第2行改成：#include “sub.h”，再次编译</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -o test main.<span class="hljs-keyword">c</span> <span class="hljs-keyword">sub</span>.<span class="hljs-keyword">c</span>//报错<span class="hljs-punctuation">,</span>因为在库文件目录中没有<span class="hljs-keyword">sub</span>.h<br></code></pre></td></tr></table></figure><p><img src="/2024/06/27/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20231106161746679.png" alt="image-20231106161746679"></p><ul><li><p>解决方法：</p><ul><li><p>在库文件目录中添加sub.h</p></li><li><p>在编译时指定头文件目录</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -o test <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> sub<span class="hljs-selector-class">.c</span>  -I ./<span class="hljs-comment">//指定在当前目录下查找头文件</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="5-编译多个文件"><a href="#5-编译多个文件" class="headerlink" title="5 编译多个文件"></a>5 编译多个文件</h1><ul><li><p>一起编译、链接：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -o test main.<span class="hljs-keyword">c</span> <span class="hljs-keyword">sub</span>.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure></li><li><p>分开编译，统一链接：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -c -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>gcc -c -o sub<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.c</span><br>gcc -o test <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> sub.o<br></code></pre></td></tr></table></figure></li></ul><h1 id="5-制作、使用动态库"><a href="#5-制作、使用动态库" class="headerlink" title="5 制作、使用动态库"></a>5 制作、使用动态库</h1><ul><li><p>第一步 制作、编译:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -c -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>gcc -c -o sub<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.c</span><br>gcc -shared -o libsub<span class="hljs-selector-class">.so</span> sub<span class="hljs-selector-class">.o</span> sub2<span class="hljs-selector-class">.o</span> sub3<span class="hljs-selector-class">.o</span><span class="hljs-comment">//可以使用多个.o生成动态库</span><br>gcc -o test <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> -lsub  -L ./<span class="hljs-comment">//指定动态库所在目录</span><br></code></pre></td></tr></table></figure></li><li><p>第2步 运行： </p><ul><li><p>先把 libsub.so 放到 Ubuntu 的&#x2F;lib 目录，然后就可以运行 test 程序。 </p></li><li><p>如果不想把 libsub.so 放到&#x2F;lib，也可以放在某个目录比如&#x2F;a，然后如下执</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/a <br>./test<br></code></pre></td></tr></table></figure></li></ul><h1 id="6-制作、使用静态库"><a href="#6-制作、使用静态库" class="headerlink" title="6 制作、使用静态库"></a>6 <strong>制作、使用静态库</strong></h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -c -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> <br>gcc -c -o sub<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.c</span> <br>ar crs libsub<span class="hljs-selector-class">.a</span> sub<span class="hljs-selector-class">.o</span> sub2<span class="hljs-selector-class">.o</span> sub3<span class="hljs-selector-class">.o</span>(可以使用多个<span class="hljs-selector-class">.o</span> 生成静态库) <br>gcc -o test <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> libsub<span class="hljs-selector-class">.a</span> (如果<span class="hljs-selector-class">.a</span> 不在当前目录下，需要指定它的绝对或相对路径) <br></code></pre></td></tr></table></figure><p>运行：不需要把静态库 libsub.a 放到板子上。 </p><p><strong>注意：</strong>执行 arm-buildroot-linux-gnueabihf-gcc -c -o sub.o sub.c 交叉编译需要在最后面加上-fPIC 参数。 </p><h1 id="7-很有用的选项"><a href="#7-很有用的选项" class="headerlink" title="7 很有用的选项"></a>7 很有用的选项</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">gcc -E main.c <span class="hljs-comment">// 查看预处理结果，比如头文件是哪个 </span><br>gcc -E -dM main.c &gt; <span class="hljs-number">1</span>.txt <span class="hljs-comment">// 把所有的宏展开，存在 1.txt 里 </span><br>gcc -Wp,-MD,abc.dep -c -o main.o main.c <span class="hljs-comment">// 生成依赖文件 abc.dep，后面 Makefile 会用 </span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;main()&#123;&#125;&#x27;</span>| gcc -E -v - <span class="hljs-comment">// 它会列出头文件目录、库目录(LIBRARY_PATH) </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git命令</title>
    <link href="/2024/06/27/Git%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/06/27/Git%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Git命令"><a href="#1-Git命令" class="headerlink" title="1 Git命令"></a>1 Git命令</h1><h2 id="1-本地创建git仓库"><a href="#1-本地创建git仓库" class="headerlink" title="1 本地创建git仓库"></a>1 本地创建git仓库</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><h2 id="2-提交到暂存区"><a href="#2-提交到暂存区" class="headerlink" title="2 提交到暂存区"></a>2 提交到暂存区</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> 文件名<br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .        <span class="hljs-comment">//目录下的所有文件</span><br></code></pre></td></tr></table></figure><h2 id="3-添加备注"><a href="#3-添加备注" class="headerlink" title="3 添加备注"></a>3 添加备注</h2><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;备注内容&quot;</span><br></code></pre></td></tr></table></figure><h2 id="4-查看提交节点"><a href="#4-查看提交节点" class="headerlink" title="4 查看提交节点"></a>4 查看提交节点</h2><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs 1c">git <span class="hljs-built_in">log</span> <br>git <span class="hljs-built_in">log</span> --stat   <span class="hljs-comment">//查看每次提交的时候修改了哪些文件</span><br></code></pre></td></tr></table></figure><h2 id="5-回溯"><a href="#5-回溯" class="headerlink" title="5 回溯"></a>5 回溯</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">git diff  <span class="hljs-selector-attr">[commit的id]</span>  <span class="hljs-comment">//查看具体修改了什么</span><br>git reset <span class="hljs-attr">--hard</span>  <span class="hljs-selector-attr">[commit的id]</span>   <span class="hljs-comment">//回溯</span><br></code></pre></td></tr></table></figure><h2 id="6-创建分支"><a href="#6-创建分支" class="headerlink" title="6 创建分支"></a>6 创建分支</h2><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs smali">git<span class="hljs-built_in"> check </span>-b develop//创建develop分支<br>git branch //查看分支<br>git checkout master//切换到master分支<br>git merge develop    //将develop分支的内容合并了master分支<br></code></pre></td></tr></table></figure><p>git config -l</p><p> git config –system  –list</p><p>git push</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux卡片电脑</title>
    <link href="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/"/>
    <url>/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-硬件（Hardware）"><a href="#1-硬件（Hardware）" class="headerlink" title="1 硬件（Hardware）"></a>1 硬件（Hardware）</h1><blockquote><p>原理图部分太多，就不一一展示了！</p></blockquote><h2 id="1-1-实物图"><a href="#1-1-实物图" class="headerlink" title="1.1 实物图"></a>1.1 实物图</h2><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301132644102.png" alt="image-20240301132644102"></p><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301132711043.png" alt="image-20240301132711043"></p><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301132724403.png" alt="image-20240301132724403"></p><h2 id="1-2-核心板-PCB"><a href="#1-2-核心板-PCB" class="headerlink" title="1.2 核心板 PCB"></a>1.2 核心板 PCB</h2><h3 id="Top1层"><a href="#Top1层" class="headerlink" title="Top1层"></a>Top1层</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301130613104.png" alt="image-20240301130613104"></p><h3 id="Gnd2层"><a href="#Gnd2层" class="headerlink" title="Gnd2层"></a>Gnd2层</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301130710279.png" alt="image-20240301130710279"></p><h3 id="Power3层"><a href="#Power3层" class="headerlink" title="Power3层"></a>Power3层</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301130807506.png" alt="image-20240301130807506"></p><h3 id="Bottom4层"><a href="#Bottom4层" class="headerlink" title="Bottom4层"></a>Bottom4层</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301130819357.png" alt="image-20240301130819357"></p><h3 id="3D视图"><a href="#3D视图" class="headerlink" title="3D视图"></a>3D视图</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301130918229.png" alt="image-20240301130918229"></p><h3 id="实物图"><a href="#实物图" class="headerlink" title="实物图"></a>实物图</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301132034603.png" alt="image-20240301132034603"></p><h2 id="1-3-扩展板1-PCB"><a href="#1-3-扩展板1-PCB" class="headerlink" title="1.3 扩展板1 PCB"></a>1.3 扩展板1 PCB</h2><h3 id="Top1层-1"><a href="#Top1层-1" class="headerlink" title="Top1层"></a>Top1层</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301132122695.png" alt="image-20240301132122695"></p><h3 id="Gnd2层-1"><a href="#Gnd2层-1" class="headerlink" title="Gnd2层"></a>Gnd2层</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301132132255.png" alt="image-20240301132132255"></p><h3 id="Power3层-1"><a href="#Power3层-1" class="headerlink" title="Power3层"></a>Power3层</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301132146304.png" alt="image-20240301132146304"></p><h3 id="Bottom4层-1"><a href="#Bottom4层-1" class="headerlink" title="Bottom4层"></a>Bottom4层</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301132212856.png" alt="image-20240301132212856"></p><h3 id="3D视图-1"><a href="#3D视图-1" class="headerlink" title="3D视图"></a>3D视图</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301132315207.png" alt="image-20240301132315207"></p><h3 id="实物图-1"><a href="#实物图-1" class="headerlink" title="实物图"></a>实物图</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301132229665.png" alt="image-20240301132229665"></p><h2 id="1-4-扩展板2-PCB"><a href="#1-4-扩展板2-PCB" class="headerlink" title="1.4 扩展板2 PCB"></a>1.4 扩展板2 PCB</h2><h3 id="Top1层-2"><a href="#Top1层-2" class="headerlink" title="Top1层"></a>Top1层</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301132937659.png" alt="image-20240301132937659"></p><h3 id="Gnd2层-2"><a href="#Gnd2层-2" class="headerlink" title="Gnd2层"></a>Gnd2层</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301132949897.png" alt="image-20240301132949897"></p><h3 id="Power3层-2"><a href="#Power3层-2" class="headerlink" title="Power3层"></a>Power3层</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301133002855.png" alt="image-20240301133002855"></p><h3 id="Bottom4层-2"><a href="#Bottom4层-2" class="headerlink" title="Bottom4层"></a>Bottom4层</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301133014067.png" alt="image-20240301133014067"></p><h3 id="3D视图-2"><a href="#3D视图-2" class="headerlink" title="3D视图"></a>3D视图</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301133037486.png" alt="image-20240301133037486"></p><h3 id="实物图-2"><a href="#实物图-2" class="headerlink" title="实物图"></a>实物图</h3><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301133057512.png" alt="image-20240301133057512"></p><h1 id="2-系统移植"><a href="#2-系统移植" class="headerlink" title="2 系统移植"></a>2 系统移植</h1><h2 id="2-1-安装交叉编译器"><a href="#2-1-安装交叉编译器" class="headerlink" title="2.1 安装交叉编译器"></a>2.1 安装交叉编译器</h2><h4 id="1-下载交叉编译器-arm-cortexa9-linux-gnueabihf-4-9-3-tar-xz，然后解压编译器"><a href="#1-下载交叉编译器-arm-cortexa9-linux-gnueabihf-4-9-3-tar-xz，然后解压编译器" class="headerlink" title="1 下载交叉编译器 arm-cortexa9-linux-gnueabihf-4.9.3.tar.xz，然后解压编译器"></a>1 下载交叉编译器 arm-cortexa9-linux-gnueabihf-4.9.3.tar.xz，然后解压编译器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /opt/YuanPi-Plus/toolchain<br>tar xf arm-cortexa9-linux-gnueabihf-4.9.3.tar.xz -C /opt/FriendlyARM/toolchain/<br></code></pre></td></tr></table></figure><h4 id="2-将编译器的路径加入到-PATH-中，vi-bashrc，在末尾加入以下内容："><a href="#2-将编译器的路径加入到-PATH-中，vi-bashrc，在末尾加入以下内容：" class="headerlink" title="2 将编译器的路径加入到 PATH 中，vi ~&#x2F;.bashrc，在末尾加入以下内容："></a>2 将编译器的路径加入到 PATH 中，vi ~&#x2F;.bashrc，在末尾加入以下内容：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=/opt/FriendlyARM/toolchain/4.9.3/bin:$PATH<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">GCC_COLORS</span>=auto<br><span class="hljs-comment"># 执行一下~/.bashrc脚本，让设置立即在当前shell窗口中生效，注意&quot;.&quot;后面有个空格：. ~/.bashrc</span><br></code></pre></td></tr></table></figure><h4 id="3-这个编译器是-64-位的，不能在-32-位的-Linux-系统上运行，安装完成后，验证是否安装成功："><a href="#3-这个编译器是-64-位的，不能在-32-位的-Linux-系统上运行，安装完成后，验证是否安装成功：" class="headerlink" title="3 这个编译器是 64 位的，不能在 32 位的 Linux 系统上运行，安装完成后，验证是否安装成功："></a>3 这个编译器是 64 位的，不能在 32 位的 Linux 系统上运行，安装完成后，验证是否安装成功：</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">arm-linux-gcc -v<br># 显示出gcc version 4.9.3 (ctng<span class="hljs-string">-1</span>.21.0<span class="hljs-string">-229</span>g-FA)即成功了<br></code></pre></td></tr></table></figure><h2 id="2-2-编译适配-U-boot"><a href="#2-2-编译适配-U-boot" class="headerlink" title="2.2 编译适配 U-boot"></a>2.2 编译适配 U-boot</h2><h4 id="1-下载-U-boot-源码，移植自FriendlyARM的仓库"><a href="#1-下载-U-boot-源码，移植自FriendlyARM的仓库" class="headerlink" title="1 下载 U-boot 源码，移植自FriendlyARM的仓库"></a>1 下载 U-boot 源码，移植自<a href="https://gitee.com/link?target=https://github.com/friendlyarm/u-boot.git">FriendlyARM</a>的仓库</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/friendlyarm/u-boot.git -b sunxi-v2017.x --depth <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="2-安装-Python-库："><a href="#2-安装-Python-库：" class="headerlink" title="2 安装 Python 库："></a>2 安装 Python 库：</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">apt-<span class="hljs-built_in">get</span> install swig python-<span class="hljs-built_in">dev</span> python3-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><h4 id="3-使用-nanopi-h3-defconfig-配置："><a href="#3-使用-nanopi-h3-defconfig-配置：" class="headerlink" title="3 使用 nanopi_h3_defconfig 配置："></a>3 使用 nanopi_h3_defconfig 配置：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 修改DDR3频率为768M，经过测试我的硬件最大支持这个频率</span><br>vim configs/nanopi_h3_defconfig<br><span class="hljs-comment"># 将 CONFIG_DRAM_CLK=408 修改为 CONFIG_DRAM_CLK=768</span><br>make nanopi_h3_defconfig <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-<br></code></pre></td></tr></table></figure><h4 id="4-编译-U-boot："><a href="#4-编译-U-boot：" class="headerlink" title="4 编译 U-boot："></a>4 编译 U-boot：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux- -j12<br><span class="hljs-comment"># 编译成功后会生成文件u-boot-sunxi-with-spl.bin</span><br></code></pre></td></tr></table></figure><h4 id="5-更新-SD-上的-U-boot："><a href="#5-更新-SD-上的-U-boot：" class="headerlink" title="5 更新 SD 上的 U-boot："></a>5 更新 SD 上的 U-boot：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=u-boot-sunxi-with-spl.bin <span class="hljs-attribute">of</span>=/dev/sdX <span class="hljs-attribute">bs</span>=1024 <span class="hljs-attribute">seek</span>=8<br>sync &amp;&amp; eject /dev/sdX<br><span class="hljs-comment"># /dev/sdX替换为实际的TF卡设备文件名。</span><br><span class="hljs-comment"># sync命令可以确保数据成功写到TF卡中，eject命令用于弹出TF卡。</span><br></code></pre></td></tr></table></figure><h4 id="6-SD-卡运行系统时，可以先用-scp-命令拷贝-u-boot-sunxi-with-spl-bin-到开发板上，然后用-dd-命令更新-SD-卡上的-U-boot"><a href="#6-SD-卡运行系统时，可以先用-scp-命令拷贝-u-boot-sunxi-with-spl-bin-到开发板上，然后用-dd-命令更新-SD-卡上的-U-boot" class="headerlink" title="6 SD 卡运行系统时，可以先用 scp 命令拷贝 u-boot-sunxi-with-spl.bin 到开发板上，然后用 dd 命令更新 SD 卡上的 U-boot:"></a>6 SD 卡运行系统时，可以先用 scp 命令拷贝 u-boot-sunxi-with-spl.bin 到开发板上，然后用 dd 命令更新 SD 卡上的 U-boot:</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">scp u-boot-sunxi-with-spl.bin root@192.168.0.106:/root/<br>dd <span class="hljs-attribute">if</span>=/root/u-boot-sunxi-with-spl.bin <span class="hljs-attribute">of</span>=/dev/mmcblk0 <span class="hljs-attribute">bs</span>=1024 <span class="hljs-attribute">seek</span>=8<br><span class="hljs-comment"># root@后面替换成板子上的IP地址，EMMC也可以用此方法</span><br><span class="hljs-comment"># H3的启动设备的设备节点总是/dev/mmcblk0</span><br></code></pre></td></tr></table></figure><h4 id="7-成功效果如下："><a href="#7-成功效果如下：" class="headerlink" title="7 成功效果如下："></a>7 成功效果如下：</h4><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/2.%E8%BD%AF%E4%BB%B6%E9%80%82%E9%85%8D1.png" alt="img"></p><h2 id="2-3-编译适配-Linux-内核"><a href="#2-3-编译适配-Linux-内核" class="headerlink" title="2.3 编译适配 Linux 内核"></a>2.3 编译适配 Linux 内核</h2><h4 id="1-下载-Linux-内核源码，移植自FriendlyARM的仓库"><a href="#1-下载-Linux-内核源码，移植自FriendlyARM的仓库" class="headerlink" title="1 下载 Linux 内核源码，移植自FriendlyARM的仓库"></a>1 下载 Linux 内核源码，移植自<a href="https://gitee.com/link?target=https://github.com/friendlyarm/u-boot.git">FriendlyARM</a>的仓库</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> clone https://github.com/friendlyarm/linux.git -b sunxi-<span class="hljs-number">4</span>.<span class="hljs-number">14</span>.y --depth <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="2-默认配置先跑起来："><a href="#2-默认配置先跑起来：" class="headerlink" title="2 默认配置先跑起来："></a>2 默认配置先跑起来：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install u-boot-tools<br>touch .scmversion<br>make sunxi_defconfig <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-<br>make zImage dtbs <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-<br><span class="hljs-comment"># 编译完成后会在arch/arm/boot/目录下生成zImage，在arch/arm/boot/dts/目录下生成dtb文件</span><br></code></pre></td></tr></table></figure><h4 id="3-更新-SD-上的-zImage-和-dtb-文件：假设-SD-卡的-boot-分区挂载在-media-SD-boot"><a href="#3-更新-SD-上的-zImage-和-dtb-文件：假设-SD-卡的-boot-分区挂载在-media-SD-boot" class="headerlink" title="3 更新 SD 上的 zImage 和 dtb 文件：假设 SD 卡的 boot 分区挂载在 &#x2F;media&#x2F;SD&#x2F;boot&#x2F;"></a>3 更新 SD 上的 zImage 和 dtb 文件：假设 SD 卡的 boot 分区挂载在 &#x2F;media&#x2F;SD&#x2F;boot&#x2F;</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> <span class="hljs-built_in">arch</span>/arm/boot/zImage /media/SD/boot/<br><span class="hljs-built_in">cp</span> <span class="hljs-built_in">arch</span>/arm/boot/dts/sun8i-*-nanopi-*.dtb /media/SD/boot/<br><span class="hljs-comment"># 也可以用scp命令通过网络更新：</span><br>scp <span class="hljs-built_in">arch</span>/arm/boot/zImage root@192.168.31.134:/boot<br>scp <span class="hljs-built_in">arch</span>/arm/boot/dts/sun8i-*-nanopi-*.dtb root@192.168.31.134:/boot<br></code></pre></td></tr></table></figure><h4 id="4-bootargs-与-bootcmd：全志-H3-使用-boot-cmd-生成-boot-scr-来描述配置，boot-cmd："><a href="#4-bootargs-与-bootcmd：全志-H3-使用-boot-cmd-生成-boot-scr-来描述配置，boot-cmd：" class="headerlink" title="4 bootargs 与 bootcmd：全志 H3 使用 boot.cmd 生成 boot.scr 来描述配置，boot.cmd："></a>4 bootargs 与 bootcmd：全志 H3 使用 boot.cmd 生成 boot.scr 来描述配置，boot.cmd：</h4><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/2.%E8%BD%AF%E4%BB%B6%E9%80%82%E9%85%8D2.png" alt="img"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Recompile with: mkimage -C none -A arm -T script -d boot.cmd boot.scr CPU=H3</span><br><span class="hljs-comment"># OS=friendlycore/ubuntu-oled/ubuntu-wifiap/openwrt/debian/debian-nas...</span><br> <br> echo <span class="hljs-string">&quot;running boot.scr&quot;</span><br> setenv fsck.repair <span class="hljs-literal">yes</span><br> setenv ramdisk rootfs.cpio.gz<br> setenv kernel zImage<br> <br> setenv env_addr 0x43000000<br> setenv kernel_addr 0x46000000<br> setenv ramdisk_addr 0x47000000<br> setenv dtb_addr 0x48000000<br> <br> fatload mmc 0 <span class="hljs-variable">$&#123;kernel_addr&#125;</span> <span class="hljs-variable">$&#123;kernel&#125;</span><br> fatload mmc 0 <span class="hljs-variable">$&#123;ramdisk_addr&#125;</span> <span class="hljs-variable">$&#123;ramdisk&#125;</span><br> setenv ramdisk_size <span class="hljs-variable">$&#123;filesize&#125;</span><br> <br> fatload mmc 0 <span class="hljs-variable">$&#123;dtb_addr&#125;</span> sun8i-h3-YuanPi-plus.dtb<br> fdt addr <span class="hljs-variable">$&#123;dtb_addr&#125;</span><br> <br> # setup MAC<span class="hljs-built_in"> address</span><br><span class="hljs-built_in"></span> fdt <span class="hljs-built_in">set</span> ethernet0 local-mac-address <span class="hljs-variable">$&#123;mac_node&#125;</span><br> <br> # setup boot_device<br> fdt <span class="hljs-built_in">set</span> mmc0 boot_device &lt;1&gt;<br> <br> setenv fbcon map:1<br> <br> setenv overlayfs <span class="hljs-attribute">data</span>=/dev/mmcblk0p3<br> #setenv hdmi_res drm_kms_helper.<span class="hljs-attribute">edid_firmware</span>=HDMI-A-1:edid/1280x720.bin <span class="hljs-attribute">video</span>=HDMI-A-1:1280x720@60<br> <br> setenv bootargs <span class="hljs-attribute">console</span>=tty1 <span class="hljs-attribute">console</span>=ttyS0,115200 earlyprintk <span class="hljs-attribute">root</span>=/dev/mmcblk0p2 <span class="hljs-attribute">rootfstype</span>=ext4 rw rootwait fsck.<span class="hljs-attribute">repair</span>=<span class="hljs-variable">$&#123;fsck.repair&#125;</span> <span class="hljs-attribute">panic</span>=10 <span class="hljs-variable">$&#123;extra&#125;</span> <span class="hljs-attribute">fbcon</span>=<span class="hljs-variable">$&#123;fbcon&#125;</span> <span class="hljs-variable">$&#123;hdmi_res&#125;</span> <span class="hljs-variable">$&#123;overlayfs&#125;</span><br> bootz <span class="hljs-variable">$&#123;kernel_addr&#125;</span> <span class="hljs-variable">$&#123;ramdisk_addr&#125;</span>:<span class="hljs-variable">$&#123;ramdisk_size&#125;</span> <span class="hljs-variable">$&#123;dtb_addr&#125;</span><br><br></code></pre></td></tr></table></figure><h4 id="5-boot-cmd-–-boot-scr：将-boot-scr-也放入-SD-卡的-boot-中即可"><a href="#5-boot-cmd-–-boot-scr：将-boot-scr-也放入-SD-卡的-boot-中即可" class="headerlink" title="5 boot.cmd –&gt; boot.scr：将 boot.scr 也放入 SD 卡的 &#x2F;boot 中即可"></a>5 boot.cmd –&gt; boot.scr：将 boot.scr 也放入 SD 卡的 &#x2F;boot 中即可</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">mkimage -C none -A arm -T <span class="hljs-keyword">script </span>-d <span class="hljs-keyword">boot.cmd </span><span class="hljs-keyword">boot.scr </span>CPU=H3<br></code></pre></td></tr></table></figure><h2 id="2-4-根文件系统"><a href="#2-4-根文件系统" class="headerlink" title="2.4 根文件系统"></a>2.4 根文件系统</h2><h4 id="1-根文件系统解压到-SD-卡："><a href="#1-根文件系统解压到-SD-卡：" class="headerlink" title="1 根文件系统解压到 SD 卡："></a>1 根文件系统解压到 SD 卡：</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo tar -xvf rootfs.tar -C <span class="hljs-regexp">/media/</span>qing<span class="hljs-regexp">/rootfs/</span>  <br></code></pre></td></tr></table></figure><h4 id="2-编译和更新驱动模块：更新-SD-卡上-rootfs-的驱动模块"><a href="#2-编译和更新驱动模块：更新-SD-卡上-rootfs-的驱动模块" class="headerlink" title="2 编译和更新驱动模块：更新 SD 卡上 rootfs 的驱动模块:"></a>2 编译和更新驱动模块：更新 SD 卡上 rootfs 的驱动模块:</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make modules <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-<br>make modules_install <span class="hljs-attribute">INSTALL_MOD_PATH</span>=/media/SD/rootfs/ <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-<br></code></pre></td></tr></table></figure><blockquote><p>make modules_install 命令的作用是：</p><ol><li>将编译好的内核模块从内核源代码目录 copy 到 &#x2F;lib&#x2F;modules 下。也可自己指定 ko 安装路径，在交叉编译的情况下，需要将 ko 模块安装到 rootfs。也即：INSTALL_MOD_PATH&#x3D;&#x2F;media&#x2F;SD&#x2F;rootfs&#x2F;。</li><li>运行 modules_install 的另一个作用是会运行 depmod 去生成 modules.dep 文件，该文件记录了模块之间的依赖关系。这样当 modprobe XXX 的时候就能够把 XXX 所依赖的模块一并加载了。</li></ol></blockquote><h2 id="2-5-挂载-nfs"><a href="#2-5-挂载-nfs" class="headerlink" title="2.5 挂载 nfs"></a>2.5 挂载 nfs</h2><ol><li>ubuntu 先安装 nfs 服务：apt-get install nfs-kernel-server rpcbind</li><li>配置相关文件夹为 nfs 文件夹：vi &#x2F;etc&#x2F;exports</li><li>在最后一行加上文件夹路径：&#x2F;home&#x2F;qing&#x2F;work&#x2F;nfs&#x2F;rootfs_friendlycore-focal_4.14 *(rw,sync,no_root_squash)</li><li>然后重启 ubuntu 服务：&#x2F;etc&#x2F;init.d&#x2F;nfs-kernel-server restart</li><li>被挂载的文件夹最好 ：chmod 777 xxx&#x2F;</li><li>在开发板里面也要安装 nfs 服务：apt-get install nfs-kernel-server rpcbind</li><li>重启开发板的 nfs 服务：&#x2F;etc&#x2F;init.d&#x2F;nfs-kernel-server restart</li><li>挂载：mount -t nfs <em><strong>ubuntu-IP</strong></em>:&#x2F;home&#x2F;qing&#x2F;work&#x2F;nfs&#x2F;rootfs_friendlycore-focal_4.14&#x2F; &#x2F;mnt&#x2F; -o nolock</li></ol><p>参考 OrangePi，以太网要修改 sun8i-h3-YuanPi-plus.dts：因为友善 M1-Plus 用了 RTL8211E，我们是直连的。</p><h1 id="3-软件适配"><a href="#3-软件适配" class="headerlink" title="3.软件适配"></a>3.软件适配</h1><h2 id="3-1-st7789v-彩屏-SPI"><a href="#3-1-st7789v-彩屏-SPI" class="headerlink" title="3.1 st7789v 彩屏 (SPI)"></a>3.1 st7789v 彩屏 (SPI)</h2><h3 id="3-1-1-修改设备树"><a href="#3-1-1-修改设备树" class="headerlink" title="3.1.1 修改设备树"></a>3.1.1 修改设备树</h3><h4 id="1-首先复制一份-sun8i-h3-nanopi-m1-plus-dts-重命名为-sun8i-h3-YuanPi-plus-dts，并修改设备树目录下的-Makefile-加上我们的设备树。最后在-sun8i-h3-YuanPi-plus-dts-中添加："><a href="#1-首先复制一份-sun8i-h3-nanopi-m1-plus-dts-重命名为-sun8i-h3-YuanPi-plus-dts，并修改设备树目录下的-Makefile-加上我们的设备树。最后在-sun8i-h3-YuanPi-plus-dts-中添加：" class="headerlink" title="1 首先复制一份 sun8i-h3-nanopi-m1-plus.dts 重命名为 sun8i-h3-YuanPi-plus.dts，并修改设备树目录下的 Makefile 加上我们的设备树。最后在 sun8i-h3-YuanPi-plus.dts 中添加："></a>1 首先复制一份 sun8i-h3-nanopi-m1-plus.dts 重命名为 sun8i-h3-YuanPi-plus.dts，并修改设备树目录下的 Makefile 加上我们的设备树。最后在 sun8i-h3-YuanPi-plus.dts 中添加：</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">&amp;spi0 &#123;<br>    pinctrl-0 = <span class="hljs-variable">&lt;&amp;spi0_pins &amp;spi0_cs_pins&gt;</span>;<br>    cs-gpios = <span class="hljs-variable">&lt;&amp;pio 2 3 GPIO_ACTIVE_HIGH&gt;</span>;<br><br>    st7789vw: st7789vw<span class="hljs-meta">@0&#123;</span><br>    compatible =<span class="hljs-string">&quot;sitronix,st7789vw&quot;</span>;<br>    reg = <span class="hljs-variable">&lt;0&gt;</span>;<br>    status = <span class="hljs-string">&quot;okay&quot;</span>;<br>    spi-max-frequency = <span class="hljs-variable">&lt;50000000&gt;</span>;<br>    buswidth = <span class="hljs-variable">&lt;8&gt;</span>;<br>    rotate = <span class="hljs-variable">&lt;0&gt;</span>;<br>    fps = <span class="hljs-variable">&lt;60&gt;</span>;<br>    rgb;<br>    spi-cpol;<br>    spi-cpha;<br>    dc-gpios    = <span class="hljs-variable">&lt;&amp;pio 0 0 GPIO_ACTIVE_HIGH&gt;</span>; /<span class="hljs-symbol">*</span> PA0 <span class="hljs-symbol">*</span>/<br>    reset-gpios = <span class="hljs-variable">&lt;&amp;pio 0 1 GPIO_ACTIVE_HIGH&gt;</span>; /<span class="hljs-symbol">*</span> PA1 <span class="hljs-symbol">*</span>/<br>    debug = <span class="hljs-variable">&lt;0x00&gt;</span>;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-修改-sun8i-h3-nanopi-dtsi，将-spi0-结点下的设备都-disabled："><a href="#2-修改-sun8i-h3-nanopi-dtsi，将-spi0-结点下的设备都-disabled：" class="headerlink" title="2 修改 sun8i-h3-nanopi.dtsi，将 spi0 结点下的设备都 disabled："></a>2 修改 sun8i-h3-nanopi.dtsi，将 spi0 结点下的设备都 disabled：</h4><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/3.1.1%E4%BF%AE%E6%94%B9%E8%AE%BE%E5%A4%87%E6%A0%912.png" alt="img"></p><h3 id="3-1-2-修改-kernel"><a href="#3-1-2-修改-kernel" class="headerlink" title="3.1.2 修改 kernel"></a>3.1.2 修改 kernel</h3><blockquote><p>**fbtft 的作用:**驱动各种 spi 接口的 TFT-LCD。</p><p><strong>如果要移植其他显示屏，我们一般只需要重写init_display，和set_addr_win，分别对于初始化和设置写入范围。</strong></p></blockquote><h4 id="1-make-menuconfig-使能-fbtft-框架，并勾选-fb-st7789vw-c："><a href="#1-make-menuconfig-使能-fbtft-框架，并勾选-fb-st7789vw-c：" class="headerlink" title="1 make menuconfig 使能 fbtft 框架，并勾选 fb_st7789vw.c："></a>1 make menuconfig 使能 fbtft 框架，并勾选 fb_st7789vw.c：</h4><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/3.1.2%E4%BF%AE%E6%94%B9kernel1.png" alt="img"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust">Device Drivers  --<span class="hljs-punctuation">-&gt;</span><br>    [*] Staging drivers  --<span class="hljs-punctuation">-&gt;</span><br>        &lt;*&gt;   Support <span class="hljs-keyword">for</span> <span class="hljs-title class_">small</span> TFT LCD display modules  --<span class="hljs-punctuation">-&gt;</span><br>            &lt;*&gt;   Support sysfs <span class="hljs-keyword">for</span> <span class="hljs-title class_">small</span> TFT LCD display modules<br>            &lt;*&gt;   FB driver <span class="hljs-keyword">for</span> <span class="hljs-title class_">the</span> ST7789VW LCD Controller <br>            &lt;*&gt;   Generic FB driver <span class="hljs-keyword">for</span> <span class="hljs-title class_">TFT</span> LCD displays<br>            &lt;*&gt;   Module to <span class="hljs-keyword">for</span> <span class="hljs-title class_">adding</span> FBTFT devices<br></code></pre></td></tr></table></figure><h4 id="2-修改-drivers-staging-fbtft-fb-st7789vw-c："><a href="#2-修改-drivers-staging-fbtft-fb-st7789vw-c：" class="headerlink" title="2 修改 drivers&#x2F;staging&#x2F;fbtft&#x2F;fb_st7789vw.c："></a>2 修改 drivers&#x2F;staging&#x2F;fbtft&#x2F;fb_st7789vw.c：</h4><p>我们的屏幕不需要偏移，将偏移去除：</p><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/3.1.2%E4%BF%AE%E6%94%B9kernel2.png" alt="3.1.2修改kernel2"></p><p>修改分辨率：</p><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/3.1.2%E4%BF%AE%E6%94%B9kernel3.png" alt="3.1.2修改kernel3"></p><p>最后修改初始化代码：将 init_display (struct fbtft_par *par) 中初始化代码换成当下屏幕的即可。</p><h3 id="3-1-3-修改-bootargs"><a href="#3-1-3-修改-bootargs" class="headerlink" title="3.1.3 修改 bootargs"></a>3.1.3 修改 bootargs</h3><h4 id="修改-boot-cmd-–-boot-scr，让屏幕作为-console："><a href="#修改-boot-cmd-–-boot-scr，让屏幕作为-console：" class="headerlink" title="修改 boot.cmd –&gt; boot.scr，让屏幕作为 console："></a>修改 boot.cmd –&gt; boot.scr，让屏幕作为 console：</h4><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/3.1.3%E4%BF%AE%E6%94%B9bootargs1.png" alt="3.1.3修改bootargs1"></p><h3 id="3-1-4-编译烧录"><a href="#3-1-4-编译烧录" class="headerlink" title="3.1.4 编译烧录"></a>3.1.4 编译烧录</h3><p>编译出 zImage、sun8i-h3-YuanPi-plus.dtb、boot.scr，重新烧录，成功！</p><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/image-20240301160315717.png" alt="image-20240301160315717"></p><h4 id><a href="#" class="headerlink" title></a></h4><h2 id="3-2-GT911-电容触摸-IIC"><a href="#3-2-GT911-电容触摸-IIC" class="headerlink" title="3.2 GT911 电容触摸 (IIC)"></a>3.2 GT911 电容触摸 (IIC)</h2><h3 id="3-2-1-修改设备树"><a href="#3-2-1-修改设备树" class="headerlink" title="3.2.1 修改设备树"></a>3.2.1 修改设备树</h3><p>GT911 使用的是 IIC 接口，可以设置中断模式，当有触摸动作则会触发中断，在中断中读取寄存器信息，通过 input 上报坐标，因为板子上的 i2c0 在硬件上已经上拉，所以设备树不用上拉，修改设备树如下：sun8i-h3-YuanPi-plus.dts</p><p><img src="/2024/06/27/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/3.2.1%E4%BF%AE%E6%94%B9%E8%AE%BE%E5%A4%87%E6%A0%911.png" alt="3.2.1修改设备树1"></p><h3 id="3-2-2-编写驱动"><a href="#3-2-2-编写驱动" class="headerlink" title="3.2.2 编写驱动"></a>3.2.2 编写驱动</h3><p>电容触摸屏驱动其实就是以下几种 linux 驱动框架的组合：</p><ol><li>IIC 设备驱动，因为电容触摸 IC 基本都是 IIC 接口的，因此大框架就是 IIC 设备驱动。</li><li>通过中断引脚 (INT) 向 内核上报触摸信息，因此需要用到中断驱动框架。坐标的上报在中断服务函数中完成。</li><li>触摸屏的坐标信息、屏幕按下和抬起信息都属于 input 子系统，因此向内核上报触摸屏坐标信息就得使用 input 子系统。只是我们得按照 linux 内核规定的规则来上报坐标信息。</li></ol><p>在实际驱动 GT911 需要注意如下几点：</p><ol><li>与其他的 IIC 设备不同，GT911 的器件地址需要根据初始化时序来确定，地址确定后才能用 i2cdetect 检测出地址。</li><li>当输出中断后请在一个中断周期内读走坐标并将 buffer status (0x814E) 写为 0，若未在中断内读走坐标，下次 IC 即使检测到坐标更新会再输出一个中断脉冲，但不更新坐标，如果一直没有读取坐标则会一直打脉冲，导致中断一直被触发。</li><li>我们的屏幕进行了旋转，所以读取出来的坐标也需要在软件上进行调整，如下：</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">我们的屏幕旋转了<span class="hljs-number">90</span>度，对应如下：<br>原先      --&gt;   旋转后   <br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span>     --&gt;</span>  (<span class="hljs-number">0</span>,<span class="hljs-number">240</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">240</span>,<span class="hljs-number">0</span>)</span>   --&gt;</span>  (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">320</span>)</span>   --&gt;</span>  (<span class="hljs-number">320</span>,<span class="hljs-number">240</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">240</span>,<span class="hljs-number">320</span>)</span> --&gt;</span>  (<span class="hljs-number">320</span>,<span class="hljs-number">0</span>)<br>所以对应的调整关系是:<br><span class="hljs-function"><span class="hljs-params">(X,Y)</span>     --&gt;</span>  (Y,|X-<span class="hljs-number">240</span>|)<br></code></pre></td></tr></table></figure><p><em><strong>完整代码如下所示，相应注释已给出：</strong></em></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mutex.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mod_devicetable.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bitops.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/jiffies.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/property.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/acpi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/i2c.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/nvmem-provider.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/regmap.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/pm_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio/consumer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/spinlock.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/atomic.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/unaligned.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/mt.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/touchscreen.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrupt.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GT_CTRL_REG         0X8040  <span class="hljs-comment">/* GT911控制寄存器         */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GT_9xx_CFGS_REG     0X8047  <span class="hljs-comment">/* GT9147配置起始地址寄存器    */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GT_1xx_CFGS_REG     0X8050  <span class="hljs-comment">/* GT1151配置起始地址寄存器    */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GT_PID_REG         0X8140  <span class="hljs-comment">/* GT911产品ID寄存器       */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GT_GSTID_REG         0X814E  <span class="hljs-comment">/* GT911当前检测到的触摸情况 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GT_TP1_REG         0X814F  <span class="hljs-comment">/* 第一个触摸点数据地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SUPPORT_POINTS      5       <span class="hljs-comment">/* 最多5点电容触摸 */</span></span><br><br><span class="hljs-type">const</span> u8 irq_table[] = &#123;IRQ_TYPE_EDGE_RISING, IRQ_TYPE_EDGE_FALLING, IRQ_TYPE_LEVEL_LOW, IRQ_TYPE_LEVEL_HIGH&#125;;  <span class="hljs-comment">/* 触发方式 */</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gt911_dev</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_desc</span>   *reset_pin;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_desc</span>   *irq_pin;<br><span class="hljs-type">int</span> irqnum;<span class="hljs-comment">/* 中断号    */</span><br><span class="hljs-type">int</span> irqtype;<span class="hljs-comment">/* 中断类型         */</span><br><span class="hljs-type">int</span> max_x;<span class="hljs-comment">/* 最大横坐标   */</span><br><span class="hljs-type">int</span> max_y; <span class="hljs-comment">/* 最大纵坐标*/</span><br><span class="hljs-type">void</span> *private_data;<span class="hljs-comment">/* 私有数据 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">input_dev</span> *input;<span class="hljs-comment">/* input结构体 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_client</span> *client;<span class="hljs-comment">/* I2C客户端 */</span><br><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gt911_dev</span> gt911;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description     : 复位GT911</span><br><span class="hljs-comment"> * @param - client : 要操作的i2c</span><br><span class="hljs-comment"> * @param - multidev: 自定义的multitouch设备</span><br><span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gt911_reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-keyword">struct</span> gt911_dev *dev)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;reset_pin and int_pin = 0 hold 10ms!\n&quot;</span>);<br>    <span class="hljs-built_in">gpiod_set_value</span>(dev-&gt;reset_pin, <span class="hljs-number">0</span>); <span class="hljs-comment">//设低电平</span><br>    <span class="hljs-built_in">gpiod_set_value</span>(dev-&gt;irq_pin, <span class="hljs-number">0</span>);   <span class="hljs-comment">//设低电平</span><br>    <span class="hljs-built_in">mdelay</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;reset_pin = 1 hold 10ms!\n&quot;</span>);<br>    <span class="hljs-built_in">gpiod_set_value</span>(dev-&gt;reset_pin, <span class="hljs-number">1</span>); <span class="hljs-comment">//设高电平</span><br>    <span class="hljs-built_in">mdelay</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;set int_pin as input!\n&quot;</span>);<br>    <span class="hljs-built_in">gpiod_direction_input</span>(dev-&gt;irq_pin);<br><br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;now gt911&#x27;s addr is 0xBA/0xBB, and i2c addr is 0x5d\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 向GT911多个寄存器写入数据，寄存器的地址指针会在写操作后自动加 1，所以当需要对连续地址的寄存器进行写操作时，可以在一次写操作中连续写入。</span><br><span class="hljs-comment"> * @param - dev:  GT911设备</span><br><span class="hljs-comment"> * @param - reg:  要写入的寄存器首地址</span><br><span class="hljs-comment"> * @param - val:  要写入的数据缓冲区</span><br><span class="hljs-comment"> * @param - len:  要写入的数据长度</span><br><span class="hljs-comment"> * @return   :   操作结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> s32 <span class="hljs-title">gt911_write_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gt911_dev *dev, u16 reg, u8 *buf, u8 len)</span></span><br><span class="hljs-function"></span>&#123;<br>u8 b[<span class="hljs-number">256</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_msg</span> msg;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_client</span> *client = (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;client;<br><br>b[<span class="hljs-number">0</span>] = reg &gt;&gt; <span class="hljs-number">8</span>;<span class="hljs-comment">/* 寄存器首地址低8位 */</span><br>    b[<span class="hljs-number">1</span>] = reg &amp; <span class="hljs-number">0XFF</span>;<span class="hljs-comment">/* 寄存器首地址高8位 */</span><br><span class="hljs-built_in">memcpy</span>(&amp;b[<span class="hljs-number">2</span>],buf,len);<span class="hljs-comment">/* 将要写入的数据拷贝到数组b里面 */</span><br><br>msg.addr = client-&gt;addr;<span class="hljs-comment">/* gt911地址 */</span><br>msg.flags = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 标记为写数据 */</span><br><br>msg.buf = b;<span class="hljs-comment">/* 要写入的数据缓冲区 */</span><br>msg.len = len + <span class="hljs-number">2</span>;<span class="hljs-comment">/* 要写入的数据长度，总长度要加上两个寄存器 */</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">i2c_transfer</span>(client-&gt;adapter, &amp;msg, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 从GT911读取多个寄存器数据</span><br><span class="hljs-comment"> * @param - dev:  GT911设备</span><br><span class="hljs-comment"> * @param - reg:  要读取的寄存器首地址</span><br><span class="hljs-comment"> * @param - buf:  读取到的数据</span><br><span class="hljs-comment"> * @param - len:  要读取的数据长度</span><br><span class="hljs-comment"> * @return : 操作结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gt911_read_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gt911_dev *dev, u16 reg, u8 *buf, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret;<br>    u8 regdata[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_msg</span> msg[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_client</span> *client = (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;client;<br>    <br>    <span class="hljs-comment">/* GT911寄存器长度为2个字节 */</span><br>    regdata[<span class="hljs-number">0</span>] = reg &gt;&gt; <span class="hljs-number">8</span>;<br>    regdata[<span class="hljs-number">1</span>] = reg &amp; <span class="hljs-number">0xFF</span>;<br><br><span class="hljs-comment">/* msg[0]为发送要读取的首地址 */</span><br>msg[<span class="hljs-number">0</span>].addr = client-&gt;addr;<span class="hljs-comment">/* GT911的i2c地址 */</span><br>msg[<span class="hljs-number">0</span>].flags = !I2C_M_RD;<span class="hljs-comment">/* 标记为发送数据 */</span><br>msg[<span class="hljs-number">0</span>].buf = &amp;regdata[<span class="hljs-number">0</span>];<span class="hljs-comment">/* 读取的首地址 */</span><br>msg[<span class="hljs-number">0</span>].len = <span class="hljs-number">2</span>;<span class="hljs-comment">/* reg长度*/</span><br><br><span class="hljs-comment">/* msg[1]读取数据 */</span><br>msg[<span class="hljs-number">1</span>].addr = client-&gt;addr;<span class="hljs-comment">/* GT911的i2c地址 */</span><br>msg[<span class="hljs-number">1</span>].flags = I2C_M_RD;<span class="hljs-comment">/* 标记为读取数据*/</span><br>msg[<span class="hljs-number">1</span>].buf = buf;<span class="hljs-comment">/* 读取数据缓冲区 */</span><br>msg[<span class="hljs-number">1</span>].len = len;<span class="hljs-comment">/* 要读取的数据长度*/</span><br><br>ret = <span class="hljs-built_in">i2c_transfer</span>(client-&gt;adapter, msg, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">if</span>(ret == <span class="hljs-number">2</span>) &#123;<br>ret = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ret = -EREMOTEIO;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description     : GT911读取固件</span><br><span class="hljs-comment"> * @param - client : 要操作的i2c</span><br><span class="hljs-comment"> * @param - multidev: 自定义的multitouch设备</span><br><span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gt911_read_firmware</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-keyword">struct</span> gt911_dev *dev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, version = <span class="hljs-number">0</span>;<br>u16 id = <span class="hljs-number">0</span>;<br>u8 data[<span class="hljs-number">7</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> id_str[<span class="hljs-number">5</span>];<br>ret = <span class="hljs-built_in">gt911_read_regs</span>(dev, GT_PID_REG, data, <span class="hljs-number">6</span>);<br><span class="hljs-keyword">if</span> (ret) &#123;<br><span class="hljs-built_in">dev_err</span>(&amp;client-&gt;dev, <span class="hljs-string">&quot;Unable to read PID.\n&quot;</span>);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-built_in">memcpy</span>(id_str, data, <span class="hljs-number">4</span>);<br>id_str[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">kstrtou16</span>(id_str, <span class="hljs-number">10</span>, &amp;id))<br>    &#123;<br>        id = <span class="hljs-number">0x1001</span>;<br>    &#125;<br>version = <span class="hljs-built_in">get_unaligned_le16</span>(&amp;data[<span class="hljs-number">4</span>]);<br><span class="hljs-built_in">dev_info</span>(&amp;client-&gt;dev, <span class="hljs-string">&quot;ID %d, version: %04x\n&quot;</span>, id, version);<br><span class="hljs-keyword">switch</span> (id) &#123;    <span class="hljs-comment">/* 由于不同的芯片配置寄存器地址不一样需要判断一下  */</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">911</span>:<br>        ret = <span class="hljs-built_in">gt911_read_regs</span>(dev, GT_9xx_CFGS_REG, data, <span class="hljs-number">7</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">break</span>;<br>    &#125;<br><span class="hljs-keyword">if</span> (ret) &#123;<br><span class="hljs-built_in">dev_err</span>(&amp;client-&gt;dev, <span class="hljs-string">&quot;Unable to read Firmware.\n&quot;</span>);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>dev-&gt;max_x = (data[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>) + data[<span class="hljs-number">1</span>];<br>dev-&gt;max_y = (data[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">8</span>) + data[<span class="hljs-number">3</span>];<br>dev-&gt;irqtype = data[<span class="hljs-number">6</span>] &amp; <span class="hljs-number">0x3</span>;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;X_MAX: %d, Y_MAX: %d, Touch Number: %d, TRIGGER: 0x%02x\n&quot;</span>, dev-&gt;max_x, dev-&gt;max_y, data[<span class="hljs-number">5</span>], dev-&gt;irqtype);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">我们的屏幕旋转了90度，对应如下：</span><br><span class="hljs-comment">原先      --&gt;   旋转后   </span><br><span class="hljs-comment">(0,0)     --&gt;  (0,240)</span><br><span class="hljs-comment">(240,0)   --&gt;  (0,0)</span><br><span class="hljs-comment">(0,320)   --&gt;  (320,240)</span><br><span class="hljs-comment">(240,320) --&gt;  (320,0)</span><br><span class="hljs-comment">所以对应的调整关系是:</span><br><span class="hljs-comment">(X,Y)     --&gt;  (Y,|X-240|)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">adjust_x_y</span><span class="hljs-params">(<span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> tmp;<br>tmp = *x;<br>*x = *y;<br><span class="hljs-keyword">if</span>(tmp &gt;= gt911.max_x)<br>*y = tmp - gt911.max_x;<br><span class="hljs-keyword">else</span><br>*y = gt911.max_x - tmp;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title">gt911_irq_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> touch_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> input_x, input_y;<br>    <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    u8 data;<br>    u8 touch_data[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">gt911_dev</span> *dev = dev_id;<br><br>    ret = <span class="hljs-built_in">gt911_read_regs</span>(dev, GT_GSTID_REG, &amp;data, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (data == <span class="hljs-number">0x00</span>)  &#123;     <span class="hljs-comment">/* 没有触摸数据，直接返回 */</span><br>        <span class="hljs-keyword">goto</span> fail;<br>    &#125; <span class="hljs-keyword">else</span> &#123;                 <span class="hljs-comment">/* 统计触摸点数据 */</span><br>        touch_num = data &amp; <span class="hljs-number">0x0f</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//这里暂时使用单点触摸 </span><br>    <span class="hljs-keyword">if</span>(touch_num) &#123;         <span class="hljs-comment">/* 单点触摸按下 */</span><br>        <span class="hljs-built_in">gt911_read_regs</span>(dev, GT_TP1_REG, touch_data, <span class="hljs-number">5</span>);<br>        id = touch_data[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x0F</span>;<br>        <span class="hljs-keyword">if</span>(id == <span class="hljs-number">0</span>) &#123;<br>            input_x  = touch_data[<span class="hljs-number">1</span>] | (touch_data[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>);<br>            input_y  = touch_data[<span class="hljs-number">3</span>] | (touch_data[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">8</span>);<br><br>            <span class="hljs-comment">//旋转了屏幕，从软件上调整坐标</span><br>            <span class="hljs-built_in">adjust_x_y</span>(&amp;input_x, &amp;input_y);<br><br>            <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;X: %d, Y: %d\n&quot;</span>, input_x, input_y);<br><br>            <span class="hljs-comment">//上报坐标</span><br>            <span class="hljs-built_in">input_mt_slot</span>(dev-&gt;input, id);<br>    <span class="hljs-built_in">input_mt_report_slot_state</span>(dev-&gt;input, MT_TOOL_FINGER, <span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">input_report_abs</span>(dev-&gt;input, ABS_MT_POSITION_X, input_x);<br>    <span class="hljs-built_in">input_report_abs</span>(dev-&gt;input, ABS_MT_POSITION_Y, input_y);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(touch_num == <span class="hljs-number">0</span>)&#123;                <span class="hljs-comment">/* 单点触摸释放 */</span><br>        <span class="hljs-built_in">input_mt_slot</span>(dev-&gt;input, id);<br>        <span class="hljs-built_in">input_mt_report_slot_state</span>(dev-&gt;input, MT_TOOL_FINGER, <span class="hljs-literal">false</span>);<br>    &#125;<br><br><span class="hljs-built_in">input_mt_report_pointer_emulation</span>(dev-&gt;input, <span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">input_sync</span>(dev-&gt;input);<br><br>    data = <span class="hljs-number">0x00</span>;                <span class="hljs-comment">/* 向0X814E寄存器写0 */</span><br>    <span class="hljs-built_in">gt911_write_regs</span>(dev, GT_GSTID_REG, &amp;data, <span class="hljs-number">1</span>);<br><br>fail:<br><span class="hljs-keyword">return</span> IRQ_HANDLED;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description     : GT911中断初始化</span><br><span class="hljs-comment"> * @param - client : 要操作的i2c</span><br><span class="hljs-comment"> * @param - multidev: 自定义的multitouch设备</span><br><span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gt911_ts_irq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-keyword">struct</span> gt911_dev *dev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* 申请中断,client-&gt;irq就是IO中断， */</span><br>ret = <span class="hljs-built_in">devm_request_threaded_irq</span>(&amp;client-&gt;dev, client-&gt;irq, <span class="hljs-literal">NULL</span>,<br>gt911_irq_handler, irq_table[dev-&gt;irqtype] | IRQF_ONESHOT,<br>client-&gt;name, &amp;gt911);<br><span class="hljs-keyword">if</span> (ret) &#123;<br><span class="hljs-built_in">dev_err</span>(&amp;client-&gt;dev, <span class="hljs-string">&quot;Unable to request touchscreen IRQ.\n&quot;</span>);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">GT911_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span></span><br><span class="hljs-function"></span>&#123;<br><br>u8 data, ret;<br>gt911.client = client;<br><br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><br>    <span class="hljs-comment">/* 1，获取设备树中的中断和复位引脚 */</span><br>gt911.irq_pin = <span class="hljs-built_in">devm_gpiod_get</span>(&amp;client-&gt;dev,<span class="hljs-string">&quot;interrupt&quot;</span>,GPIOD_OUT_LOW);<br>gt911.reset_pin = <span class="hljs-built_in">devm_gpiod_get</span>(&amp;client-&gt;dev, <span class="hljs-string">&quot;reset&quot;</span>, GPIOD_OUT_LOW);<br><br><span class="hljs-comment">/* 2，复位GT911 */</span><br><span class="hljs-built_in">gt911_reset</span>(client, &amp;gt911);<br><br>    <span class="hljs-comment">/* 3，初始化GT911 */</span><br>    data = <span class="hljs-number">0x02</span>;<br>    <span class="hljs-built_in">gt911_write_regs</span>(&amp;gt911, GT_CTRL_REG, &amp;data, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 软复位 */</span><br>    <span class="hljs-built_in">mdelay</span>(<span class="hljs-number">100</span>);<br>    data = <span class="hljs-number">0x0</span>;<br>    <span class="hljs-built_in">gt911_write_regs</span>(&amp;gt911, GT_CTRL_REG, &amp;data, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 停止软复位 */</span><br>    <span class="hljs-built_in">mdelay</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">/* 4,初始化GT911，读取固件  */</span><br>ret = <span class="hljs-built_in">gt911_read_firmware</span>(client, &amp;gt911);<br><span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;Fail !!! check !!\r\n&quot;</span>);<br><span class="hljs-keyword">goto</span> fail;<br>    &#125;<br><br>    <span class="hljs-comment">/* 5，input设备注册 */</span><br>gt911.input = <span class="hljs-built_in">devm_input_allocate_device</span>(&amp;client-&gt;dev);<br><span class="hljs-keyword">if</span> (!gt911.input) &#123;<br>ret = -ENOMEM;<br><span class="hljs-keyword">goto</span> fail;<br>&#125;<br>gt911.input-&gt;name = client-&gt;name;<br>gt911.input-&gt;id.bustype = BUS_I2C;<br>gt911.input-&gt;dev.parent = &amp;client-&gt;dev;<br><br>__set_bit(EV_KEY, gt911.input-&gt;evbit);<br>__set_bit(EV_ABS, gt911.input-&gt;evbit);<br>__set_bit(BTN_TOUCH, gt911.input-&gt;keybit);<br><br><span class="hljs-built_in">input_set_abs_params</span>(gt911.input, ABS_X, <span class="hljs-number">0</span>, gt911.max_x, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">input_set_abs_params</span>(gt911.input, ABS_Y, <span class="hljs-number">0</span>, gt911.max_y, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">input_set_abs_params</span>(gt911.input, ABS_MT_POSITION_X,<span class="hljs-number">0</span>, gt911.max_x, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">input_set_abs_params</span>(gt911.input, ABS_MT_POSITION_Y,<span class="hljs-number">0</span>, gt911.max_y, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);     <br>ret = <span class="hljs-built_in">input_mt_init_slots</span>(gt911.input, MAX_SUPPORT_POINTS, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (ret) &#123;<br><span class="hljs-keyword">goto</span> fail;<br>&#125;<br><br>ret = <span class="hljs-built_in">input_register_device</span>(gt911.input);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> fail;<br><br>    <span class="hljs-comment">/* 6，最后初始化中断 */</span><br>ret = <span class="hljs-built_in">gt911_ts_irq</span>(client, &amp;gt911);<br><span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">goto</span> fail;<br>&#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>fail:<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">of_device_id</span> of_match_ids_GT911[] = &#123;<br>&#123; .compatible = <span class="hljs-string">&quot;my_gt911&quot;</span>,.data = <span class="hljs-literal">NULL</span> &#125;,<br>&#123; <span class="hljs-comment">/* END OF LIST */</span> &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_device_id</span> GT911_ids[] = &#123;<br>&#123; <span class="hljs-string">&quot;gt911&quot;</span>,(<span class="hljs-type">kernel_ulong_t</span>)<span class="hljs-literal">NULL</span> &#125;,<br>&#123; <span class="hljs-comment">/* END OF LIST */</span> &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">GT911_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_driver</span> i2c_GT911_driver = &#123;<br>.driver = &#123;<br>.name = <span class="hljs-string">&quot;gt911&quot;</span>,<br>.of_match_table = of_match_ids_GT911,<br>&#125;,<br>.probe = GT911_probe,<br>.remove = GT911_remove,<br>.id_table = GT911_ids,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">i2c_driver_GT911_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">i2c_add_driver</span>(&amp;i2c_GT911_driver);<br>&#125;<br><span class="hljs-built_in">module_init</span>(i2c_driver_GT911_init);<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">i2c_driver_GT911_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">i2c_del_driver</span>(&amp;i2c_GT911_driver);<br>&#125;<br><span class="hljs-built_in">module_exit</span>(i2c_driver_GT911_exit);<br><br><span class="hljs-built_in">MODULE_AUTHOR</span>(<span class="hljs-string">&quot;LK&quot;</span>);<br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-2-3-移植-tslib"><a href="#3-2-3-移植-tslib" class="headerlink" title="3.2.3 移植 tslib"></a>3.2.3 移植 tslib</h3><p>tslib 是一个开源的第三方库，用于触摸屏性能调试，使用电阻屏的时候一般使用 tslib 进行校准。虽然电容屏不需要校准，但主要的是 tslib 提供了一些其他软件，我们可以通过这些软件来测试触摸屏工作是否正常。最新版本的 tslib 已经支持了多点电容触摸屏，因此可以通过 tslib 来直观的测试多点电容触摸屏驱动，这个要比观看 eventX 原始数据方便的多。</p><p>①获取 tslib 源码。git 地址为：<a href="https://github.com/kergoth/tslib">https://github.com/kergoth/tslib</a> ，目前最新的版本是 1.21。</p><p>②修改 tslib 源码所属用户，修改解压得到的 tslib-1.21 目录所属用户为当前用户，这一步一定要做！否则在稍后的编译中会遇到各种问题。我当前 ubuntu 的登录用户名为 “lk”，修改命令如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> chown lk:lk tslib-<span class="hljs-number">1</span>.<span class="hljs-number">21</span> -R<br></code></pre></td></tr></table></figure><p>③ubuntu 工具安装：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install autoconf<br>sudo apt-<span class="hljs-built_in">get</span> install automake<br>sudo apt-<span class="hljs-built_in">get</span> install libtool<br></code></pre></td></tr></table></figure><p>④编译 tslib：编译完成后在安装目录中，bin 目录下是可执行文件，包括 tslib 的测试工具。etc 目录下是 tslib 的配置文件，lib 目录下是相关的库文件，将所有文件拷贝到开发板中。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./autogen.sh</span><br><span class="hljs-string">./configure</span> <span class="hljs-params">--host=arm-linux</span> <span class="hljs-params">--prefix=</span><span class="hljs-string">&quot;安装目录&quot;</span><br>make &amp;&amp; make install <br></code></pre></td></tr></table></figure><p>⑤配置 tslib</p><ol><li>打开 etc&#x2F;ts.conf 文件，找到 module_raw input，如果这句前面有 “#” 的话就删除掉 “#”。</li><li>在开发板终端输入：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 注意，下面路径是根目录，如果没有这些文件，运行时会生成</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">TSLIB_TSDEVICE</span>=/dev/input/event2<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">TSLIB_CALIBFILE</span>=/etc/pointercal<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">TSLIB_CONFFILE</span>=/etc/ts.conf<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">TSLIB_PLUGINDIR</span>=/lib/ts<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">TSLIB_CONSOLEDEVICE</span>=none<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">TSLIB_FBDEVICE</span>=/dev/fb1<br></code></pre></td></tr></table></figure><p>⑥ tslib 测试：使用 ts_test_mt 来测试触摸屏工作是否正常，测试结果如下，一切正常：</p><p><em><strong>至此，从头写 GT911 触摸驱动就圆满完成了！</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2024/06/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/06/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="何为进程和线程"><a href="#何为进程和线程" class="headerlink" title="何为进程和线程"></a>何为进程和线程</h2><ul><li><p>进程</p><p>是<strong>资源分配</strong>的最小单位，它是程序执行时的一个实例，在程序运行时创建</p></li><li><p>线程</p><p>是<strong>程序执行</strong>的最小单位，也是<strong>处理器调度</strong>的基本单位，是进程的一个执行流，<strong>一个进程由多个线程组成的</strong></p></li></ul><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li><p><strong>进程有自己的独立地址空间</strong>，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代 码段、堆栈段和数据段，这种操作非常昂贵；而<strong>线程是共享进程中的数据</strong>，<strong>使用相同的地址空间</strong>， 因此，CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也比进程小很多</p></li><li><p><strong>线程之间的通信更方便</strong>，同一进程下的线程共享全局变量、静态变量等数据，而<strong>进程之间的通信需 要以通信的方式（IPC）进行</strong>。不过如何处理好同步与互斥是编写多线程程序的难点。但是<strong>多进程程序更健壮</strong>，<strong>多线程程序只要有一个线程死掉，整个进程也跟着死掉了，而一个进程死掉并不会对另 外一个进程造成影响，因为进程有自己独立的地址空间</strong>**</p></li><li><p><strong>进程切换时，消耗的资源大，效率低</strong>。所以涉及到频繁的切换时，使用线程要好于进程。同样如果 要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程</p></li><li><p>执行过程：<strong>每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口</strong>。但是<strong>线程不能独立执行</strong>，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p></li><li><p><strong>线程执行开销小，但是不利于资源的管理和保护</strong>。线程适合在SMP机器（双CPU系统）上运行。进<strong>程执行开销大，但是能够很好的进行资源管理和保护</strong>，可以跨机器迁移。</p></li></ul><h2 id="何时使用多进程，何时使用多线程？"><a href="#何时使用多进程，何时使用多线程？" class="headerlink" title="何时使用多进程，何时使用多线程？"></a>何时使用多进程，何时使用多线程？</h2><p>对资源的管理和保护要求高，不限制开销和效率时，使用<strong>多进程</strong>。 </p><p>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用<strong>多线程</strong>。</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><img src="/2024/06/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231212142116596.png" alt="image-20231212142116596"></p><ul><li><p>创建态</p><p>一个应用程序从系统上启动，首先就是进入创建状态，需要获取系统资源创建进程管理块（PCB： Process Control Block）完成资源分配</p></li><li><p>就绪态</p><p>在创建状态完成之后，进程已经准备好，但是还未获得处理器资源，无法运行</p></li><li><p>运行态</p><p>获取处理器资源，被系统调度，开始进入运行状态。如果进程的时间片用完了就进入就绪状态</p></li><li><p>阻塞态</p><p>在运行状态期间，如果进行了阻塞的操作，如耗时的I&#x2F;O操作，此时进程暂时无法操作就进入到了阻塞状 态，在这些操作完成后就进入就绪状态</p></li><li><p>终止态</p><p>进程结束或者被系统终止，进入终止状态</p></li></ul><h2 id="linux创建进程的方式"><a href="#linux创建进程的方式" class="headerlink" title="linux创建进程的方式"></a>linux创建进程的方式</h2><ul><li><p><strong>fork创建</strong></p><p>⼀个进程时，⼦进程只是完全复制⽗进程的资源，复制出来的⼦进程 有⾃⼰的t ask_struct结构和pi d, 但却复制⽗进程其它所有的资源。 </p></li><li><p><strong>vfork创建：</strong></p><p>系统调⽤不同于fork，⽤vfork创建的⼦进程与⽗进程共享地址空间， 也就是说⼦进程完全运⾏在⽗进程的地址空间上，如果这时⼦进程修改了某个变量， 这将影响到⽗进程 </p></li><li><p><strong>clone（）是带有参数的</strong></p></li></ul><p><strong>fork( ) 是全部复制，vfor k( ) 是共享内存，⽽clone( ) 是则可以将⽗进程资源有选择地复制给⼦进程</strong></p><h2 id="进程间的通信方式以及特点"><a href="#进程间的通信方式以及特点" class="headerlink" title="进程间的通信方式以及特点"></a>进程间的通信方式以及特点</h2><ul><li><p>管道（pipe ）</p><ul><li><p>管道（无名管道）</p><p>这种通讯方式<strong>有两种限制</strong>，<strong>一是</strong>半双工的通信，数据只能单向流动，<strong>二是</strong>只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系</p></li><li><p>流管道（s_pipe）</p><p>去除了第一种限制,<strong>可以双向传输</strong>（全双工）</p></li><li><p>命名管道（FIFO）</p><p>克服了管道没有名字的限制，因此，除 具有管道所具有的功能外，它还<strong>允许无亲缘关系进程间的通信</strong></p></li></ul></li><li><p>信号量（semaphore）</p><p>信号量是一个<strong>计数器</strong>，可以用来<strong>控制多个进程对共享资源的访问</strong>。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为<strong>进程间</strong>以及<strong>同一进程内不同线程之间</strong>的同步手段</p></li><li><p>消息队列（message queue）</p><p><strong>消息队列是由消息组成的链表</strong>，存放在内核中并由消息队列标识符标识。</p><p>消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加 消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承 载无格式字节流以及缓冲区大小受限等缺点。</p><p>息发送后可以⽴即返回，有消息系统来确保信息的可靠专递，消息发布者只管把消息发布到MQ中⽽不管谁来取， 消息使⽤者只管从MQ中取消息⽽不管谁发布的，这样发布者和使⽤者都不⽤知道对⽅的存在。</p></li><li><p>信号</p><p>信号是通讯⽅式，信号量是⼀个计数器，限制资源访问线程的数</p><p>信号是一种比较复杂的通信方式，用于<strong>通知接收进程某个事件已经发生</strong>。主要作为进程间以及同一进程 不同线程之间的同步手段。</p></li><li><p>共享内存</p><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以 访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与 其他通信机制，如信号量，配合使用，来实现进程间的同步和通信</p></li><li><p>套字节</p><p>套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信</p><p>由I P地址可以唯⼀确定⼀台主机，但是准确来说，⽹络通讯中的双⽅并不是主机，⽽是运⾏在主机上的进程， 这样就需要进⼀步确定是主机中的哪个进程要进⾏⽹络通讯。因此，除了I P地址之外，还需要端⼝号来唯⼀确定主机中的通讯进程。 I P地址和端⼝号就构成了⼀个⽹络中的唯⼀标识符，即套接字</p></li></ul><p><strong>各通信方式的比较和优缺点：</strong></p><ul><li>管道 ：速度慢，容量有限，只有父子进程能通讯</li><li>FIFO ：任何进程间都能通讯，但速度慢。</li><li>消息队列 ：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题，消息队列可以不再 局限于父子进程，而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息 发送和接收之间的同步，从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用方便， 但是<strong>信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合</strong>。此种方法不太常用</li><li>信号量 ：不能用来传递复杂消息，只能用来同步</li><li>共享内存：利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。共享内存块提供了在任意数量的 进程之间进行高效双向通信的机制。每个使用者都可以读取写入数据，但是所有程序之间必须达成并遵 守一定的协议，以防止诸如在读取信息之前覆写内存空间等竞争状态的出现</li></ul><p><strong>进程间通信方式的选择</strong>：</p><p>PIPE和FIFO(有名管道)用来实现进程间相互发送非常短小的、频率很高的消息，这两种方式通常适用于 <strong>两个进程间</strong>的通信。</p><p>共享内存用来实现进程间共享的、非常庞大的、读写操作频率很高的数据；这种方法适用于<strong>多进程间</strong>的 通信。</p><p>其他考虑用socket。主要应用在分布式开发中</p><h2 id="线程间的同步方式"><a href="#线程间的同步方式" class="headerlink" title="线程间的同步方式"></a>线程间的同步方式</h2><p>现在流行的进程线程同步互斥的控制机制，其实是由最原始、最基本的4种方法（临界区、互斥量、信号 量和事件）实现的</p><ul><li><p>临界区</p><p>通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意 时刻只允许一个线程访问共享资源，如果有多个线程试图访问共享资源，那么当有一个线程进入 后，其他试图访问共享资源的线程将会被挂起，并一直等到进入临界区的线程离开，临界在被释放 后，其他线程才可以抢占</p></li><li><p>互斥量</p><p>为协调对一个共享资源的单独访问而设计，只有拥有互斥量的线程，才有权限去访问系统 的公共资源，因为互斥量只有一个，所以能够保证资源不会同时被多个线程访问。互斥不仅能实现 同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享</p></li><li><p>信号量</p><p>为控制一个具有有限数量的用户资源而设计。它允许多个线程在同一个时刻去访问同一个 资源，但一般需要限制同一时刻访问此资源的最大线程数目</p></li><li><p>事件</p><p>用来通知线程有一些事件已发生，从而启动后继任务的开始</p></li></ul><h2 id="内核线程和用户线程"><a href="#内核线程和用户线程" class="headerlink" title="内核线程和用户线程"></a>内核线程和用户线程</h2><ul><li><p>内核线程</p><p>由操作系统内核创建和撤销。内核维护进程及线程的上下文信息以及线程切换。一个内核线 程由于I&#x2F;O操作而阻塞，不会影响其它线程的运行</p></li><li><p>用户线程、</p><p>不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态&#x2F;核心态切换，速度快，操作 系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这 里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少</p></li></ul><h2 id="内核线程和用户线程的优缺点"><a href="#内核线程和用户线程的优缺点" class="headerlink" title="内核线程和用户线程的优缺点"></a>内核线程和用户线程的优缺点</h2><ol><li>内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。 </li><li>用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核 支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同 的。 </li><li>用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时， 只导致该线程被中断。 </li><li>在只有<strong>用户级线程的系统</strong>内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由 用户程序控制线程的轮换运行；在有<strong>内核支持线程的系统</strong>内，CPU调度则以线程为单位，由OS的线 程调度程序负责线程的调度。 </li><li>用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何 状态下的程序。</li></ol><p><strong>内核线程的优点：</strong> 当有多个处理机时，一个进程的多个线程可以同时执行。</p><p><strong>内核线程的缺点：</strong> 由内核进行调度。</p><p><strong>用户线程的优点：</strong></p><ol><li>线程的调度不需要内核直接参与，控制简单。 </li><li>可以在不支持线程的操作系统中实现。 </li><li>创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。 </li><li>允许每个进程定制自己的调度算法，线程管理比较灵活。这就是必须自己写管理程序，与内核线程 的区别 </li><li>线程能够利用的表空间和堆栈空间比内核级线程多。 </li><li>同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都 会被挂起。另外，页面失效也会产生同样的问题。</li></ol><p><strong>用户线程的缺点：</strong>资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</p><h2 id="僵尸进程、孤儿进程、守护进程"><a href="#僵尸进程、孤儿进程、守护进程" class="headerlink" title="僵尸进程、孤儿进程、守护进程"></a>僵尸进程、孤儿进程、守护进程</h2><ul><li><p>僵尸进程</p><p>是 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子 进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程</p><p>fork的本质，就是复制，把当前进程复制⼀份，然后两个进程并发地执⾏for k后⾯的语句，</p></li><li><p>孤儿进程</p><p>⽗进程结束了，⽽它的⼀个或多个⼦进程还在运⾏，那么这些⼦进程就成为孤⼉进程(fat her di ed) 。⼦进程的资源由init进程( 进程号PID &#x3D; 1) 回收</p></li><li><p>守护进程</p><p>建守护进程时有意把父进程结束，然后被1号进程init收养</p><p>是运⾏在后台的⼀种特殊进程。它独⽴于控制终端并且周期性地执⾏某种任务或等待处理某些发⽣的事件</p></li></ul><p><strong>区分：</strong> 一个正常运行的子进程，如果此刻子进程退出，父进程没有及时调用wait或waitpid收回子进程 的系统资源，该进程就是僵尸进程，如果系统收回了，就是正常退出，如果一个正常运行的子进程，父 进程退出了但是子进程还在，该进程此刻是孤儿进程，被init收养，如果父进程是故意被杀掉，子进程做 相应处理后就是守护进程</p><h2 id="僵尸进程的危害"><a href="#僵尸进程的危害" class="headerlink" title="僵尸进程的危害"></a>僵尸进程的危害</h2><p>在进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留 一定的信息(包括进程号 PID，退出状态 the termination status of the process，运行时间 the amount  of CPU time taken by the process 等)。直到父进程通过 wait &#x2F; waitpid 来取时才释放。 </p><p>如果进程不调用 wait &#x2F; waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但 是系统所能使用的进程号是有限的，<strong>如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不 能产生新的进程</strong></p><h2 id="如何清理僵尸进程"><a href="#如何清理僵尸进程" class="headerlink" title="如何清理僵尸进程"></a>如何清理僵尸进程</h2><p>僵尸进程的产生是因为父进程没有 wait() 子进程。所以如果我们自己写程序的话一定要在父进程中通过  wait() 来避免僵尸进程的产生</p><p>当系统中出现了僵尸进程时，我们是无法通过 kill 命令把它清除掉的。但是我们可以杀死它的父进程， 让它变成孤儿进程，并进一步被系统中管理孤儿进程的进程收养并清理。</p><p>1.kill 杀死元凶⽗进程( ⼀般不⽤) 严格的说，僵⼫进程并不是问题的根源，罪魁祸⾸是产⽣⼤量僵死进程的⽗进程。 因此，我们可以直接除掉元凶，通过ki l l 发送SI GTERM或者SI GKI LL信号。元凶死后，僵⼫进程进程变成孤⼉进程，由i ni t充当⽗进程，并回收资源。 或者运⾏：ki l l -9 ⽗进程的pi d值</p><p>2.⽗进程⽤wai t或wai tpi d去回收资源( ⽅案不好) ⽗进程通过wai t或wai tpi d等函数去等待⼦进程结束，但是不好，会导致⽗进程⼀直等待被挂起，相当于⼀个进程在⼲活，没有起到多进程的作⽤。 </p><p>3.通过信号机制，在处理函数中调⽤wai t，回收资源 通过信号机制，⼦进程退出时向⽗进程发送SI GCHLD信号，⽗进程调⽤si gnal ( SI GCHLD, si g_chi l d) 去处理SI GCHLD信号， 在信号处理函数si g_chi l d( ) 中调⽤wai t进⾏处理僵⼫进程。什么时候得到⼦进程信号，什么时候进⾏信号处理，⽗进程可以继续⼲其他活，不⽤去阻塞等待。</p><h2 id="如何唤醒被阻塞的socket线程"><a href="#如何唤醒被阻塞的socket线程" class="headerlink" title="如何唤醒被阻塞的socket线程"></a>如何唤醒被阻塞的socket线程</h2><ul><li><p>同步阻塞</p><p>等待锁的释放</p></li><li><p>等待阻塞</p><ul><li>使用Thread.sleep造成的阻塞:时间结束后自动进入RUNNABLE状态 </li><li>使用Thread.wait造成的阻塞:使用Thread.notify或者Thread.notifyAll唤醒 </li><li>使用Thread.join造成的阻塞:等待上一个线程执行完后自动进入RUNNABLE状态 </li><li>使用Thread.suspend造成的阻塞:使用Thread.resum唤醒 </li><li>使用LockSupport.park造成的阻塞:使用LockSupport.unpark唤醒 </li><li>使用LockSupport.parkNanos造成的阻塞:指定时间结束后，自动唤醒 </li><li>使用LockSupport.parkUntil造成的阻塞:到达指定的时间，自动唤醒</li></ul></li></ul><h2 id="确定当前线程是繁忙还是阻塞"><a href="#确定当前线程是繁忙还是阻塞" class="headerlink" title="确定当前线程是繁忙还是阻塞"></a>确定当前线程是繁忙还是阻塞</h2><p>使用ps命令查看</p><h2 id="空闲和阻塞的进程会在唤醒的时候判误吗"><a href="#空闲和阻塞的进程会在唤醒的时候判误吗" class="headerlink" title="空闲和阻塞的进程会在唤醒的时候判误吗"></a>空闲和阻塞的进程会在唤醒的时候判误吗</h2><p>不会。每个进程有个进程控制块PCB，两种状态的进程分别处于两种队列。唤醒应该是找阻塞队列的进 程</p><h2 id="就绪态的进程在等待什么"><a href="#就绪态的进程在等待什么" class="headerlink" title="就绪态的进程在等待什么"></a>就绪态的进程在等待什么</h2><p>被调度使用cpu的运行权</p><h2 id="如何实现线程池"><a href="#如何实现线程池" class="headerlink" title="如何实现线程池"></a>如何实现线程池</h2><ol><li>设置一个生产者消费者队列，作为临界资源 </li><li>初始化n个线程，并让其运行起来，加锁去队列取任务运行 </li><li>当任务队列为空的时候，所有线程阻塞 </li><li>当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻 塞中的一个线程</li></ol><h2 id="fork和vfork"><a href="#fork和vfork" class="headerlink" title="fork和vfork"></a>fork和vfork</h2><p><strong>fork的基础知识：</strong></p><p>创建一个和当前进程映像一样的进程可以通过fork( )系统调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续 运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错 误，fork( )返回一个负值</strong>。 最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二 进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一 个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。 在早期的Unix系统 中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表 项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐 页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的 方法，而不是对父进程空间进程整体复制。</p><p><strong>vfork的基础知识：</strong></p><p>在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成 的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">vfork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用 所产生的结果和fork( )是一样的。vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行 文件的映像。通过这样的方式，vfork( )避免了地址空间的按页复制。在这个过程中，父进程和子 进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。 因此，子进程也就不能修改地址空间中的任何内存。 vfork( )是一个历史遗留产物，Linux本 不应该实现它。需要注意的是，即使<strong>增加了写时复制，</strong>vfork( )也要比fork( )快，因为它没有进行页 表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork(  )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可 行的。 </p><p><strong>fork和vfork的区别：</strong> </p><ol><li>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段 </li><li>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程 数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。 </li><li>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个 函数之前子进程依赖于父进程的进一步动作，则会导致死锁。  </li><li>当需要改变共享数据段中变量的值，则拷贝父进程。</li></ol><h2 id="server端监听端口，此时进程处于什么状态"><a href="#server端监听端口，此时进程处于什么状态" class="headerlink" title="server端监听端口，此时进程处于什么状态"></a>server端监听端口，此时进程处于什么状态</h2><p>最普通的Server模型，则处于阻塞状态；如果使用IO复用中epoll、select等，则处于运行状态</p><h2 id="阻塞态和挂起态"><a href="#阻塞态和挂起态" class="headerlink" title="阻塞态和挂起态"></a>阻塞态和挂起态</h2><p>线程在运⾏的过程中因为某些原因⽽发⽣阻塞，阻塞状态的线程的特点是：该线程放弃CPU的使⽤， 暂停运⾏，只有等到导致阻塞的原因消除之后才回复运⾏。或者是被其他的线程中断，该线程也会退出阻塞状态. 正在执⾏的进程由于发⽣某时间（如I &#x2F;O请求、申请缓冲区失败等）暂时⽆法继续执⾏。此时引起进程调度， OS把处理机分配给另⼀个就绪进程，⽽让受阻进程处于暂停状态，⼀般将这种状态称为阻塞状态。</p><p>挂起进程在操作系统中可以定义为暂时被淘汰出内存的进程，机器的资源是有限的，在资源不⾜的情况下， 操作系统对在内存中的程序进⾏合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存， 重新进⼊等待被执⾏的状态即就绪态</p><p>共同点： 1. 进程都暂停执⾏ 2. 进程都释放CPU，即两个过程都会涉及上下⽂切换</p><h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><h2 id="代码段、数据段、bss段、堆、栈"><a href="#代码段、数据段、bss段、堆、栈" class="headerlink" title="代码段、数据段、bss段、堆、栈"></a>代码段、数据段、bss段、堆、栈</h2><ul><li><p><strong>代码段</strong></p><p>代码段通常用来存放程序<strong>执行代码</strong>的一块区域。这部分区域的大小在程序运行前就已经确定了，通常这块内存区域属于只读，有些架构也允许可写，在代码段中也有可能包含以下只读的常数变量，例如字符串常量等。程序段为程序代码在内存中映射一个程序可以在内存中有多个副本</p></li><li><p><strong>数据段</strong></p><p>数据段通常用来存放程序中<strong>已初始化的全局变量和已初始化为非0的静态变量</strong>的一块内存区域，属于静态内存分配。直观理解就是C语言程序中的全局变量（注意：<strong>全局变量才算是程序的数据， 局部变量不算程序的数据，只能算是函数的数据</strong>）</p></li><li><p><strong>bss段</strong></p><p>bss段通常是指用来存放程序中<strong>未初始化的全局变量和未初始化的静态变量或者初始化为0的静 态变量</strong>一块区域。bss英文Block started by symbol，bss属于静态内存分配。bss段的特点就是被初始 化为0，<strong>bss段本质上也是属于数据段</strong>，bss段就是被初始化为0的数据段。 注意区分</p><p><strong>数据段（.data）和bss段的区别和联系：</strong>二者本来没有本质区别，都是用来存放C程序中的全局变量的。区别在于把显示初始化为非零的全局变量存在**.data段<strong>中，而把显式初始化为0或者并未显式 初始化（C语言规定未显式初始化的全局变量值默认为0）的全局变量存在</strong>bss段**</p></li><li><p><strong>堆</strong></p><p>堆是用来存放进程中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用 malloc等函数分配内存时，新分配的内存就被动态分配到堆上，当利用free等函数释放内存时，被释放 的内存从堆中被剔除</p></li><li><p><strong>栈</strong></p><p>栈又称堆栈，是用户存放程序临时创建的变量，也就是我们函数{}中定义的变量，但不包括static声 明的变量，static意味着在数据段中存放变量。除此之外，在函数被调用时，其参数也会被压入发起调用 的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中，由于栈的先进后出特点，所以栈 特别方便用来保存、恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存，交换临时数据的 内存区</p></li></ul><h2 id="为什么堆的空间不连续"><a href="#为什么堆的空间不连续" class="headerlink" title="为什么堆的空间不连续"></a>为什么堆的空间不连续</h2><p>堆包含一个链表来维护已用和空闲的内存块。在堆上新分配（用 new 或者 malloc）内存是从空闲的内 存块中找到一些满足要求的合适块。所以可能让人觉得只要有很多不连续的零散的小区域，只要总数达 到申请的内存块，就可以分配。</p><p>但事实上是不行的，这又让人觉得是不是零散的内存块不能连接成一个大的空间，而必须要一整块连续 的内存空间才能申请成功呢</p><p>申请和释放许多小的块可能会产生如下状态：在已用块之间存在很多小的空闲块。进而申请大块内存失 败，虽然空闲块的总和足够，但是<strong>空闲的小块是零散的，不连续的</strong>，不能满足申请的大小，这叫做“堆碎 片”</p><p>当旁边有空闲块的已用块被释放时，新的空闲块会与相连的空闲块合并成一个大的空闲块，这样就可以 有效的减少”堆碎片”的产生</p><p><strong>堆分配的空间在逻辑地址（虚拟地址）上是连续的，但在物理地址上是不连续的</strong>（因为采用了页式内存 管理,windows下有段机制、分页机制），如果逻辑地址空间上已经没有一段连续且足够大的空间，则分 配内存失败</p><h2 id="用户栈和内核栈"><a href="#用户栈和内核栈" class="headerlink" title="用户栈和内核栈"></a>用户栈和内核栈</h2><ul><li><p>内核栈、</p><p>内存中属于操作系统空间的一块区域</p><p>作用：</p><pre><code class="hljs">1. 保存中断现场，对于嵌套中断，被中断程序的现场信息一次压入系统栈，中断返回时逆序弹出2. 保存操作系统程序相互调用的参数，返回值，以及函数的局部变量</code></pre></li><li><p>用户栈</p><p>用户进程空间的一块区域，用于保存用户空间子程序间调用的参数，返回值以及局部变量。</p></li></ul><h2 id="为什么用户栈和内核栈不能共用一个栈"><a href="#为什么用户栈和内核栈不能共用一个栈" class="headerlink" title="为什么用户栈和内核栈不能共用一个栈"></a>为什么用户栈和内核栈不能共用一个栈</h2><ol><li>如果只用系统栈，系统栈一般大小有限，用户程序调用次数可能很多。如果中断有16个优先级，那 么系统栈一般大小为15（只需保存15个低优先级中断，另一个高优先级中断在运行）用户程序调用 次数很多，那样15次子程序调用以后的子程序的参数，返回值，局部变量就不能保存，用户程序也 就不能正常运行。</li><li>如果只用用户栈，系统程序需要在某种保护下运行，而用户栈在用户空间不能提供相应的保护措 施</li></ol><h2 id="线程是否有相同的堆栈"><a href="#线程是否有相同的堆栈" class="headerlink" title="线程是否有相同的堆栈"></a>线程是否有相同的堆栈</h2><p>真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。 每个线程有自己的堆栈</p><h1 id="并发和互斥"><a href="#并发和互斥" class="headerlink" title="并发和互斥"></a>并发和互斥</h1><h2 id="并发和互斥如何实现"><a href="#并发和互斥如何实现" class="headerlink" title="并发和互斥如何实现"></a>并发和互斥如何实现</h2><p>并发，指的是多个执行单元同时、并行被执行，而并发的执行单元对共享资源（硬件资源和软件上的全 局变量、静态变量等）的访问则很容易导致竞态</p><p>解决竞态问题的途径是保证对共享资源的互斥访问，所谓互斥访问就是指一个执行单元在访问共享资源 的时候，其他的执行单元都被禁止访问</p><p>访问共享资源的代码区域被称为临界区，临界区需要以某种互斥机制加以保护。中断屏蔽，原子操作， 自旋锁，和信号量都是linux设备驱动中可采用的互斥途径</p><h2 id="自旋锁、信号量"><a href="#自旋锁、信号量" class="headerlink" title="自旋锁、信号量"></a>自旋锁、信号量</h2><ul><li><p><strong>自旋锁</strong></p><p>自旋锁，顾名思义，我们可以把他理解成厕所门上的一把锁。这个厕所门只有一把钥匙，当我们进去 时，把钥匙取下来，进去后反锁。那么当第二个人想进来，必须等我们出去后才可以。当第二个人在外 面等待时，可能会一直等待在门口转圈。 </p><p>我们的自旋锁也是这样，自旋锁只有锁定和解锁两个状态。当我们进入拿上钥匙进入厕所，这就相当于 自旋锁锁定的状态，期间谁也不可以进来。当第二个人想要进来，这相当于线程B想要访问这个共享资 源，但是目前不能访问，所以线程B就一直在原地等待，一直查询是否可以访问这个共享资源。当我们 从厕所出来后，这个时候就“解锁”了，只有再这个时候线程B才能访问。 </p><p>假如，在厕所的人待的时间太长怎么办？外面的人一直等待吗？如果换做是我们，肯定不会这样，简直 浪费时间，可能我们会寻找其他方法解决问题。自旋锁也是这样的，如果线程A<strong>持有自旋锁时间过长， 显然会浪费处理器的时间，降低了系统性能</strong>。我们知道CPU最伟大的发明就在于多线程操作，这个时候 让线程B在这里傻傻的不知道还要等待多久，显然是不合理的。因此，如果<strong>自旋锁只适合短期持有</strong>，如果遇到需要长时间持有的情况，我们就要换一种方式了（互斥体）</p></li><li><p><strong>信号量</strong></p><p>信号量和自旋锁有些相似，不同的是信号量会发出一个信号告诉你还需要等多久。因此，不会出现傻傻 等待的情况。比如，有100个停车位的停车场，门口电子显示屏上实时更新的停车数量就是一个信号 量。这个停车的数量就是一个信号量，他告诉我们是否可以停车进去。当有车开进去，信号量加一，当 有车开出来，信号量减一</p><p>比如，厕所一次只能让一个人进去，当A在里面的时候，B想进去，如果是自旋锁，那么B就会一直在门 口傻傻等待。如果是信号量，A就会给B一个信号，你先回去吧，我出来了叫你。这就是一个信号量的例 子，B听到A发出的信号后，可以先回去睡觉，等待A出来</p><p>因此，信号量显然可以提高系统的执行效率，避免了许多无用功。</p></li><li><p><strong>区别</strong></p><ol><li>由于争用信号量的进程在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情 况。 </li><li>相反，锁被短时间持有时，使用信号量就不太适宜了，因为睡眠引起的耗时可能比锁被占用的全部 时间还要长。 </li><li>由于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号量锁，因为在中断上下 文中（使用自旋锁）是不能进行调度的。 </li><li>你可以在持有信号量时去睡眠（当然你也可能并不需要睡眠），因为当其它进程试图获得同一信号 量时不会因此而死锁，（因为该进程也只是去睡眠而已，而你最终会继续执行的）。 </li><li>在你占用信号量的同时不能占用自旋锁，因为在你等待信号量时可能会睡眠，而在持有自旋锁时是 不允许睡眠的</li><li>信号量锁保护的临界区可包含可能引起阻塞的代码，而自旋锁则绝对要避免用来保护包含这样代码 的临界区，因为阻塞意味着要进行进程的切换，如果进程被切换出去后，另一进程企图获取本自旋 锁，死锁就会发生。 </li><li>信号量不同于自旋锁，它不会禁止内核抢占（自旋锁被持有时，内核不能被抢占），所以持有信号 量的代码可以被抢占，这意味着信号量不会对调度的等待时间带来负面影响</li></ol></li></ul><h2 id="自旋锁和信号量可以睡眠吗"><a href="#自旋锁和信号量可以睡眠吗" class="headerlink" title="自旋锁和信号量可以睡眠吗"></a>自旋锁和信号量可以睡眠吗</h2><p>自旋锁不能睡眠，信号量可以</p><p>自旋锁自旋锁禁止处理器抢占；而信号量不禁止处理器抢占</p><p>基于这个原因，如果自旋锁在锁住以后进入睡眠，由于不能进行处理器抢占，其他系统进程将都不能获 得CPU而运行，因此不能唤醒睡眠的自旋锁，因此系统将不响应任何操作（除了中断或多核的情况，下 面会讨论）。而信号量在临界区睡眠后，其他进程可以用抢占的方式继续运行，从而可以实现内存拷贝 等功能而使得睡眠的信号量程序由于获得了等待的资源而被唤醒，从而恢复了正常的代码运行</p><p>当然，自旋锁的睡眠的情况包含考虑多核CPU和中断的因素。自旋锁睡眠时，只是当前CPU的睡眠以及 当前CPU的禁止处理器抢占，所以，如果存在多个CPU，那么其他活动的CPU可以继续运行使操作系统 功能正常，并有可能完成相应工作而唤醒睡眠了的自旋锁，从而没有造成系统死机；自旋锁睡眠时，如 果允许中断处理，那么中断的代码是可以正常运行的，但是中断通常不会唤醒睡眠的自旋锁，因此系统 仍然运行不正常</p><h2 id="自旋锁和信号量可以用于中断中吗？"><a href="#自旋锁和信号量可以用于中断中吗？" class="headerlink" title="自旋锁和信号量可以用于中断中吗？"></a>自旋锁和信号量可以用于中断中吗？</h2><p>信号量不能用于中断中，因为信号量会引起休眠，<strong>中断不能休眠</strong></p><p>自旋锁可以用于中断。在获取锁之前<strong>一定要先禁止本地中断</strong>（也就是本CPU中断，对于多核SOC来说会 有多个CPU核），否则可能导致锁死现象的发生</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>临界区的一个文件可以被<strong>同时读取</strong>，但是并不能被同时读和写。如果一个线程在读，另一个线程在 写，那么很可能会读取到错误的不完整的数据。读写自旋锁是可以<strong>允许对临界区的共享资源进行并发读操作的。但是并不允许多个线程并发读写操作</strong></p><h2 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h2><p><strong>多个并发进程因争夺系统资源而产生相互等待的现象</strong>。即：一组进程中的每个进程都在等待某个事件发 生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。</p><p>死锁: 是指多个线程因竞争资源⽽造成的⼀种僵局（互相等待）</p><p><strong>产生死锁的本质原因为：</strong></p><ol><li>系统资源有限。 </li><li>进程推进顺序不合理。</li><li>信号量使⽤不当也会造成死锁。进程间彼此相互等待对⽅发来的消息，结果也会使得这 些进程间⽆法继续向前推进。例如， 进程A等待进程B发的消息，进程B⼜在等待进程A 发的消息，可以看出进程A和B不是因为竞争同⼀资源，⽽是在等待对⽅的资源导致死锁。</li></ol><h2 id="死锁的四个必要的条件"><a href="#死锁的四个必要的条件" class="headerlink" title="死锁的四个必要的条件"></a>死锁的四个必要的条件</h2><p>产⽣死锁必须同时满⾜以下四个条件，只要其中任⼀条件不成⽴，死锁就不会发⽣。</p><ol><li><strong>互斥</strong>：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访 问，直到该进程访问结束。</li><li><strong>占有且等待</strong>：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进 程释放该资源。</li><li><strong>不可抢占</strong>：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。 </li><li><strong>循环等待</strong>：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源</li></ol><p>当以上四个条件均满足，必然会造成死锁，发生死锁的进程无法进行下去，它们所持有的资源也无 法释放。这样会导致CPU的吞吐量下降。所以死锁情况是会浪费系统资源和影响计算机的使用性能的。 那么，解决死锁问题就是相当有必要的了</p><h2 id="死锁的处理方式"><a href="#死锁的处理方式" class="headerlink" title="死锁的处理方式"></a>死锁的处理方式</h2><p>死锁的处理方式主要从预防死锁、避免死锁、检测与解除死锁这四个方面来进行处理</p><ul><li><p>预防死锁</p></li><li><p>避免死锁</p></li><li><p>检测死锁</p><p>首先为每个进程和每个资源指定一个唯一的号码；然后建立资源分配表和进程等待表</p></li><li><p>解除死锁</p></li></ul><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><ul><li>加锁顺序（线程按照一定的顺序加锁）</li><li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的 锁）</li><li>死锁检测</li></ul><h2 id="单核机器上写多线程程序是否需要加锁"><a href="#单核机器上写多线程程序是否需要加锁" class="headerlink" title="单核机器上写多线程程序是否需要加锁"></a>单核机器上写多线程程序是否需要加锁</h2><p>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机 器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时 间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某 些数据，不使用线程锁的前提下，<strong>可能会导致共享数据修改引起冲突</strong></p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="1G的计算机中可以malloc-1-2G-吗"><a href="#1G的计算机中可以malloc-1-2G-吗" class="headerlink" title="1G的计算机中可以malloc(1.2G)吗"></a>1G的计算机中可以malloc(1.2G)吗</h2><p><strong>malloc能够申请的空间大小与物理内存的大小没有直接关系，仅与程序的虚拟地址空间相关</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;     <br>      <span class="hljs-type">char</span>*p;<br>       constunsigned k= <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1.2</span>;    <br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x\n&quot;</span>,k);<br>       p= (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>( k );<br>       <span class="hljs-keyword">if</span>( p!=<span class="hljs-literal">NULL</span> )<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK&quot;</span>);<br>       <span class="hljs-keyword">else</span><br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>       return0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="malloc能申请多大的空间"><a href="#malloc能申请多大的空间" class="headerlink" title="malloc能申请多大的空间"></a>malloc能申请多大的空间</h2><p>malloc能够申请的空间到底能达到多大，还真是一个比较复杂的问题。想知道在一台机器上malloc能够 申请的最大空间到底是多少，可以使用下面的程序进行测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">unsigned</span> maximum = <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>       unsignedblocksize[] = &#123;<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">1</span>&#125;;<br>       inti, count;<br>       <span class="hljs-type">void</span>* block;<br>       <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">sizeof</span>(blocksize)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span>); i++ )<br>       &#123;     <span class="hljs-keyword">for</span>( count = <span class="hljs-number">1</span>; ;count++ )<br>              &#123;     block = <span class="hljs-built_in">malloc</span>( maximum +blocksize[i]*count );<br>                     <span class="hljs-keyword">if</span>( block!=<span class="hljs-literal">NULL</span> ) &#123;<br>                            maximum= maximum + blocksize[i]*count;<br>                            <span class="hljs-built_in">free</span>(block );<br>                     &#125;<span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                     &#125;<br>              &#125;<br>       &#125;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maximummalloc size = %u bytes\n&quot;</span>, maximum);<br>       return0;<br>&#125;<br></code></pre></td></tr></table></figure><p>在当前正在使用的Windows环境中，可申请的最大空间超过1.9G。实际上，具体的数值会受到操作系统 版本、程序本身的大小、用到的动态&#x2F;共享库数量、大小、程序栈数量、大小等的影响，甚至每次运行的 结果都可能存在差异，因为有些操作系统使用了一种叫做随机地址分布的技术，使得进程的堆空间变 小。感兴趣的读者可以去研究操作系统中的相关内容</p><h2 id="内存管理的方式"><a href="#内存管理的方式" class="headerlink" title="内存管理的方式"></a>内存管理的方式</h2><p>常见的内存管理方式有<strong>块式管理、页式管理、段式管理和段页式管理</strong>。最常用的是段页式管理。</p><ul><li><p>块式管理</p><p>把主存分为一大块一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断载入主 存，就算所需的程序片段只有几个字节，也只能把这一块分配给它。这样会造成很大的浪费，平均浪费 了50%的内存空间，但是易于管理</p></li><li><p>页式管理</p><p>用户程序的地址空间被划分成若干个固定大小的区域，这个区域被称为页”，相应地，内存空间也被划分 为若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，从而实现了离散分 配。这种方式的优点是页的大小是固定的，因此便于管理；缺点是页长与程序的逻辑大小没有任何关 系。这就导致在某个时刻一个程序可能只有一部分在主存中，而另一部分则在辅存中。这不利于编程时 的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦</p></li><li><p>段式管理</p><p>段是按照程序的自然分界划分的并且长度可以动态改变的区域。使用这种方式，程序员可以把子程序、 操作数和不同类型的数据和函数划分到不同的段中。这种方式将用户程序地址空间分成若干个大小不等 的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻 接，也实现了离散分配。</p></li></ul><blockquote><p>分页对程序员而言是不可见的，而分段通常对程序员而言是可见的，因而分段为组织程序和数据提 供了方便，但是对程序员的要求也比较高。 </p><p>分段存储主要有如下优点： </p><ol><li>段的逻辑独立性不仅使其易于编译、管理、修改和保护，也便于多道程序共享。 </li><li>段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。 </li><li>方便分段共享、分段保护、动态链接、动态增长。</li></ol><p>分段存储的缺点如下： </p><ol><li>由于段的大小不固定，因此存储管理比较麻烦。 </li><li>会生成段内碎片，这会造成存储空间利用率降低。而且段式存储管理比页式存储管理方式需 要更多的硬件支持。</li></ol><p>正是由于页式管理和段式管理都有各种各样的缺点，因此，为了把这两种存储方式的优点结合起 来，新引入了段页式管理。</p></blockquote><ul><li><p>段页式管理</p><p>段页式存储组织是分段式和分页式结合的存储组织方法，这样可充分利用分段管理和分页管理的优点。</p><ol><li>用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有 自己的段名，再把每段分成固定大小的若干页 </li><li>用分页方法来分配和管理内存，即把整个主存分成与上述页大小相等的存储块，可装入作业的任何 一页。程序对内存的调入或调出是按页进行的，但它又可按段实现共享和保护</li></ol></li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存简称虚存，是计算机系统内存管理的一种技术。它是相对于物理内存而言的，可以理解为“假 的”内存。它使得<strong>应用程序认为它拥有连续可用的内存（一个连续完整的地址空间）</strong>，允许程序员编写并 运行比实际系统拥有的内存大得多的程序，这使得许多大型软件项目能够在具有有限内存资源的系统上 实现。而实际上，它通常被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要 时进行数据交换。</p><p>相比实存，虚存有以下好处：</p><ol><li>扩大了地址空间。无论是段式虚存，还是页式虚存，或是段页式虚存，寻址空间都比实存大。 </li><li>内存保护。每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。另外，虚存还对特定的 内存地址提供写保护，可以防止代码或数据被恶意篡改。 </li><li>公平分配内存。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。 </li><li>当进程需要通信时，可采用虚存共享的方式实现不过，使用虚存也是有代价的，主要表现在以下几 个方面。<ol><li>虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</li><li>虚拟地址到物理地址的转换，增加了指令的执行时间</li><li>页面的换入换出需要磁盘IO，这是很耗时间的</li><li>如果一页中只有一部分数据，会浪费内存</li></ol></li></ol><h2 id="内存碎片、内碎片、外碎片"><a href="#内存碎片、内碎片、外碎片" class="headerlink" title="内存碎片、内碎片、外碎片"></a>内存碎片、内碎片、外碎片</h2><ul><li><p>内存碎片</p><p>是由于多次进行内存分配造成的，当进行内存分配时，内存格式一般为：（用户使用段）（空 白段）（用户使用段），当空白段很小的时候，可能不能提供给用户足够多的空间，如夹在中间的空白 段的大小为5，而用户需要的内存大小为6，这样会产生很多的间隙，造成使用效率下降，这些很小的空 隙叫碎片</p></li><li><p>内碎片</p><p>分配给程序的存储空间没有用完，有一部分是程序不使用，但其他程序也没法用的空间。内碎 片是处于区域内部或页面内部的存储块，占有这些区域或页面的进程并不使用这个存储块，而在进程占 有这块存储块时，系统无法利用它，直到进程释放它，或进程结束时，系统才有可能利用这个存储块</p></li><li><p>外碎片</p><p>空间太小，小到无法给任何程序分配（不属于任何进程）的存储空间。外部碎片是出于任何已 分配区域或页面外部的空闲存储块，这些存储块的总和可以满足当前申请的长度要求，但是它们的地址 不连续或其他原因，使得系统无法满足当前申请</p></li></ul><p>内碎片和外碎片是一对矛盾体，一种特定的内存分配算法，很难同时解决好内碎片和外碎片的问题，只 能根据应用特点进行取舍</p><h2 id="虚拟地址、逻辑地址、线性地址、物理地址"><a href="#虚拟地址、逻辑地址、线性地址、物理地址" class="headerlink" title="虚拟地址、逻辑地址、线性地址、物理地址"></a>虚拟地址、逻辑地址、线性地址、物理地址</h2><ul><li><p>虚拟地址</p><p>是指由程序产生的由段选择符和段内偏移地址组成的地址。这两部分组成的地址并没有直接访 问物理内存，而是通过分段地址的变换处理后才会对应到相应的物理内存地址</p></li><li><p>逻辑地址</p><p>由程序产生的段内偏移地址。有时直接把逻辑地址当成虚拟地址，两者并没有明确的界限</p></li><li><p>线性地址</p><p>是指<strong>虚拟地址到物理地址变换之间的中间层</strong>，是处理器可寻址的内存空间（称为线性地址空 间）中的地址。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段基址就生成了一个线 性地址。如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若没有采用分页机制，那 么线性地址就是物理地址</p></li><li><p>物理地址</p><p>指现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。虚拟地址 到物理地址的转化方法是与体系结构相关的，一般有分段与分页两种方式。以x86CPU为例，分段、分 页都是支持的。内存管理单元负责从虚拟地址到物理地址的转化。逻辑地址是段标识+段内偏移量的形 式，MMU通过査询段表，可以把逻辑地址转化为线性地址。如果CPU没有开启分页功能，那么线性地址 就是物理地址；如果CPU开启了分页功能MMU还需要查询页表来将线性地址转化为物理地址：逻辑地址 （段表）→线性地址（页表）→物理地址。</p></li></ul><p>映射是一种多对一的关系，即不同的逻辑地址可以映射到同一个线性地址上；不同的线性地址也可以映 射到同一个物理地址上。而且，同一个线性地址在发生换页以后，也可能被重新装载到另外一个物理地 址上，所以这种多对一的映射关系也会随时间发生变化</p><h2 id="虚拟内存的置换方式（？）"><a href="#虚拟内存的置换方式（？）" class="headerlink" title="虚拟内存的置换方式（？）"></a>虚拟内存的置换方式（？）</h2><h2 id="类里面有static、virtual，其内存分布"><a href="#类里面有static、virtual，其内存分布" class="headerlink" title="类里面有static、virtual，其内存分布"></a>类里面有static、virtual，其内存分布</h2><ul><li><p>static修饰符</p><ul><li><p>static修饰成员变量</p><p>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被 定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态 数据成员的值对每个对象都是一样的，它的值可以更新</p><p>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在 没有产生类对象前就可以使用</p></li><li><p>static修饰成员函数</p><p>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个 意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的 静态成员函数。static修饰的成员函数，在代码区分配内存</p></li></ul></li><li><p>C++继承和虚函数</p><p>C++多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多 态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定</p><p>动态多态实现有几个条件：</p><ul><li>虚函数</li><li>一个基类的指针或引用指向派生类的对象</li></ul><p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地 址。查找该虚函数表中该函数的指针进行调用。 </p><p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都 指向这同一个虚函数表。</p><p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承 过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该 调用哪个函数</p></li><li><p>virtual修饰符</p><p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new&#x2F;malloc动态申请的，则该类数据 存储在堆区。 </p><p>如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指 向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。 </p><p>如果类中成员是virtual属性，会隐藏父类对应的属性</p></li></ul><h2 id="假设临界区资源释放，如何保证只让一个线程获取临界区资源"><a href="#假设临界区资源释放，如何保证只让一个线程获取临界区资源" class="headerlink" title="假设临界区资源释放，如何保证只让一个线程获取临界区资源"></a>假设临界区资源释放，如何保证只让一个线程获取临界区资源</h2><p>给临界区资源加互斥锁，可以保证临界区资源释放时，只有一个线程获得临界区资源。</p><h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h2><p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应 的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常</p><p>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存 中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在 外存中找到所缺的一页，将其调入内存</p><p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p><ol><li>保护CPU现场 </li><li>分析中断原因 </li><li>转入缺页中断处理程序进行处理 </li><li>恢复CPU现场，继续执行</li></ol><p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般 的中断存在区别： </p><ol><li>在指令执行期间产生和处理缺页中断信号 </li><li>一条指令在执行期间，可能产生多次缺页中断 </li><li>缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</li></ol><h2 id="OS缺页置换算法"><a href="#OS缺页置换算法" class="headerlink" title="OS缺页置换算法"></a>OS缺页置换算法</h2><p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区， 替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：</p><p> <strong>先进先出(FIFO)算法</strong>：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存 的先后次序排列成队列，从队尾进入，从队首删除。 </p><p>最近最少使用<strong>（LRU）算法</strong>: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚 被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。当前最 常采用的就是LRU算法。</p><h2 id="系统调用和库函数"><a href="#系统调用和库函数" class="headerlink" title="系统调用和库函数"></a>系统调用和库函数</h2><ul><li><p>系统调用</p><p>系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程 与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。下面为适用于访 问设备驱动程序的系统调用</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">open:</span> 打开文件或设备 <br><span class="hljs-symbol">read:</span> 从打开的文件或设备中读取数据 <br><span class="hljs-symbol">write:</span> 向打开的文件或设备中写入数据 <br><span class="hljs-symbol">close:</span> 关闭文件或设备 <br><span class="hljs-symbol">ioctl:</span> 把控制信息传递给设备驱动文件<br></code></pre></td></tr></table></figure></li><li><p>库函数</p><p>库函数（Library function）是把函数放到库里，供别人使用的一种方式。.方法是把一些常用到的函数 编完放到一个文件里，供不同的人进行调用。一般放在.lib文件中。库函数调用则是面向应用开发的，库 函数可分为两类，一类是C语言标准规定的库函数，一类是编译器特定的库函数。</p></li></ul><p><strong>系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便</strong></p><p>库函数调用与系统无关，不同的系统，调用库函数，库函数会调用不同的底层函数实现，因此可移植性 好。</p><p>由于库函数是基于c库的，因此不能用于内核对于底层驱动设备的操作</p><p><strong>区别：</strong></p><ol><li>库函数是语言或应用程序的一部分，而系统调用是内核提供给应用程序的接口，属于系统的一部分 </li><li>库函数在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行时间属于用户时间，系 统调用属于系统时间，库函数开销较小，系统调用开销较大 </li><li>库函数是有缓冲的，系统调用是无缓冲的 </li><li>系统调用依赖于平台，库函数并不依赖</li></ol><p><img src="/2024/06/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/image-20231213192034154.png" alt="image-20231213192034154"></p><h2 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h2><p>加快从磁盘读取文件的速率。page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢， 所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。 </p><p>在Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这 些 Cache项，一个是radix tree，另一个是双向链表。Radix tree 是一种搜索树，Linux内核利用这个数 据结构来通过文件内偏移快速定位Cache 项</p><h1 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h1><h2 id="上下文有哪些"><a href="#上下文有哪些" class="headerlink" title="上下文有哪些"></a>上下文有哪些</h2><p>上下文简单说来就是一个环境</p><p>用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递 很多变量、参数 的值给内核，内核态运行的时候也要保存用户进程的一些寄存 器值、变量等。所谓的“进程上下文”，可 以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境 等。</p><p>相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进 程打开的文件、内存信息等</p><p>一个进程的上下文可以分为三个部分:<strong>用户级上下文、寄存器上下文以及系统级上下文</strong></p><ol><li>用户级上下文: 正文、数据、用户堆栈以及共享存储区； </li><li>寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)； </li><li>系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、 pte)、内核栈</li></ol><p><strong>当发生进程调度时，进行进程切换就是上下文切换(context switch).操作系统必须对上面提到的全部信 息进行切换，新调度的进程才能运行。而系统调用进行的模式切换(mode switch)。模式切换与进程切 换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换进程寄存器上下文的切 换</strong></p><p>硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的 一些变量和参数 也要传递给内核，内核通过这些参数进行中断处理。所谓的“ 中断上下文”，其实也可以看作就是硬件传 递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。中断时，内 核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一 般不会阻塞</p><h2 id="为什么会有上下文"><a href="#为什么会有上下文" class="headerlink" title="为什么会有上下文"></a>为什么会有上下文</h2><p>内核空间和用户空间是现代操作系统的两种工作模式，内核模块运行在内核空间，而用户态应用程序运 行在用户空间。它们代表不同的级别，而对系统资源具有不同的访问权限。内核模块运行在最高级别 （内核态），这个级下所有的操作都受系统信任，而应用程序运行在较低级别（用户态）。在这个级 别，处理器控制着对硬件的直接访问以及对内存的非授权访问。内核态和用户态有自己的内存映射，即 自己的地址空间。</p><p>其中，处理器总处于以下状态中的一种： </p><p>内核态，运行于进程上下文，内核代表进程运行于内核空间； </p><p>用户态，运行于用户空间。</p><p>系统的两种不同运行状态，才有了上下文的概念。用户空间的应用程序，如果想请求系统服务，比如操 作某个物理设备，映射设备的地址到用户空间，必须通过系统调用来实现。（系统调用是操作系统提供 给用户空间的接口函数）。</p><p>通过系统调用，用户空间的应用程序就会进入内核空间，由内核代表该进程运行于内核空间，这就涉及 到上下文的切换，用户空间和内核空间具有不同的 地址映射，通用或专用的寄存器组，而<strong>用户空间的进 程要传递很多变量、参数给内核，内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后 回到用户空间继续执行</strong></p><h2 id="用户态到内核态什么情况下会切换"><a href="#用户态到内核态什么情况下会切换" class="headerlink" title="用户态到内核态什么情况下会切换"></a>用户态到内核态什么情况下会切换</h2><ol><li>进程上下文主要是异常处理程序和内核线程。内核之所以进入进程上下文是因为进程自身的一些工 作需要在内核中做。例如，系统调用是为当前进程服务的，异常通常是处理进程导致的错误状态 等。 </li><li>中断上下文是由于硬件发生中断时会触发中断信号请求，请求系统处理中断，执行中断服务子程 序。</li></ol><h2 id="中断上下文代码中有哪些注意事项"><a href="#中断上下文代码中有哪些注意事项" class="headerlink" title="中断上下文代码中有哪些注意事项"></a>中断上下文代码中有哪些注意事项</h2><p>运行于进程上下文的内核代码是可抢占的，但中断上下文则会一直运行至结束，不会被抢占。所以中断 处理程序代码要受到一些限制，在中断代码中不能出现实现下面功能的代码：</p><ol><li><strong>睡眠或者放弃CPU</strong> ，因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来 执行，系统就会死掉。牢记：中断服务子程序一定不能睡眠（或者阻塞）。 </li><li><strong>尝试获得信号量</strong> ，如果获得不到信号量，代码就会睡眠，导致（1）中的结果。 </li><li><strong>执行耗时的任务</strong> ，中断处理应该尽可能快，因为如果一个处理程序是IRQF_DISABLED类型，他执行的时候会禁止所有 本地中断线，而内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。 中断处理程序的任务尽可能放在中断下半部执行</li><li><strong>访问用户空间的虚拟地址</strong> ，因为中断运行在内核空间。</li></ol><h2 id="线程需要保存哪些上下文，SP、PC、EAX寄存器的作用"><a href="#线程需要保存哪些上下文，SP、PC、EAX寄存器的作用" class="headerlink" title="线程需要保存哪些上下文，SP、PC、EAX寄存器的作用"></a>线程需要保存哪些上下文，SP、PC、EAX寄存器的作用</h2><p>线程在切换的过程中需要保存当前线程id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括 SP、PC、EAX等寄存器，其主要功能如下：</p><p>SP:堆栈指针，指向当前栈的栈顶地址 </p><p>PC:程序计数器，存储下一条将要执行的指令 </p><p>EAX:累加寄存器，用于加法乘法的缺省寄存器</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC性能检测站</title>
    <link href="/2024/06/27/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/"/>
    <url>/2024/06/27/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="1-硬件"><a href="#1-硬件" class="headerlink" title="1 硬件"></a>1 硬件</h1><h2 id="1-1-实物图"><a href="#1-1-实物图" class="headerlink" title="1.1 实物图"></a>1.1 实物图</h2><p><img src="/2024/06/27/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/image-20240301180803046.png" alt="image-20240301180803046"></p><p><img src="/2024/06/27/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/image-20240301180824622.png" alt="image-20240301180824622"></p><h2 id="1-1-原理图"><a href="#1-1-原理图" class="headerlink" title="1.1 原理图"></a>1.1 原理图</h2><p><img src="/2024/06/27/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/image-20240301175301750.png" alt="image-20240301175301750"></p><h2 id="1-2-PCB"><a href="#1-2-PCB" class="headerlink" title="1.2 PCB"></a>1.2 PCB</h2><p><img src="/2024/06/27/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/image-20240313160523991.png" alt="image-20240313160523991"></p><h1 id="2-软件"><a href="#2-软件" class="headerlink" title="2 软件"></a>2 软件</h1><h2 id="2-1-创建工程以及移植"><a href="#2-1-创建工程以及移植" class="headerlink" title="2.1 创建工程以及移植"></a>2.1 创建工程以及移植</h2><h3 id="RT-Thread-Nano-联合-CubeMX编程"><a href="#RT-Thread-Nano-联合-CubeMX编程" class="headerlink" title="RT-Thread Nano 联合 CubeMX编程"></a>RT-Thread Nano 联合 CubeMX编程</h3><ul><li>使用 RT-Thread  Studio 新建一个 RT-Thread Nano 项目，选择芯片信号</li><li>在test文件夹下，双击CubeMX Settings打开CubeMX</li><li>配置RCC、GPIO、UART、SPI、DMA、USB、USB_DEVICE(虚拟串口)等，选择工具链为Makefile，生成代码</li><li>在test文件夹下，双击RT-Thread Settings打开，选择需要用到的组件，如互斥量、信号量等</li></ul><h3 id="移植图形库u8g2"><a href="#移植图形库u8g2" class="headerlink" title="移植图形库u8g2"></a>移植图形库u8g2</h3><p>根据OLED驱动芯片、显示大小、驱动总线来选择</p><h3 id="USB虚拟串口"><a href="#USB虚拟串口" class="headerlink" title="USB虚拟串口"></a>USB虚拟串口</h3><p>通常我们使用STM32进行串口通信会选择其硬件串口，但在某些情况下串口会不够用，这个时候就可以选择USB的虚拟串口，这样可以增加一个串口。</p><h4 id="在CubeMX里面配置USB需要两个地方"><a href="#在CubeMX里面配置USB需要两个地方" class="headerlink" title="在CubeMX里面配置USB需要两个地方"></a>在CubeMX里面配置USB需要两个地方</h4><ul><li><p>一个是Connectivity下勾选USB，在Mode下勾选Device，下面的参数保持默认即可。其他芯片类型的选项可能不同，选择有Device字样的就OK。</p><p><img src="/2024/06/27/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/image-20240314160237186.png" alt="image-20240314160237186"></p></li><li><p>第二在Middleware下选择USB_DEVICE，在右边的下拉菜单选择Communication Device Class（Virtual Port Com），下面的参数设置可以保持默认，除非你了解各个参数是干什么的，否则不建议修改。这些参数涉及到了USB的设备描述符、字符串描述符、缓存等等。</p><p><img src="/2024/06/27/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/image-20240314160318465.png" alt="image-20240314160318465"></p></li></ul><h4 id="USB虚拟串口涉及的文件有下面三类："><a href="#USB虚拟串口涉及的文件有下面三类：" class="headerlink" title="USB虚拟串口涉及的文件有下面三类："></a>USB虚拟串口涉及的文件有下面三类：</h4><ul><li><p>底层</p><p><img src="/2024/06/27/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/image-20240314160459162.png" alt="image-20240314160459162"></p></li><li><p>中间层</p><p><img src="/2024/06/27/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/image-20240314160626178.png" alt="image-20240314160626178"></p></li><li><p>应用层</p><p><img src="/2024/06/27/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/image-20240314161442924.png" alt="image-20240314161442924"></p></li></ul><p>实际使用只需要关注应用层就行。&#x3D;&#x3D;在使用的时候需要安装STM32提供的虚拟串口驱动&#x3D;&#x3D;</p><p>在usb_device.c文件下实现了USB设备的初始化，只需要调用它就完成了所有的USB初始化工作</p><p>通过在main中调用这个函数，电脑就已经可以将芯片的USB识别为一个串口了</p><h2 id="2-3-开发环境"><a href="#2-3-开发环境" class="headerlink" title="2.3 开发环境"></a>2.3 开发环境</h2><ul><li>操作系统：Windows10（RT-Thread Nano + CubeMX）</li><li>文本编辑器：vscode</li><li>gcc开发环境：MinGW-64，gcc版本8.1.0，将经典的开源C语言编译器 GCC 移植到了 Windows 平台下</li><li>编译器（交叉编译工具链）：arm-none-eabi-gcc版本10.3.1</li><li>调试器：ST-link，调试口SWD</li><li>代码管理工具：git</li></ul><h2 id="2-4-源代码分析"><a href="#2-4-源代码分析" class="headerlink" title="2.4 源代码分析"></a>2.4 源代码分析</h2><h3 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h3><p><img src="/2024/06/27/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/PC%E6%80%A7%E8%83%BD%E7%9B%91%E6%B5%8B%E7%AB%99/image-20240313135721291.png" alt="image-20240313135721291"></p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-selector-tag">main</span>(void)<br>&#123;<br><span class="hljs-built_in">eeprom_init</span>();        <span class="hljs-comment">//模拟eeprom初始化</span><br><br><span class="hljs-built_in">oled_init</span>();          <span class="hljs-comment">// OLED初始化，oled刷新数据线程2</span><br><span class="hljs-built_in">DMA1_channel7_Init</span>(); <span class="hljs-comment">// DMA初始化</span><br><br><span class="hljs-built_in">MX_GPIO_Init</span>();  <span class="hljs-comment">// GPIOA12初始化</span><br><span class="hljs-built_in">rt_thread_mdelay</span>(<span class="hljs-number">500</span>);<br><span class="hljs-built_in">MX_USB_DEVICE_Init</span>();  <span class="hljs-comment">//USB初始化</span><br><br><span class="hljs-built_in">led_init</span>();  <span class="hljs-comment">//LED初始化，呼吸灯线程5</span><br><br><span class="hljs-built_in">data_decode_init</span>();   <span class="hljs-comment">//数据解码线程3、定时器线程100</span><br><br><span class="hljs-built_in">oled_show_init</span>();    <span class="hljs-comment">//gui线程20、oled线程20</span><br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="oled-c"><a href="#oled-c" class="headerlink" title="oled.c"></a>oled.c</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">oled_set_light</span>(uint8_t value) <span class="hljs-comment">//设置亮度</span><br>void <span class="hljs-built_in">oled_set_power</span>(uint8_t en)   <span class="hljs-comment">//设置是否开启显示</span><br>void <span class="hljs-built_in">oled_set_direction</span>(uint8_t direction)<span class="hljs-comment">//设置显示方向</span><br><br><span class="hljs-comment">/* OLED初始化 */</span><br>void <span class="hljs-built_in">oled_init</span>(void)<br>&#123;<br><span class="hljs-comment">/* 初始化信号量 */</span><br>    <span class="hljs-built_in">rt_sem_init</span>(&amp;sem_oled_dma_TxCplt, &quot;dmatxcplt&quot;, <span class="hljs-number">0</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-comment">/* 初始化互斥量 */</span><br>    <span class="hljs-built_in">rt_mutex_init</span>(&amp;mutex_oled_lock, &quot;oled_lock&quot;, RT_IPC_FLAG_FIFO);<br><br>    <span class="hljs-comment">/* 创建OLED线程 */</span><br>    <span class="hljs-built_in">rt_thread_init</span>(&amp;oled_send_thread, <br>                    &quot;oled_spi&quot;,<br>                    oled_send_entry,<br>                    RT_NULL,<br>                    &amp;oled_send_thread_stack[<span class="hljs-number">0</span>],<br>                    sizeof(oled_send_thread_stack),<br>                    <span class="hljs-number">2</span>,<br>                    <span class="hljs-number">20</span>);<br><br>    <span class="hljs-comment">/* 1.复位SSD1306 */</span><br>    <span class="hljs-comment">/* 2.驱动IC初始化代码：直接使用厂家推荐的设置 */</span><br>    <br>    <span class="hljs-comment">/* 开启oled进程 */</span><br>    <span class="hljs-built_in">rt_thread_startup</span>(&amp;oled_send_thread);<br>&#125;<br><br><span class="hljs-comment">// oled数据发送线程入口函数</span><br>void <span class="hljs-built_in">oled_send_entry</span>(void *parameter)<br>&#123;<br><span class="hljs-comment">/* 获取互斥量 */</span><br><span class="hljs-comment">/* 开启片选 */</span><br><br><span class="hljs-comment">/* 1.设置页地址和列地址 */</span><br><span class="hljs-comment">/* 获取信号量，等待DMA发送完毕 */</span><br><span class="hljs-comment">/* 2.将vdb[8][128]中的数据刷新到oled上显示 */</span><br><span class="hljs-comment">/* 获取信号量，等待DMA发送完毕 */</span><br><br><span class="hljs-comment">/* 关闭片选 */</span><br><span class="hljs-comment">/* 释放互斥量 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="decode-c"><a href="#decode-c" class="headerlink" title="decode.c"></a>decode.c</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/* 数据解码初始化 */</span><br>void data_decode_init()<br>&#123;<br><span class="hljs-comment">/* 初始化信号量 */</span><br>rt_sem_init(&amp;sem_usb_rx, <span class="hljs-string">&quot;sem_usb_tx&quot;</span>, <span class="hljs-number">0</span>, RT_IPC_FLAG_FIFO);<br><br><span class="hljs-comment">/* 创建数据解码线程 */</span><br>ret = rt_thread_init(&amp;data_decode_thread,<br>                         <span class="hljs-string">&quot;decode&quot;</span>,<br>                         data_decode_entry,<br>                         RT_NULL,<br>                         &amp;data_decode_thread_stack[<span class="hljs-number">0</span>],<br>                         sizeof(data_decode_thread_stack),<br>                         <span class="hljs-number">3</span>,<br>                         <span class="hljs-number">20</span>);<br>     <span class="hljs-comment">/* 开启数据解码进程 */</span>                  <br>    rt_thread_startup(&amp;data_decode_thread);                     <br>&#125;<br><br><span class="hljs-comment">//存放数据的数据框架</span><br>typedef struct<br>&#123;<br>    uint8_t head;   <span class="hljs-comment">//码头</span><br>    uint8_t func_code; <span class="hljs-comment">//功能码</span><br>    uint8_t data_len;  <span class="hljs-comment">//数据长度</span><br>    uint8_t *<span class="hljs-keyword">data</span>;   <span class="hljs-comment">//数据</span><br>    uint8_t checksum;  <span class="hljs-comment">//校验和</span><br>    uint8_t tail;<span class="hljs-comment">//码尾</span><br><br>    uint8_t data_cnt;   <span class="hljs-comment">//数据个数</span><br>    uint8_t state;<span class="hljs-comment">//状态</span><br><br>    uint16_t rec_error_cnt; <span class="hljs-comment">//超时计数</span><br>&#125; data_frame_t;<br><br><span class="hljs-comment">// 数据解码线程入口函数</span><br>void data_decode_entry(void *parameter)<br>&#123;<br>    uint8_t <span class="hljs-keyword">data</span> = <span class="hljs-number">0</span>;<br>    uint8_t data_buffer[<span class="hljs-number">150</span>];<br><br><span class="hljs-comment">/* 创建定时线程 */</span><br>    rt_timer_init(&amp;no_data_rx_timer,<br>                  <span class="hljs-string">&quot;no_data_rx&quot;</span>,<br>                  no_data_rx_timer_timeout,<br>                  (void *)&amp;data_frame, <br>                  <span class="hljs-number">100</span>,<br>                  RT_TIMER_FLAG_ONE_SHOT);<br>    <br>    <span class="hljs-comment">//初始化数据框架，设置数据内容为0，设置码头、码尾</span><br>    data_frame_init(&amp;data_frame, data_buffer, sizeof(data_buffer), <span class="hljs-number">0</span>x87, <span class="hljs-number">0</span>x16);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<span class="hljs-comment">//从usb_rxcb环形缓冲区中取出一个字节放入到data里面，返回值为0表示为空</span><br>        <span class="hljs-keyword">while</span> (rt_ringbuffer_getchar(&amp;usb_rxcb, &amp;<span class="hljs-keyword">data</span>) == <span class="hljs-number">0</span>)  <br>        &#123;<br>            rt_sem_take(&amp;sem_usb_rx, RT_WAITING_FOREVER);<br>        &#125;<br><br>        data_receive_prepare(&amp;data_frame, <span class="hljs-keyword">data</span>);<br>        rt_timer_start(&amp;no_data_rx_timer); <span class="hljs-comment">// 启动定时器，100ms未接受数据，数据帧重置</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 定时线程的入口函数 */</span><br>void no_data_rx_timer_timeout(void *parameter)<br>&#123;<br>    <span class="hljs-function"><span class="hljs-title">data_frame_reset</span>((data_frame_t *)parameter); //实际上就是让data_frame-&gt;</span>state = <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-comment">/* 对取出来的data数据处理，按照数据框架放入其中 */</span><br>void data_receive_prepare(data_frame_t *data_frame, uint8_t <span class="hljs-keyword">data</span>)<br>&#123;<br>    <span class="hljs-function"><span class="hljs-title">if</span> (data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">state</span> == 0 &amp;&amp; <span class="hljs-keyword">data</span> == data_frame-&gt;</span>head) <span class="hljs-comment">//码头</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (data_frame-&gt;</span>state == <span class="hljs-number">1</span>) <span class="hljs-comment">//功能码</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>data_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>data_cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>func_code = <span class="hljs-keyword">data</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (data_frame-&gt;</span>state == <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-keyword">data</span> &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//数据长度</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">3</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>data_len = <span class="hljs-keyword">data</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>data_cnt = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">state</span> == 3 &amp;&amp; data_frame-&gt;</span>data_len &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//数据</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[data_frame-&gt;</span>data_cnt++] = <span class="hljs-keyword">data</span>;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">data_cnt</span> == data_frame-&gt;</span>data_len)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">4</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (data_frame-&gt;</span>state == <span class="hljs-number">4</span>) <span class="hljs-comment">//数据校验码</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">5</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>checksum = <span class="hljs-keyword">data</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">state</span> == 5 &amp;&amp; <span class="hljs-keyword">data</span> == data_frame-&gt;</span>tail) <span class="hljs-comment">//码尾</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">0</span>;<br>        data_receive_anl(data_frame); <span class="hljs-comment">//接收到一帧完整的数据后，对这帧数据进项解析</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>data_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>data_cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>rec_error_cnt++;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 对一帧完整的数据data_frame进行数据解析 */</span><br>void data_receive_anl(data_frame_t *data_frame)<br>&#123;<br>    uint8_t sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-title">sum</span> += data_frame-&gt;</span>head;<br>    <span class="hljs-function"><span class="hljs-title">sum</span> += data_frame-&gt;</span>func_code;<br>    <span class="hljs-function"><span class="hljs-title">sum</span> += data_frame-&gt;</span>data_len;<br>    <span class="hljs-function"><span class="hljs-title">for</span> (uint8_t i = 0; i &lt; data_frame-&gt;</span>data_len; i++)<br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">sum</span> += *(data_frame-&gt;</span><span class="hljs-keyword">data</span> + i);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">if</span> (!(sum == data_frame-&gt;</span>checksum)) <span class="hljs-comment">//首先对这帧数据进行校验和</span><br>    &#123;<br>        return;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>xF0) <span class="hljs-comment">//根据功能码，提取不同的数据信息</span><br>    &#123;<br>    case <span class="hljs-number">0</span>x10: <span class="hljs-comment">//cpu数据信息</span><br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.cpu_data.cpu_act = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x01:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.cpu_data.cpupkg_temp = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        default:<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x20: <span class="hljs-comment">//RAM</span><br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.ram_data.mem_act = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x01:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.ram_data.mem_used = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        default:<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x30: <span class="hljs-comment">//GPU</span><br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.gpu_data.gpu_temp = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x01:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.gpu_data.gpu_act = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x02:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.gpu_data.gpu_mem_act = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x03:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.gpu_data.gpu_mem_used = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x04:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.gpu_data.gpu_mem_total = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        default:<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x40: <span class="hljs-comment">//NET</span><br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.net_data.download_rate = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x01:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.net_data.upload_rate = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        default:<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x50: <span class="hljs-comment">//others</span><br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00: <span class="hljs-comment">//0x50</span><br>            break;<br><br>        case <span class="hljs-number">0</span>x0F: <span class="hljs-comment">//频谱</span><br>            <span class="hljs-function"><span class="hljs-title">show_spectrum_data_update</span>(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        default:<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x60: <span class="hljs-comment">//接收gif</span><br>        <span class="hljs-function"><span class="hljs-title">gif_frame_write</span>(data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">func_code</span> &amp; 0x0F, data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>, data_frame-&gt;</span>data_len);<br>        break;<br><br>    case <span class="hljs-number">0</span>x70: <span class="hljs-comment">//显示</span><br>        oled_idle_mode_timer_reset();<br><br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00: <span class="hljs-comment">//0x70 性能监控</span><br>            show_pc_data_update(&amp;pc_data);<br>            oled_mode_switch(MODE_MONITOR);<br>            break;<br><br>        case <span class="hljs-number">0</span>x01: <span class="hljs-comment">//0x71 //GIF显示</span><br>            oled_mode_switch(MODE_GIF);<br>            break;<br><br>        case <span class="hljs-number">0</span>x02: <span class="hljs-comment">//0x72 //频谱</span><br>            oled_mode_switch(MODE_SPECTRUM);<br>            break;<br><br>        default:<br>            oled_mode_switch(MODE_IDLE);<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x80:<br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00:<br>            <span class="hljs-function"><span class="hljs-title">device_control</span>(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x01:<br>            device_config_send();<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x90: <span class="hljs-comment">// set logo pic</span><br>        <span class="hljs-function"><span class="hljs-title">logo_bmp_update</span>(data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">func_code</span> &amp; 0x0F, data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>, data_frame-&gt;</span>data_len);<br>        break;<br><br>    case <span class="hljs-number">0</span>xF0: <span class="hljs-comment">//上位机寻找本设备</span><br>        device_ack();<br>        break;<br><br>    default:<br>        break;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="draw-c"><a href="#draw-c" class="headerlink" title="draw.c"></a>draw.c</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs csharp">uint8_t new_mode = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 待切换至的模式  0 空闲   1 性能监视器   2 频谱  3 动画</span><br>uint8_t now_mode = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 当前的模式</span><br>uint8_t mode_switching = <span class="hljs-number">0</span>; <span class="hljs-comment">// 模式切换动画进行中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">idle_mode_enter</span>()</span>;     <span class="hljs-comment">// idle mode 的进入动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monitor_mode_enter</span>()</span>;  <span class="hljs-comment">// monitor mode 的进入动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spectrum_mode_enter</span>()</span>; <span class="hljs-comment">// spectrum mode 的进入动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gif_mode_enter</span>()</span>;      <span class="hljs-comment">// gif mode 的进入动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">idle_mode_leave</span>()</span>;     <span class="hljs-comment">// idle mode 的退出动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monitor_mode_leave</span>()</span>;  <span class="hljs-comment">// monitor mode 的退出动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spectrum_mode_leave</span>()</span>; <span class="hljs-comment">// spectrum mode 的退出动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gif_mode_leave</span>()</span>;      <span class="hljs-comment">// gif mode 的退出动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mode_switch_over_cb</span>()</span>; <span class="hljs-comment">// 模式切换完毕的回调函数</span><br><br><span class="hljs-comment">/* 显示初始化 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">oled_show_init</span>()</span><br>&#123;<br> gui_init(); <span class="hljs-comment">//有一个gui_thread线程，用于不断的去绘制gui</span><br> <br><span class="hljs-comment">//    rt_thread_init(&amp;gui_thread, //gui线程初始化</span><br><span class="hljs-comment">//                   &quot;gui&quot;,</span><br><span class="hljs-comment">//                   gui_entry,</span><br><span class="hljs-comment">//                   RT_NULL,</span><br><span class="hljs-comment">//                   &amp;gui_thread_stack[0],</span><br><span class="hljs-comment">//                   sizeof(gui_thread_stack),</span><br><span class="hljs-comment">//                   1,</span><br><span class="hljs-comment">//                   20);</span><br><span class="hljs-comment">//    rt_thread_startup(&amp;gui_thread);</span><br> <br> <br> <span class="hljs-comment">/* 初始化 */</span><br> <span class="hljs-comment">/* 1.logo */</span><br> <span class="hljs-comment">/* 2.cpu */</span><br> <span class="hljs-comment">/* 3.mem */</span><br> <span class="hljs-comment">/* 4.gpu */</span><br> <span class="hljs-comment">/* 5.nic */</span><br> <span class="hljs-comment">/* 6.频谱 */</span><br> <span class="hljs-comment">/* 7.gif显示模式 */</span><br> <br> <span class="hljs-comment">/* 创建oled绘制线程 */</span><br> ret = rt_thread_init(&amp;oled_draw_thread,<br>                         <span class="hljs-string">&quot;oled_draw&quot;</span>,<br>                         oled_draw_entry,<br>                         RT_NULL,<br>                         &amp;oled_draw_thread_stack[<span class="hljs-number">0</span>],<br>                         <span class="hljs-keyword">sizeof</span>(oled_draw_thread_stack),<br>                         <span class="hljs-number">4</span>,<br>                         <span class="hljs-number">20</span>);<br>     rt_thread_startup(&amp;oled_draw_thread);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据传输流程"><a href="#数据传输流程" class="headerlink" title="数据传输流程"></a>数据传输流程</h4><ul><li><h4 id="1-数据来源：通过RTT自带的环形缓冲区函数，将PC传过来的数据buf写入到usb-rxcb里面"><a href="#1-数据来源：通过RTT自带的环形缓冲区函数，将PC传过来的数据buf写入到usb-rxcb里面" class="headerlink" title="1.数据来源：通过RTT自带的环形缓冲区函数，将PC传过来的数据buf写入到usb_rxcb里面"></a>1.数据来源：通过RTT自带的环形缓冲区函数，将PC传过来的数据buf写入到usb_rxcb里面</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">static int8_t <span class="hljs-built_in">CDC_Receive_FS</span>(uint8_t *Buf, uint32_t *Len)<br>&#123;<br>  <span class="hljs-comment">/* USER CODE BEGIN 6 */</span><br>  <span class="hljs-built_in">USBD_CDC_SetRxBuffer</span>(&amp;hUsbDeviceFS, &amp;Buf[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">USBD_CDC_ReceivePacket</span>(&amp;hUsbDeviceFS);<br><br>  <span class="hljs-built_in">rt_ringbuffer_put</span>(&amp;usb_rxcb, Buf, *Len);     <span class="hljs-comment">/* 往环形缓冲区中写入数据 */</span><br>  <span class="hljs-built_in">rt_sem_release</span>(&amp;sem_usb_rx);<br><br>  return (USBD_OK);<br>  <span class="hljs-comment">/* USER CODE END 6 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="2-从环形缓冲区usb-rxcb中取出一个字节放入data中"><a href="#2-从环形缓冲区usb-rxcb中取出一个字节放入data中" class="headerlink" title="2.从环形缓冲区usb_rxcb中取出一个字节放入data中"></a>2.从环形缓冲区usb_rxcb中取出一个字节放入data中</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts">rt_ringbuffer_getchar(<span class="hljs-variable">&amp;usb_rxcb</span>, <span class="hljs-variable">&amp;data</span>)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure></li><li><h4 id="3-处理data-组合成一帧数据"><a href="#3-处理data-组合成一帧数据" class="headerlink" title="3.处理data,组合成一帧数据"></a>3.处理data,组合成一帧数据</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> head;<span class="hljs-comment">//码头  0X87</span><br>    <span class="hljs-type">uint8_t</span> func_code;<span class="hljs-comment">//功能码</span><br>    <span class="hljs-type">uint8_t</span> data_len;<span class="hljs-comment">//数据长度</span><br>    <span class="hljs-type">uint8_t</span> *data;<span class="hljs-comment">//数据</span><br>    <span class="hljs-type">uint8_t</span> checksum;<span class="hljs-comment">//数据校验码</span><br>    <span class="hljs-type">uint8_t</span> tail;<span class="hljs-comment">//码尾  0X16</span><br><br>    <span class="hljs-type">uint8_t</span> data_cnt;<span class="hljs-comment">//统计数据位，与data_len进行比较</span><br>    <span class="hljs-type">uint8_t</span> state;<span class="hljs-comment">//状态</span><br><br>    <span class="hljs-type">uint16_t</span> rec_error_cnt; <span class="hljs-comment">//错误码</span><br>&#125; <span class="hljs-type">data_frame_t</span>;<br><br><span class="hljs-built_in">data_receive_prepare</span>(&amp;data_frame, data);<br></code></pre></td></tr></table></figure></li><li><h4 id="4-接收完一帧数据后，先对数据进行校验，再识别不同的功能码，做出对应的处理"><a href="#4-接收完一帧数据后，先对数据进行校验，再识别不同的功能码，做出对应的处理" class="headerlink" title="4.接收完一帧数据后，先对数据进行校验，再识别不同的功能码，做出对应的处理"></a>4.接收完一帧数据后，先对数据进行校验，再识别不同的功能码，做出对应的处理</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">0</span>X10pc_data<span class="hljs-selector-class">.cpu_data</span><span class="hljs-selector-class">.cpu_act</span><br><span class="hljs-number">0</span>X11pc_data<span class="hljs-selector-class">.cpu_data</span><span class="hljs-selector-class">.cpupkg_temp</span><br><br><span class="hljs-number">0</span>X20pc_data<span class="hljs-selector-class">.ram_data</span><span class="hljs-selector-class">.mem_act</span><br><span class="hljs-number">0</span>X21pc_data<span class="hljs-selector-class">.ram_data</span><span class="hljs-selector-class">.mem_used</span><br><br><span class="hljs-number">0</span>X30pc_data<span class="hljs-selector-class">.gpu_data</span><span class="hljs-selector-class">.gpu_temp</span><br><span class="hljs-number">0</span>X31pc_data<span class="hljs-selector-class">.gpu_data</span><span class="hljs-selector-class">.gpu_act</span><br><span class="hljs-number">0</span>X32pc_data<span class="hljs-selector-class">.gpu_data</span><span class="hljs-selector-class">.gpu_mem_act</span><br><span class="hljs-number">0</span>X33pc_data<span class="hljs-selector-class">.gpu_data</span><span class="hljs-selector-class">.gpu_mem_used</span><br><span class="hljs-number">0</span>X34pc_data<span class="hljs-selector-class">.gpu_data</span><span class="hljs-selector-class">.gpu_mem_total</span><br><br><span class="hljs-number">0</span>X40pc_data<span class="hljs-selector-class">.net_data</span><span class="hljs-selector-class">.download_rate</span><br><span class="hljs-number">0</span>X41pc_data<span class="hljs-selector-class">.net_data</span><span class="hljs-selector-class">.upload_rate</span><br><br><span class="hljs-number">0</span>X50保留<br><span class="hljs-number">0</span>X5F<span class="hljs-built_in">show_spectrum_data_update</span>(data_frame-&gt;data);<br><br><span class="hljs-number">0</span>X60 <span class="hljs-built_in">gif_frame_write</span>(data_frame-&gt;func_code &amp; <span class="hljs-number">0</span>x0F, data_frame-&gt;data, data_frame-&gt;data_len);<br><br><span class="hljs-number">0</span>X70<span class="hljs-built_in">show_pc_data_update</span>(&amp;pc_data);      <span class="hljs-built_in">oled_mode_switch</span>(MODE_MONITOR);<br><span class="hljs-number">0</span>X71<span class="hljs-built_in">oled_mode_switch</span>(MODE_GIF);<br><span class="hljs-number">0</span>X72<span class="hljs-built_in">oled_mode_switch</span>(MODE_SPECTRUM);<br><span class="hljs-number">0</span>X7N<span class="hljs-built_in">oled_mode_switch</span>(MODE_IDLE);<br><br><span class="hljs-number">0</span>X80<span class="hljs-built_in">device_control</span>(data_frame-&gt;data);<br><span class="hljs-number">0</span>X81<span class="hljs-built_in">device_config_send</span>();<br><br><span class="hljs-number">0</span>X90<span class="hljs-built_in">logo_bmp_update</span>(data_frame-&gt;func_code &amp; <span class="hljs-number">0</span>x0F, data_frame-&gt;data, data_frame-&gt;data_len);<br><br><span class="hljs-number">0</span>XF0<span class="hljs-built_in">device_ack</span>();<br><br></code></pre></td></tr></table></figure></li></ul><p>24种不同的功能码  </p><h1 id="3-遇到问题"><a href="#3-遇到问题" class="headerlink" title="3 遇到问题"></a>3 遇到问题</h1><h2 id="1、更新显存到OLED的时候不成功"><a href="#1、更新显存到OLED的时候不成功" class="headerlink" title="1、更新显存到OLED的时候不成功"></a>1、更新显存到OLED的时候不成功</h2><p>因为以前用OLED的时候，是在裸机上操作的，需要更新的时候调用一次函数就行，不存在并发的问题</p><p>上了操作系统就会出现这个问题，当我线程这次更新的时候还没完成，又被别的线程抢占了，导致出现这个问题</p><p>在更新显存线程里加上互斥锁，在SPI的DMA发送函数前获取信号量，发完完后释放信号量</p><h2 id="2、使用USB虚拟串口（空闲中断-DMA）接收电脑传过来的数据时，因为接收的数据量很大，CPU来不及处理，就有一部分数据丢失掉了"><a href="#2、使用USB虚拟串口（空闲中断-DMA）接收电脑传过来的数据时，因为接收的数据量很大，CPU来不及处理，就有一部分数据丢失掉了" class="headerlink" title="2、使用USB虚拟串口（空闲中断+DMA）接收电脑传过来的数据时，因为接收的数据量很大，CPU来不及处理，就有一部分数据丢失掉了"></a>2、使用USB虚拟串口（空闲中断+DMA）接收电脑传过来的数据时，因为接收的数据量很大，CPU来不及处理，就有一部分数据丢失掉了</h2><p>加了一个环形缓冲区，接收来的数据先放入环形缓冲区里面，以后每次从环形缓冲区里面取数据，等来CPU的处理</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rttread移植</title>
    <link href="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/"/>
    <url>/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1、rtthread介绍"><a href="#1、rtthread介绍" class="headerlink" title="1、rtthread介绍"></a>1、rtthread介绍</h1><ul><li>RT-Thread 是一款完全由国内团队开发维护的嵌入式实时操作系统（RTOS），具有完全的自主知识产权。经过 16 个年头的沉淀，伴随着物联网的兴起，它正演变成一个功能强大、组件丰富的物联网操作系统。</li><li>rtthread官网提供了很多个版本，针对于不同的应用情况：标准版、nano版、smart版本。我们移植的是nano版本，是一个去除了很多第三方组件的只保留操作系统的内核基本功能：线程管理、线程间通信、时钟管理、中断管理、内存管理。</li><li>支持的CPU架构有：ARM架构下的Cortex M0&#x2F; M3&#x2F; M4&#x2F; M7 等；RISC-V架构及其他。</li><li>nano版本源码也可以保留了finsh组件，让rtthread也可以像linux那样有终端界面，通过命令行来进行相应的命令操作。</li></ul><h1 id="2、rtthread源码"><a href="#2、rtthread源码" class="headerlink" title="2、rtthread源码"></a>2、rtthread源码</h1><h2 id="2-1nano版本的源码获取"><a href="#2-1nano版本的源码获取" class="headerlink" title="2&#x2F;1nano版本的源码获取"></a>2&#x2F;1nano版本的源码获取</h2><ul><li>进入官网下载界面选择nano版本下载;<a href="https://www.rt-thread.org/download.html#download-rt-thread-nano">rt-thread.org&#x2F;download.html#download-rt-thread-nano</a></li></ul><h2 id="2-2源码目录及文件分析"><a href="#2-2源码目录及文件分析" class="headerlink" title="2&#x2F;2源码目录及文件分析"></a>2&#x2F;2源码目录及文件分析</h2><ul><li>源码目录</li></ul><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rtt%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95.png"></p><ul><li>重点rtt内核相关文件</li></ul><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rttsrc%E7%9B%AE%E5%BD%95.png"></p><ul><li><p>需要移植的文件</p><ul><li><p><strong>板级支持包和rtt配置文件：bsp文件夹下面的board.c和rtconfig.h</strong></p></li><li><p><strong>可选的第三方组件；components文件夹下面的finsh组件和device驱动框架</strong></p></li><li><p><strong>include文件夹所有内容</strong></p></li><li><p><strong>libcpu文件下对应的架构文件；这里使用的是stm32h743vit6所以要移植该文件夹下的arm-&gt;cortex-m7文件夹下面的所有内容</strong></p></li><li><p><strong>src文件夹下所有内核源码</strong></p></li></ul></li></ul><h1 id="3、具体移植细节"><a href="#3、具体移植细节" class="headerlink" title="3、具体移植细节"></a>3、具体移植细节</h1><h2 id="3-1基于gcc工程的移植"><a href="#3-1基于gcc工程的移植" class="headerlink" title="3&#x2F;1基于gcc工程的移植"></a>3&#x2F;1基于gcc工程的移植</h2><ul><li>按照如下cubemx配置一个简单的gcc工程，参考另外一篇cubemx搭建工程文章。这里主要配置一些led引脚和串口1。串口1来作为finsh组件终端通信。另外这里使用的是stm32h7系列的，我们开启数据cache和指令cache</li></ul><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/h743cache.png"></p><ul><li>stm32h743有2M的flash和1M的RAM所以堆栈可以设置大些。然后生成Makefile工程</li></ul><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/743%E5%A0%86%E6%A0%88%E8%AE%BE%E7%BD%AE.png"></p><ul><li>创建好的工程目录如下。</li></ul><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/743rtt-gcc.png"></p><ul><li>在目录中创建一个rtthread目录，然后将下载的nano源码全都拷贝过来，并且删除一些不必要的文件。</li></ul><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rtt%E5%88%A0%E9%99%A41.png"></p><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rtt%E5%88%A0%E9%99%A42.png"></p><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rtt%E5%88%A0%E9%99%A43.png"></p><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rtt%E5%88%A0%E9%99%A44.png"></p><ul><li>到上面，需要的文件都已经移植好了，然后修改工程里面的Makefile文件，将刚刚添加进来的c文件和h文件包含到编译依赖里面；用vscode打开刚刚新建的工程。修改Makefile文件内容。</li></ul><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rttmk1.png"></p><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rttmk2.png"></p><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rttmk3.png"></p><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rttmk4.png"></p><ul><li>然后屏蔽掉芯片原厂提供的中断文件中的三个中断。void HardFault_Handler(void)；void PendSV_Handler(void)；void SysTick_Handler(void)；因为rtthread内核实现了这三个函数。这三个函数一般在it.c文件里面定义的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief This function handles Hard fault interrupt.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HardFault_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">/* USER CODE BEGIN HardFault_IRQn 0 */</span><br><br>  <span class="hljs-comment">/* USER CODE END HardFault_IRQn 0 */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-comment">/* USER CODE BEGIN W1_HardFault_IRQn 0 */</span><br>    <span class="hljs-comment">/* USER CODE END W1_HardFault_IRQn 0 */</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief This function handles Pendable request for system service.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PendSV_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief This function handles System tick timer.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br>  HAL_IncTick();<br><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>gcc编译的话还要修改启动文件的入口函数，为什么要修改呢？修改启动文件；</li></ul><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rttgcc%E5%85%A5%E5%8F%A3.png"></p><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rttgcc%E5%90%AF%E5%8A%A8.png"></p><ul><li>rtthread启动流程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C">entry()-&gt;rtthread_startup()-&gt;<br>&#123;<br>    rt_hw_interrupt_disable();<br><br>    <span class="hljs-comment">/* board level initialization</span><br><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> please initialize heap inside board initialization.</span><br><span class="hljs-comment">     */</span><br>    rt_hw_board_init();-&gt;板级初始化<br><br>    <span class="hljs-comment">/* show RT-Thread version */</span><br>    rt_show_version();-&gt;这里的先实现串口打印功能<br><br>    <span class="hljs-comment">/* timer system initialization */</span><br>    rt_system_timer_init();<br><br>    <span class="hljs-comment">/* scheduler system initialization */</span><br>    rt_system_scheduler_init();<br><br>    <span class="hljs-comment">/* create init_thread */</span><br>    rt_application_init();-&gt;这个里面创建了一个线程；而这个线程的线程函数会调用main函数<br><br>    <span class="hljs-comment">/* timer thread initialization */</span><br>    rt_system_timer_thread_init();<br><br>    <span class="hljs-comment">/* idle thread initialization */</span><br>    rt_thread_idle_init();<br><br>    <span class="hljs-comment">/* start scheduler */</span><br>    rt_system_scheduler_start();-&gt;这里启动了调度器后，就会进入刚刚创建这个线程函数<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>至此rtthread的nano版本已经移植完了，可以在main函数里面创建不同的线程了；</li></ul><h2 id="3-2移植第三方finsh组件，来实现命令行交互"><a href="#3-2移植第三方finsh组件，来实现命令行交互" class="headerlink" title="3&#x2F;2移植第三方finsh组件，来实现命令行交互"></a>3&#x2F;2移植第三方finsh组件，来实现命令行交互</h2><ul><li><p>修改makefile，将rtthread&#x2F;components&#x2F;finsh里面的c文件和h文件都添加进编译文件里面。具体看上面怎么添加的，同理添加。</p></li><li><p>修改链接文件ld，在text段里面添加虚线之内的代码</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs ld">.text :<br>  &#123;<br>    . = ALIGN(4);<br>    *(.text)           /* .text sections (code) */<br>    *(.text*)          /* .text* sections (code) */<br>    *(.glue_7)         /* glue arm to thumb code */<br>    *(.glue_7t)        /* glue thumb to arm code */<br>    *(.eh_frame)<br><br>    KEEP (*(.init))<br>    KEEP (*(.fini))<br><br>    /*RT-thread GCC Add start---------------------------------*/    <br>    /* section information for finsh shell */<br>    . = ALIGN(4);<br>    __fsymtab_start = .;<br>    KEEP(*(FSymTab))<br>    __fsymtab_end = .;<br>    . = ALIGN(4);<br>    __vsymtab_start = .;<br>    KEEP(*(VSymTab))<br>    __vsymtab_end = .;<br>    . = ALIGN(4);<br><br>    /* section information for initial. */<br>    . = ALIGN(4);<br>    __rt_init_start = .;<br>    KEEP(*(SORT(.rti_fn*)))<br>    __rt_init_end = .;<br>    . = ALIGN(4);<br>    /* RT-thread GCC Add end ------------------------------------*/<br><br>    . = ALIGN(4);<br>    _etext = .;        /* define a global symbols at end of code */<br>  &#125; &gt;FLASH<br></code></pre></td></tr></table></figure><ul><li>实现两个函数，这两个函数都是弱定义的，即rtthread里面终端接收和发送函数。在finsh_port.c文件里面实现以下两个函数。具体还要包含相应的uart文件，这里使用的是串口1；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> <span class="hljs-title function_">rt_hw_console_getchar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> ch = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_RXNE) != RESET)<br>    &#123;<br><br>        ch = huart1.Instance-&gt;RDR &amp; <span class="hljs-number">0xff</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_ORE) != RESET)<br>        &#123;<br>            __HAL_UART_CLEAR_OREFLAG(&amp;huart1);<br>        &#125;<br>        rt_thread_mdelay(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ch;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_console_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-type">rt_size_t</span> i = <span class="hljs-number">0</span>, size = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;\r&#x27;</span>;<br><br>    __HAL_UNLOCK(&amp;huart1);<br><br>    size = rt_strlen(str);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (*(str + i) == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        &#123;<br>            HAL_UART_Transmit(&amp;huart1, (<span class="hljs-type">uint8_t</span> *)&amp;a, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>        HAL_UART_Transmit(&amp;huart1, (<span class="hljs-type">uint8_t</span> *)(str + i), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在配置文件rtconfig.h里面添加包含finsh组件的配置文件finsh_config.h;</li></ul><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rttfinsh1.png"></p><ul><li>屏蔽重复定义的宏，这样防止出现警告。有些在finsh_config.h里面已经宏定义过了。屏蔽掉rtconfig.h里面的相关内容。</li></ul><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rttfinsh2.png"></p><ul><li>第三方组件也移植好了，在终端make。生成hex文件，下载进cpu内。打开Mobaxterm建立一个串口通信。连接好串口，然后打开终端。复位cpu，可以在终端看到如下，表示移植成功。</li></ul><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/rttfinshxterm.png" alt=""></p><ul><li>finsh常用的内置命令如下</li></ul><p><img src="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/photo/finshcmd.png" alt=""></p><ul><li>其他kile以及IAR编译道理相同，更加简单，一样只需要添加相应c文件到工程里面，将头文件添加到IDE的搜索路径。</li></ul><h1 id="4、rtthread常用的API"><a href="#4、rtthread常用的API" class="headerlink" title="4、rtthread常用的API"></a>4、rtthread常用的API</h1><ul><li>线程管理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*线程动态创建函数*/</span><br><span class="hljs-type">rt_thread_t</span> <span class="hljs-title function_">rt_thread_create</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * name,<span class="hljs-comment">//线程的名称</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span>(*)(<span class="hljs-type">void</span> *parameter) entry,<span class="hljs-comment">//线程的入口函数</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> * parameter,<span class="hljs-comment">//入口函数的传入参数</span></span><br><span class="hljs-params">    <span class="hljs-type">rt_uint32_t</span> stack_size,<span class="hljs-comment">//线程堆栈的大小</span></span><br><span class="hljs-params">    <span class="hljs-type">rt_uint8_t</span> priority,<span class="hljs-comment">//线程的优先级</span></span><br><span class="hljs-params">    <span class="hljs-type">rt_uint32_t</span> tick <span class="hljs-comment">//线程的时间片大小。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。</span></span><br><span class="hljs-params">)</span><br>    <br><span class="hljs-comment">/*线程启动函数函数*/</span>   <br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_startup</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span><span class="hljs-comment">//参数是线程的句柄</span><br><br><span class="hljs-comment">/*线程删除函数*/</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delete</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span><br>    <br><span class="hljs-comment">/*线程挂起函数*/</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_suspend</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span><br><br><span class="hljs-comment">/*线程恢复函数*/</span>   <br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_resume</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>    <br>    <br><span class="hljs-comment">/*线程延时相关函数函数*/</span> <br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_sleep</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delay</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_mdelay</span><span class="hljs-params">(<span class="hljs-type">rt_int32_t</span> ms)</span><br></code></pre></td></tr></table></figure><ul><li>软件定时器相关函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*动态创建软件定时器*/</span><br><br><span class="hljs-type">rt_timer_t</span> <span class="hljs-title function_">rt_timer_create</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * name,<span class="hljs-comment">//定时器名称</span></span><br><span class="hljs-params"><span class="hljs-type">void</span>(*)(<span class="hljs-type">void</span> *parameter) timeout,<span class="hljs-comment">//超时回调函数</span></span><br><span class="hljs-params"><span class="hljs-type">void</span> * parameter,<span class="hljs-comment">//超时回调函数的传入参数</span></span><br><span class="hljs-params"><span class="hljs-type">rt_tick_t</span> time,<span class="hljs-comment">//定时超时时间</span></span><br><span class="hljs-params"><span class="hljs-type">rt_uint8_t</span> flag <span class="hljs-comment">//定时器的标志位</span></span><br><span class="hljs-params">)</span><br><br><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_delete</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_start</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_stop</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span><br></code></pre></td></tr></table></figure><ul><li>线程通信函数：这里有信号量、互斥量、事件、邮箱、消息队列等等。可以参考官网编程手册</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS移植</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于FreeRtos+STM32智能车载终端系统</title>
    <link href="/2023/12/05/%E5%9F%BA%E4%BA%8EFreeRtos-STM32%E6%99%BA%E8%83%BD%E8%BD%A6%E8%BD%BD%E7%BB%88%E7%AB%AF%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/12/05/%E5%9F%BA%E4%BA%8EFreeRtos-STM32%E6%99%BA%E8%83%BD%E8%BD%A6%E8%BD%BD%E7%BB%88%E7%AB%AF%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="1、项目概述"><a href="#1、项目概述" class="headerlink" title="1、项目概述"></a>1、项目概述</h1><p>​基于freertos实时操作系统加stm32完成一个智能车载终端系统。主要实现功能：车载娱乐播放、车内温湿度记录、模拟汽车启动，加速，减速；语音控制、黑匣子以及录音功能、实现人机交互，移动互联进行车内数据上云，界面设计。</p><h1 id="2、硬件目录和功能"><a href="#2、硬件目录和功能" class="headerlink" title="2、硬件目录和功能"></a>2、硬件目录和功能</h1><table><thead><tr><th align="center">器件</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">stm32f103zet6</td><td align="center">主控CPU</td></tr><tr><td align="center">VS1053模块</td><td align="center">音频解码以及录音</td></tr><tr><td align="center">DS18B20模块</td><td align="center">测量车内温度</td></tr><tr><td align="center">对射光电传感器</td><td align="center">测量车速</td></tr><tr><td align="center">AT24C64模块</td><td align="center">黑匣子存储功能</td></tr><tr><td align="center">esp8266</td><td align="center">wifi互联功能</td></tr><tr><td align="center">LD3320模块</td><td align="center">语音识别</td></tr><tr><td align="center">TFT串口屏幕</td><td align="center">车载终端界面</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32mp157启动及移植</title>
    <link href="/2023/06/16/stm32mp157%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%A7%BB%E6%A4%8D/"/>
    <url>/2023/06/16/stm32mp157%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1、stm32mp157启动方式"><a href="#1、stm32mp157启动方式" class="headerlink" title="1、stm32mp157启动方式"></a>1、stm32mp157启动方式</h1><ul><li><p>相对于MCU的启动方式，MPU的启动要复杂很多。对于MPU的芯片来说，启动方式都是大差不差，大致如下进行；看似先从启动bootloader，但是实际这个bootloader也需要运行的地方。所以大部分的芯片内部都有一小段存放厂商写好的一个裸机程序放在ROM里面，这里的ROM不是指的flash之类的。而是芯片内部的ROM，然后还有一个内部的RAM，这个不是DDR。</p></li><li><p>stm32mp1的启动方式有以下几种，根据芯片的BOOT0和BOOT1和BOOT2引脚来设置。</p><p><img src="/2023/06/16/stm32mp157%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%A7%BB%E6%A4%8D/photo/157%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F.png"></p></li><li><p>我们的代码存在EMMC上面，也就是NAND Flash上面，他是非XIP设备，不能直接运行程序。因此需要把上面的代码搬运到DDR上面来运行，可是DDR不像SRAM，不用初始化就可以使用。使用前需要初始化DDR才能使用。stm32mp157里面有128K的内部ROM地址为0x00000000<del>0x00020000和256KB的内部RAM地址为0x2FFC0000</del>0x2FFFFFFF。内部的ROM存储的代码针对不同启动方式有实现不同的功能。</p><p><img src="/2023/06/16/stm32mp157%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%A7%BB%E6%A4%8D/photo/157%E5%86%85%E9%83%A8ROM.png"></p><p><img src="/2023/06/16/stm32mp157%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%A7%BB%E6%A4%8D/photo/157%E5%86%85%E9%83%A8RAM.png"></p></li><li><p>我们选择外部FLASH启动时候，内部ROM的功能就会执行安全启动（secure boot）；安全启动很复杂，只要CPU正常运行，就会进入冷启动，然后就从flash中加载系统，并且进行鉴权，鉴权成功才会加载内核系统。</p></li><li><p>bootloader启动分成两个阶段第一阶段启动阶段FSBL和第二启动阶段SSBL阶段。上电后内部ROM在安全启动方式下。ROM代码从选定的flash里面加载的第一段代码就是FSBL镜像，这个镜像有个要求在可执行二进制文件加一段头部信息代码。ROM读取了带头部信息的FSBL镜像后，把带头部信息的镜像拷贝到内部RAM里面运行，先对头部信息进行鉴权，鉴权成功后，头部信息保存着FSBL镜像的入口地址0x2FFC2500，头部信息大小为0x100。因此带头信息的FSBL镜像会被加载到0x2FFC2400这个地址上执行。我们可以在任意裸机程序加上头部信息就可以作为FSBL镜像了。</p></li><li><p>st公司专门做了一个添加头部信息的软件，来给二进制文件加头部，让内部代码可以鉴权成功。工具叫stm32image。可以从github下载：<a href="https://github.com/ARM-software/arm-trusted-firmware/tree/master/tools/stm32image">arm-trusted-firmware&#x2F;tools&#x2F;stm32image at master · ARM-software&#x2F;arm-trusted-firmware · GitHub</a>；下载后是一个c代码，我们需要编译一下。注意这里不是使用交叉编译工具链，是使用ubunt自带的gcc工具链</p><p><img src="/2023/06/16/stm32mp157%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%A7%BB%E6%A4%8D/photo/157image.png"></p></li><li><p>在stm32mp157中启动流程是bootROM-&gt;TFA可信固件(FSBL)-&gt;uboot(SSBL)-&gt;linux-&gt;rootfs这里多出来一个TFA可信固件，主要是ARM为了针对CPU安全提出来的一种隔离方式启动，如果内部ROM鉴权失败，是不会启动后面的uboot一系列操作。</p></li><li><p>TFA源码介绍</p></li></ul><h1 id="2、SD卡移植"><a href="#2、SD卡移植" class="headerlink" title="2、SD卡移植"></a>2、SD卡移植</h1>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FAT文件系统移植</title>
    <link href="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
    <url>/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1、FAT文件系统简介"><a href="#1、FAT文件系统简介" class="headerlink" title="1、FAT文件系统简介"></a>1、FAT文件系统简介</h1><ul><li><p>FAT是一种文件格式，而FATFS是一个文件系统，为什么要文件系统呢？文件系统可以帮助我们更好的管理存储空间，另外让我们操作文件更加的简便，屏蔽掉具体实现细节，提供API函数供我们来读写，控制文件。FATFS是一个完全用C语言（ANSIC C89）编写的专为嵌入式设备设计的小型文件系统，可以很好的兼容各种硬件平台，并且支持RTOS，支持挂载最多十个存储设备。</p></li><li><p>FATFS的层次结构如下：</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/fatfs%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p></li></ul><h1 id="2、移植准备"><a href="#2、移植准备" class="headerlink" title="2、移植准备"></a>2、移植准备</h1><h2 id="2-1移植文件下载及源码介绍"><a href="#2-1移植文件下载及源码介绍" class="headerlink" title="2&#x2F;1移植文件下载及源码介绍"></a>2&#x2F;1移植文件下载及源码介绍</h2><ul><li><p>官网下载fatfs的源码；官网链接:<a href="http://elm-chan.org/fsw/ff/00index_e.html;%E5%9C%A8Resources%E9%87%8C%E9%9D%A2%E4%B8%8B%E8%BD%BD%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%9B%E5%A6%82%E5%9B%BE%EF%BC%9A">http://elm-chan.org/fsw/ff/00index_e.html;在Resources里面下载源代码；如图：</a></p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%98%E7%BD%91.png"></p></li><li><p>下载后解压源码目录如下：</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/fat%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95.png"></p></li><li><p>sourece目录下源码作用</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/fatfs%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95.png"></p></li></ul><h2 id="2-2移植具体细节修改"><a href="#2-2移植具体细节修改" class="headerlink" title="2&#x2F;2移植具体细节修改"></a>2&#x2F;2移植具体细节修改</h2><ol><li><p>修改ffconf.h文件来配置需要的功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_MKFS1 /开启定时格式化</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_FASTSEEK1 /使能快速定位</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_LABEL1 /使能磁盘名称读取和设置</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_STRFUNC1 /使能支持字符串操作</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_CODE_PAGE936 /语言设置为GBK</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_LFN3 /支持长文件名，3表示长文件名存在堆区，通过ff_memalloc来动态分配</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_VOLUMES      2 /表示支持的逻辑存储设备数，1到10之间</span><br><span class="hljs-comment">/*这些是基础配置，更多看具体文件内说明，按需裁剪*/</span><br></code></pre></td></tr></table></figure></li><li><p>修改diskio.c文件里面的具体操作函数,修改格式可以按照diskio.c里面的格式来修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">DSTATUS <span class="hljs-title function_">disk_initialize</span> <span class="hljs-params">( BYTE pdrv)</span> /pdrv是逻辑块号<br>&#123;<br>    /相关存储设备初始化函数/<br>&#125;<br>f_mount-&gt;disk_initialize<br>    <br>DSTATUS <span class="hljs-title function_">disk_status</span> <span class="hljs-params">(BYTE pdrv)</span> <br>&#123;<br>    /读取设备状态相关的函数/<br>&#125;<br><br>DRESULT <span class="hljs-title function_">disk_read</span> <span class="hljs-params">(BYTE pdrv, BYTE *buff, DWORD sector, UINT count)</span><br>&#123;<br>    /具体的存储芯片读写函数/<br>&#125;<br>f_read-&gt;disk_read<br>    <br>DRESULT <span class="hljs-title function_">disk_write</span> <span class="hljs-params">( BYTE pdrv, <span class="hljs-type">const</span> BYTE *buff, DWORD sector, UINT count)</span><br>&#123;<br>    /具体的写函数/<br>&#125;<br><br>f_write-&gt;disk_write<br><br>DRESULT <span class="hljs-title function_">disk_ioctl</span> <span class="hljs-params">(BYTE pdrv, BYTE cmd, <span class="hljs-type">void</span> *buff)</span><br>&#123;<br>    /具体的命令控制函数/<br>&#125;<br>f_ioctl-&gt;disk_ioctl<br></code></pre></td></tr></table></figure></li></ol><h1 id="3、实例操作，挂载SD卡作为文件系统"><a href="#3、实例操作，挂载SD卡作为文件系统" class="headerlink" title="3、实例操作，挂载SD卡作为文件系统"></a>3、实例操作，挂载SD卡作为文件系统</h1><h2 id="3-1用cubemx快速生成SDMMC操作SD卡工程"><a href="#3-1用cubemx快速生成SDMMC操作SD卡工程" class="headerlink" title="3&#x2F;1用cubemx快速生成SDMMC操作SD卡工程"></a>3&#x2F;1用cubemx快速生成SDMMC操作SD卡工程</h2><ul><li><p>用cubemx快速生成一个模版文件；新建一个cubemx的工程，并且选取具体的芯片型号</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/cubemx%E9%80%89%E6%8B%A9.png"></p></li><li><p>我选用的是stm32h743vit6，具体配置如下</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743%E6%97%B6%E9%92%9F%E9%80%89%E6%8B%A9.png"></p></li><li><p>时钟树配置各种外设设置</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743%E6%97%B6%E9%92%9F%E6%A0%91%E9%85%8D%E7%BD%AE.png"></p></li><li><p>配置串口一为PC通信串口，根据需求开启DMA和中断，配置波特率等等；</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE.png"></p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743%E6%B3%A2%E7%89%B9%E7%8E%87%E8%AE%BE%E7%BD%AE.png"></p></li><li><p>配置SDMMC参数</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743SDMMC%E9%85%8D%E7%BD%AE.png"></p></li><li><p>设置Project Manager。这里我是生成makefile工程</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743%E9%A1%B9%E7%9B%AE.png"></p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743%E9%A1%B9%E7%9B%AE1.png"></p></li><li><p>用vscode打开整个生成的项目文件夹</p><p>首先进行串口一重定向，来实现c标准库里面的printf函数；找到syscalls.c文件，修改里面的_io_putchar函数；如图所示：</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743%E4%B8%B2%E5%8F%A3%E9%87%8D%E5%AE%9A%E5%90%91.png"></p><p>SDMMC初始化程序在sdmmc.c文件中,我使用的是SDMMC1这个控制器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*部分代码*/</span><br>SD_HandleTypeDef hsd1;<br><span class="hljs-type">void</span> <span class="hljs-title function_">MX_SDMMC1_SD_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  hsd1.Instance = SDMMC1;<br>  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;<br>  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;<br>  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;<br>  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_ENABLE;<br>  hsd1.Init.ClockDiv = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (HAL_SD_Init(&amp;hsd1) != HAL_OK)<br>  &#123;<br>    Error_Handler();<br>  &#125;<br>&#125;<span class="hljs-comment">//SDMMC初始程序；HAL_SD_Init这个函数内部会调用HAL_SD_MspInit；因此在Msp函数内进行相关引脚初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_SD_MspInit</span><span class="hljs-params">(SD_HandleTypeDef* sdHandle)</span><br>&#123;<br>  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;<br>  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">if</span>(sdHandle-&gt;Instance==SDMMC1)<br>  &#123;<br><br>    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SDMMC;<br>    PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;<br>    <span class="hljs-keyword">if</span> (HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInitStruct) != HAL_OK)<br>    &#123;<br>      Error_Handler();<br>    &#125;<br>    __HAL_RCC_SDMMC1_CLK_ENABLE();<br>    __HAL_RCC_GPIOC_CLK_ENABLE();<br>    __HAL_RCC_GPIOD_CLK_ENABLE();<br>    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11<br>                          |GPIO_PIN_12;<br>    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;<br>    GPIO_InitStruct.Pull = GPIO_PULLUP;<br>    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<br>    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;<br>    HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);<br><br>    GPIO_InitStruct.Pin = GPIO_PIN_2;<br>    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;<br>    GPIO_InitStruct.Pull = GPIO_PULLUP;<br>    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<br>    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;<br>    HAL_GPIO_Init(GPIOD, &amp;GPIO_InitStruct);<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>HAL库提供相关SD卡操作函数；注意SD卡读写操作都是以块为单位来操作的；SD卡本质是nand flash，所以不能把数据从0写成1，只能先擦除；先擦除，再写入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//阻塞方式读取和写入函数；</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_ReadBlocks</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd, <span class="hljs-type">uint32_t</span> NumberOfBlocks,<span class="hljs-type">uint32_t</span> Timeout)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_WriteBlocks</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd,<span class="hljs-type">uint32_t</span> NumberOfBlocks, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_Erase</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">uint32_t</span> BlockStartAdd, <span class="hljs-type">uint32_t</span> BlockEndAdd)</span>;<span class="hljs-comment">//扇区擦除函数</span><br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_ReadBlocks_IT</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd,<span class="hljs-type">uint32_t</span> NumberOfBlocks)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_WriteBlocks_IT</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd,<span class="hljs-type">uint32_t</span> NumberOfBlocks)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_ReadBlocks_DMA</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd,<span class="hljs-type">uint32_t</span> NumberOfBlocks)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_WriteBlocks_DMA</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd, <span class="hljs-type">uint32_t</span> NumberOfBlocks)</span>;<br></code></pre></td></tr></table></figure></li><li><p>写个程序测试一下，先擦除SD卡块0，擦除后，先读取看一下擦除后内容是什么；再往块0里面写入0xAB;再读取看一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">SD_test</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> BlockStartAdd, <span class="hljs-type">uint32_t</span> BlockEndAdd)</span><br>&#123; <br>  <span class="hljs-type">uint32_t</span> address=<span class="hljs-number">0</span>;<br>  <span class="hljs-type">uint8_t</span> rxbuf[<span class="hljs-number">512</span>];<br>  <span class="hljs-type">uint8_t</span> txbuf[<span class="hljs-number">512</span>];<br>  <span class="hljs-built_in">memset</span>(rxbuf,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(rxbuf));<br>  <span class="hljs-built_in">memset</span>(txbuf,<span class="hljs-number">0xAB</span>,<span class="hljs-keyword">sizeof</span>(txbuf));<br>  HAL_StatusTypeDef status =HAL_SD_Erase(&amp;hsd1,BlockStartAdd,BlockEndAdd);<br>  <span class="hljs-keyword">if</span> (status == HAL_OK)<br>   &#123;<br>      <span class="hljs-keyword">while</span> (HAL_SD_GetCardState(&amp;hsd1) != HAL_SD_CARD_TRANSFER) &#123;&#125;<br>   &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;擦除完成,等待两秒开始读取数据\r\n&quot;</span>);<br>   HAL_Delay(<span class="hljs-number">2000</span>);<br>  status=ReadSDCard(address,rxbuf,<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (status == HAL_OK)<br>   &#123;<br>      <span class="hljs-keyword">while</span> (HAL_SD_GetCardState(&amp;hsd1) != HAL_SD_CARD_TRANSFER) &#123;&#125;<br>   &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">512</span>;i++)<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;擦除后扇区读到的数据为:0x%X\r\n&quot;</span>,rxbuf[i]);<br>   &#125;<br>  HAL_Delay(<span class="hljs-number">5000</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;开始向擦除扇区写入数据&quot;</span>);<br>  status=WriteSDCard(address,txbuf,<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (status == HAL_OK)<br>   &#123;<br>      <span class="hljs-keyword">while</span> (HAL_SD_GetCardState(&amp;hsd1) != HAL_SD_CARD_TRANSFER) &#123;&#125;<br>   &#125;<br>  HAL_Delay(<span class="hljs-number">2000</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写入完成,等待两秒开始读取数据\r\n&quot;</span>); <br>  status=ReadSDCard(address,rxbuf,<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (status == HAL_OK)<br>   &#123;<br>      <span class="hljs-keyword">while</span> (HAL_SD_GetCardState(&amp;hsd1) != HAL_SD_CARD_TRANSFER) &#123;&#125;<br>   &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">512</span>;i++)<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;从新写入后扇区读到的数据为:0x%X\r\n&quot;</span>,rxbuf[i]);<br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在main函数里面调用，打开串口调试助手，选择相应端口。可以看到打印信息</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743SD%E4%B8%B2%E5%8F%A3%E6%B5%8B%E8%AF%95.png"></p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743SD%E4%B8%B2%E5%8F%A3%E6%B5%8B%E8%AF%951.png"></p></li></ul><h2 id="3-2按照上述移植方法，来修改相应文件"><a href="#3-2按照上述移植方法，来修改相应文件" class="headerlink" title="3&#x2F;2按照上述移植方法，来修改相应文件"></a>3&#x2F;2按照上述移植方法，来修改相应文件</h2><ul><li><p>在cubemx来生成文件系统，按照如下配置，来增加FATfs系统。在上述SDMMC配置情况下，添加如下配置；</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743fatfs%E9%85%8D%E7%BD%AE.png"></p><p>fatfs要求有一个SD卡检测引脚，可以任选引脚作为输入，然后接地就行。</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743fat%E8%BE%93%E5%85%A5%E6%A3%80%E6%B5%8B%E5%BC%95%E8%84%9A.png"></p><p>在挂载的时候，如果出现FR_DISK_ERR这个错误，那就开启SDMMC&#x2F;SDIO的硬件流控。</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743sdmmc%E7%A1%AC%E4%BB%B6%E6%B5%81%E6%8E%A7%E5%BC%80%E5%90%AF.png"></p></li><li><p>生成代码后，修改源码，来实现上述需要的函数，打开diskio.c这个文件里面可以看到，disk_initialize、disk_status、disk_read、disk_disk_write、disk_ioctl这些函数都是调用某个结构体里面的指针数组所指向的函数；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C">DSTATUS <span class="hljs-title function_">disk_initialize</span> <span class="hljs-params">(</span><br><span class="hljs-params">BYTE pdrv<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span><br><span class="hljs-params">)</span><br>&#123;<br>  DSTATUS stat = RES_OK;<br><br>  <span class="hljs-keyword">if</span>(disk.is_initialized[pdrv] == <span class="hljs-number">0</span>)<br>  &#123;<br>    stat = disk.drv[pdrv]-&gt;disk_initialize(disk.lun[pdrv]);<br>    <span class="hljs-keyword">if</span>(stat == RES_OK)<br>    &#123;<br>      disk.is_initialized[pdrv] = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> stat;<br>&#125;<br>DSTATUS <span class="hljs-title function_">disk_status</span> <span class="hljs-params">(</span><br><span class="hljs-params">BYTE pdrv<span class="hljs-comment">/* Physical drive number to identify the drive */</span></span><br><span class="hljs-params">)</span><br>&#123;<br>  DSTATUS stat;<br><br>  stat = disk.drv[pdrv]-&gt;disk_status(disk.lun[pdrv]);<br>  <span class="hljs-keyword">return</span> stat;<br>&#125;<br>DRESULT <span class="hljs-title function_">disk_read</span> <span class="hljs-params">(</span><br><span class="hljs-params">BYTE pdrv,<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span><br><span class="hljs-params">BYTE *buff,<span class="hljs-comment">/* Data buffer to store read data */</span></span><br><span class="hljs-params">DWORD sector,        <span class="hljs-comment">/* Sector address in LBA */</span></span><br><span class="hljs-params">UINT count<span class="hljs-comment">/* Number of sectors to read */</span></span><br><span class="hljs-params">)</span><br>&#123;<br>  DRESULT res;<br><br>  res = disk.drv[pdrv]-&gt;disk_read(disk.lun[pdrv], buff, sector, count);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br>......等等函数<br></code></pre></td></tr></table></figure></li><li><p>从上面可以看到都是调用disk这个结构体里面的drv指针数组所指向的函数。disk结构体在ff_gen_drv.h这个文件下定义的；disk里面的drv结构体就是我们要实现的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">uint8_t</span>                 is_initialized[_VOLUMES];<span class="hljs-comment">//记录每个磁盘是否被初始化过</span><br>  <span class="hljs-type">const</span> Diskio_drvTypeDef *drv[_VOLUMES];<span class="hljs-comment">//指针数组，指向每个磁盘的操作函数</span><br>  <span class="hljs-type">uint8_t</span>                 lun[_VOLUMES];<span class="hljs-comment">//记录磁盘号</span><br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>        nbr;<br><br>&#125;Disk_drvTypeDef;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  DSTATUS (*disk_initialize) (BYTE);                     <span class="hljs-comment">/*!&lt; Initialize Disk Drive                     */</span><br>  DSTATUS (*disk_status)     (BYTE);                     <span class="hljs-comment">/*!&lt; Get Disk Status                           */</span><br>  DRESULT (*disk_read)       (BYTE, BYTE*, DWORD, UINT);       <span class="hljs-comment">/*!&lt; Read Sector(s)                            */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _USE_WRITE == 1</span><br>  DRESULT (*disk_write)      (BYTE, <span class="hljs-type">const</span> BYTE*, DWORD, UINT); <span class="hljs-comment">/*!&lt; Write Sector(s) when _USE_WRITE = 0       */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _USE_WRITE == 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _USE_IOCTL == 1</span><br>  DRESULT (*disk_ioctl)      (BYTE, BYTE, <span class="hljs-type">void</span>*);              <span class="hljs-comment">/*!&lt; I/O control operation when _USE_IOCTL = 1 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _USE_IOCTL == 1 */</span></span><br><br>&#125;Diskio_drvTypeDef;<br></code></pre></td></tr></table></figure></li><li><p>新建一个.c文件来实现这些函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> Diskio_drvTypeDef  SD_Driver =<br>&#123;<br>  SD_initialize,<br>  SD_status,<br>  SD_read,<br><span class="hljs-meta">#<span class="hljs-keyword">if</span>  _USE_WRITE == 1</span><br>  SD_write,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _USE_WRITE == 1 */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span>  _USE_IOCTL == 1</span><br>  SD_ioctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _USE_IOCTL == 1 */</span></span><br>&#125;;<br><span class="hljs-comment">//下面就是具体函数</span><br>DSTATUS <span class="hljs-title function_">SD_initialize</span><span class="hljs-params">(BYTE lun)</span><br>&#123;<br>Stat = STA_NOINIT;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(DISABLE_SD_INIT)</span><br><br>  <span class="hljs-keyword">if</span>(BSP_SD_Init() == MSD_OK)<br>  &#123;<br>    Stat = SD_CheckStatus(lun);<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  Stat = SD_CheckStatus(lun);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">return</span> Stat;<br>&#125;<br><br>DSTATUS <span class="hljs-title function_">SD_status</span><span class="hljs-params">(BYTE lun)</span><br>&#123;<br>  <span class="hljs-keyword">return</span> SD_CheckStatus(lun);<br>&#125;<br><br>DRESULT <span class="hljs-title function_">SD_read</span><span class="hljs-params">(BYTE lun, BYTE *buff, DWORD sector, UINT count)</span><br>&#123;<br>  DRESULT res = RES_ERROR;<br><br>  <span class="hljs-keyword">if</span>(BSP_SD_ReadBlocks((<span class="hljs-type">uint32_t</span>*)buff,<br>                       (<span class="hljs-type">uint32_t</span>) (sector),<br>                       count, SD_TIMEOUT) == MSD_OK)<br>  &#123;<br>    <span class="hljs-comment">/* wait until the read operation is finished */</span><br>    <span class="hljs-keyword">while</span>(BSP_SD_GetCardState()!= MSD_OK)<br>    &#123;<br>    &#125;<br>    res = RES_OK;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>DRESULT <span class="hljs-title function_">SD_write</span><span class="hljs-params">(BYTE lun, <span class="hljs-type">const</span> BYTE *buff, DWORD sector, UINT count)</span><br>&#123;<br>  DRESULT res = RES_ERROR;<br><br>  <span class="hljs-keyword">if</span>(BSP_SD_WriteBlocks((<span class="hljs-type">uint32_t</span>*)buff,<br>                        (<span class="hljs-type">uint32_t</span>)(sector),<br>                        count, SD_TIMEOUT) == MSD_OK)<br>  &#123;<br><span class="hljs-comment">/* wait until the Write operation is finished */</span><br>    <span class="hljs-keyword">while</span>(BSP_SD_GetCardState() != MSD_OK)<br>    &#123;<br>    &#125;<br>    res = RES_OK;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>DRESULT <span class="hljs-title function_">SD_ioctl</span><span class="hljs-params">(BYTE lun, BYTE cmd, <span class="hljs-type">void</span> *buff)</span><br>&#123;<br>  DRESULT res = RES_ERROR;<br>  BSP_SD_CardInfo CardInfo;<br><br>  <span class="hljs-keyword">if</span> (Stat &amp; STA_NOINIT) <span class="hljs-keyword">return</span> RES_NOTRDY;<br><br>  <span class="hljs-keyword">switch</span> (cmd)<br>  &#123;<br>  <span class="hljs-comment">/* Make sure that no pending write process */</span><br>  <span class="hljs-keyword">case</span> CTRL_SYNC :<br>    res = RES_OK;<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-comment">/* Get number of sectors on the disk (DWORD) */</span><br>  <span class="hljs-keyword">case</span> GET_SECTOR_COUNT :<br>    BSP_SD_GetCardInfo(&amp;CardInfo);<br>    *(DWORD*)buff = CardInfo.LogBlockNbr;<br>    res = RES_OK;<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-comment">/* Get R/W sector size (WORD) */</span><br>  <span class="hljs-keyword">case</span> GET_SECTOR_SIZE :<br>    BSP_SD_GetCardInfo(&amp;CardInfo);<br>    *(WORD*)buff = CardInfo.LogBlockSize;<br>    res = RES_OK;<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-comment">/* Get erase block size in unit of sector (DWORD) */</span><br>  <span class="hljs-keyword">case</span> GET_BLOCK_SIZE :<br>    BSP_SD_GetCardInfo(&amp;CardInfo);<br>    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;<br>    res = RES_OK;<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-keyword">default</span>:<br>    res = RES_PARERR;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>到这里可能有个疑问，FATfs调用的是disk这个结构体里面drv的函数，他怎么知道要调用哪个具体的drv指针呢。虽然我们定义了drv这个函数指针结构体，但是我们没有链接。fatfs中是如何连接呢，调用如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_FATFS_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">/*## FatFS: Link the SD driver ###########################*/</span><br>  retSD = FATFS_LinkDriver(&amp;SD_Driver, SDPath);<br>&#125;<br><span class="hljs-comment">//这个就是fatfs初始化的时候，将我们上述实现的drv结构体和磁盘号都连接到fatfs定义的disk这个结构体内了。</span><br></code></pre></td></tr></table></figure></li><li><p>到这里FATFS已经完全移植完了。我们可以另外添加各种存储设备，spi flash、emmc、USB虚拟存储设备等等都可以，只需要定义多个Diskio_drvTypeDef结构体，并且链接到系统调用的disk结构体中。</p></li></ul><h2 id="3-3测试一下移植的是否成功"><a href="#3-3测试一下移植的是否成功" class="headerlink" title="3&#x2F;3测试一下移植的是否成功"></a>3&#x2F;3测试一下移植的是否成功</h2><ul><li><p>在mian函数之前写好测试函数，并且设置好串口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C">FRESULT fres; <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FatFs_Test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>    UINT bytes_written, bytes_read;<br><br><br>    fres = f_mount(&amp;SDFatFS, SDPath, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to mount filesystem: %d\n&quot;</span>, fres);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件系统挂载成功！\r\n&quot;</span>);<br><br><br>    fres = f_open(&amp;SDFile, <span class="hljs-string">&quot;test.txt&quot;</span>, FA_CREATE_ALWAYS | FA_WRITE);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to open file: %d\n&quot;</span>, fres);<br>        f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;创建test.txt文件成功\n&quot;</span>);<br><br><br>    <span class="hljs-built_in">strcpy</span>(buffer, <span class="hljs-string">&quot;Hello, STM32H743vit6!&quot;</span>);<br>    fres = f_write(&amp;SDFile, buffer, <span class="hljs-built_in">strlen</span>(buffer), &amp;bytes_written);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK || bytes_written == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to write to file: %d\n&quot;</span>, fres);<br>        f_close(&amp;SDFile);<br>        f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写入文件成功\n&quot;</span>);<br><br><br>    f_close(&amp;SDFile);<br><br><br>    fres = f_open(&amp;SDFile, <span class="hljs-string">&quot;test.txt&quot;</span>, FA_READ);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to open file for reading: %d\n&quot;</span>, fres);<br>        f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开test.txt文件成功\n&quot;</span>);<br><br> <br>    fres = f_read(&amp;SDFile, buffer, <span class="hljs-keyword">sizeof</span>(buffer) - <span class="hljs-number">1</span>, &amp;bytes_read);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK || bytes_read == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to read from file: %d\n&quot;</span>, fres);<br>        f_close(&amp;SDFile);<br>        f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    buffer[bytes_read] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件里面的数据为: %s\n&quot;</span>, buffer);<br><br> <br>    f_close(&amp;SDFile);<br><br><br>    f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;取消挂载文件系统成功\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在main函数内调用，打开串口可以看到，然后make编译程序。如下：</p><p><img src="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/photo/743fat%E4%B8%B2%E5%8F%A3%E6%B5%8B%E8%AF%95.png"></p></li><li><p>另外注意，如果使用了操作系统，则在应该在任务之外挂载文件系统。不然可能会导致，任务结束后，文件系统会丢失。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS总结</title>
    <link href="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1、FreeRTOS简介"><a href="#1、FreeRTOS简介" class="headerlink" title="1、FreeRTOS简介"></a>1、FreeRTOS简介</h1><h2 id="1-1嵌入式操作系统简介"><a href="#1-1嵌入式操作系统简介" class="headerlink" title="1&#x2F;1嵌入式操作系统简介"></a>1&#x2F;1嵌入式操作系统简介</h2><ul><li>操作系统是允许多个任务“同时运行”的，操作系统的这个特性被称为多任务。然而实际 上，一个 CPU 核心在某一时刻只能运行一个任务，而操作系统中任务调度器的责任就是决定在 某一时刻 CPU 究竟要运行哪一个任务，任务调度器使得 CPU 在各个任务之间来回切换并处理 任务，由于切换处理任务的速度非常快，因此就给人造成了一种同一时刻有多个任务同时运行 的错觉。</li></ul><h2 id="1-2为什么要引入FreeRTOS"><a href="#1-2为什么要引入FreeRTOS" class="headerlink" title="1&#x2F;2为什么要引入FreeRTOS"></a>1&#x2F;2为什么要引入FreeRTOS</h2><ul><li>FreeRTOS是嵌入式实时操作系统的一种，但是它具备的优点：可移植性强、可裁剪、支持多种任务通讯、同步机制、高效的软件定时器、任务数量、优先级数量不限、运行效率高、支持抢占式、合作式调度、开源、免费、可商用。功能强大，技术成熟的实时操作系统。引入实时操作系统后，可以同步处理多个任务，让CPU执行效率更高。不像裸机结构，针对某个任务需要不断查询，造成CPU资源浪费。</li></ul><h2 id="1-3如何获取FreeRTOS"><a href="#1-3如何获取FreeRTOS" class="headerlink" title="1&#x2F;3如何获取FreeRTOS"></a>1&#x2F;3如何获取FreeRTOS</h2><ul><li>FreeRTOS是用C语言编写的一个操作系统，可以在官网获取到源码。<a href="https://www.freertos.org/zh-cn-cmn-s/">FreeRTOS官网链接</a></li></ul><p>进入官网后点击下载，即可获取最新的FreeRTOS的源码，如图所示：</p><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/%E5%AE%98%E7%BD%91%E5%9B%BE.png"></p><h2 id="1-2FreeRTOS源码目录及其介绍"><a href="#1-2FreeRTOS源码目录及其介绍" class="headerlink" title="1&#x2F;2FreeRTOS源码目录及其介绍"></a>1&#x2F;2FreeRTOS源码目录及其介绍</h2><ul><li>下载解压后，如图所示 ：</li></ul><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/%E6%BA%90%E7%A0%81.png"></p><ul><li><p>源码目录内容介绍：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs DTS">├─FreeRTOS<br>│  ├─Demo<span class="hljs-comment">// 各种开发工具的完整Demo，开发者可以方便的以此搭建出自己的项目，甚至直接使用</span><br>│  │  ├─Common<span class="hljs-comment">// 所有例程都可以使用的演示例程文件</span><br>│  │  └─其他<span class="hljs-comment">// 对应平台和开发工具的项目例程（命名：平台_开发工具，例如：CORTEX_M4F_M0_LPC43xx_Keil）</span><br>│  ├─License<span class="hljs-comment">// 使用修改过的 GPL</span><br>│  └─Source<span class="hljs-comment">// FreeRTOS的源码</span><br>│      ├─include<span class="hljs-comment">// 源码对应的头文件</span><br>│      └─portable<span class="hljs-comment">// 每个支持的处理器架构需要一小段与处理器架构相关的RTOS代码。该目录下即为和开发平台相关的代码</span><br>│            ├─MemMang<span class="hljs-comment">// FreeRTOS内存管理方案（一般要根据平台来选择以下5个之一）</span><br>│            │     heap_1.c<br>│            │     heap_2.c<br>│            │     heap_3.c<br>│            │     heap_4.c<br>│            │     heap_5.c<br>│            └─其他<span class="hljs-comment">// 其他开发工具相关的代码，需要根据自己的开发工具进行选择</span><br>│      croutine.c<span class="hljs-comment">// 协线程（协程）文件，和任务类似，在系统资源比较缺乏下使用</span><br>│      event_groups.c<span class="hljs-comment">// 事件标志组</span><br>│      list.c<span class="hljs-comment">// 列表结构描述，在内核整体控制上都使用了列表格式数据处理,一切数据结构的基础</span><br>│      queue.c<span class="hljs-comment">// 队列，任务和任务之间的通讯处理</span><br>│      tasks.c<span class="hljs-comment">// 所有任务相关函数</span><br>│      timers.c<span class="hljs-comment">// 软件定时器，以任务形式存在</span><br>|      stream_buffer.c<span class="hljs-comment">// 10.0.0 新增</span><br>└─FreeRTOS-Plus<span class="hljs-comment">// FreeRTOS+组件和演示例程</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="2、FreeRTOS移植"><a href="#2、FreeRTOS移植" class="headerlink" title="2、FreeRTOS移植"></a>2、FreeRTOS移植</h1><h2 id="2-1源码具体分类"><a href="#2-1源码具体分类" class="headerlink" title="2&#x2F;1源码具体分类"></a>2&#x2F;1源码具体分类</h2><ul><li><p><strong>操作系统内核核心文件</strong>：内核的核心文件，包括任务管理、调度算法、消息通知…等等重要文件</p><ul><li><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/freertos%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></li></ul></li><li><p><strong>硬件架构相关的文件</strong>：这个里面的内容都是与具体处理器架构相关的文件，根据不同的架构选择不同的文件，如图所示，这个里面的文件是操作系统跟硬件架构相适配，保证系统正常运行</p><ul><li><p>例如ARM架构下的cortex-m3和cortex-m4架构的文件如图</p><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/freertos%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></p></li></ul></li><li><p><strong>内存管理算法文件，以及配置文件</strong>；FreeRTOS提供了5种内存管理算法。为了方便裁剪系统，官方DEMO文件中定义了一个FreeRTOSConfig.h的头文件，里面都是一些宏开关，可以根据需求，来裁剪系统，使不需要的配置不被编译进目标文件。</p><ul><li><p>内存管理文件如图</p><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/freertos%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></p></li><li><p>配置文件模板：这个配置文件，没有固定的文件，官方只是在示例中给出一些模板，用户可以根据这个模板来自己修改内容，另外可以模仿直接从写一份；如图所示</p><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/freertos%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></p></li></ul></li></ul><h2 id="2-2基于CORTEX-M3-M4系列的移植"><a href="#2-2基于CORTEX-M3-M4系列的移植" class="headerlink" title="2&#x2F;2基于CORTEX-M3&#x2F;M4系列的移植"></a>2&#x2F;2基于CORTEX-M3&#x2F;M4系列的移植</h2><ul><li><p>移植前需要稍微了解一下这两个架构异常和中断类型；</p><ul><li><p>如图就是cm3的异常表</p><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/cm4%E5%BC%82%E5%B8%B8%E8%A1%A8.png"></p></li><li><p>这里我们主要关注这三个异常</p><ul><li><p>SYSTICK异常：cortex-m系列的产品里面的系统滴答定时器产生的异常，在freertos中使用滴答定时器作为系统的心跳，以此来实现时间片轮转的调度功能；每当时间片（就是滴答定时器计数到了）到了，调用相应的中断服务函数来检查是否需要切换任务。在freertos的port.c中定义了相应的中断服务函数，如图；</p><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/systick%E5%87%BD%E6%95%B0.png"></p></li><li><p>PendSV异常：根据上述，SYSTICK这个异常只是检查是否要进行任务切换，真正要实现任务切换的是触发PendSV异常，在freertos的port.c中定义了相应的中断服务函数，如图；</p><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/pendsv%E5%87%BD%E6%95%B0.png"></p></li><li><p>SVC异常：这个异常在freertos中一般只会使用一次，它也是用来进行任务调度的，但是只在vTaskStartScheduler(void)这个函数里面调用一次，在freertos中定义了相关的中断服务函数。这个函数调用流程为（vTaskStartScheduler( void )-&gt;xPortStartScheduler( void )-&gt;prvPortStartFirstTask(void)在这个函数里面会触发svc异常）</p><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/svc%E5%87%BD%E6%95%B0.png"></p></li></ul></li></ul></li><li><p>修改启动文件，启动文件里面定义了中断服务函数的名称，需要用freertos中的这三个函数名替换掉三个函数</p><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6.png"></p></li><li><p>注释掉HAL库下的中断服务函数：stm32fxxx_it.c文件里面注释掉这三个函数。</p></li><li><p>最后就是将上述操作系统内核核心文件、架构文件、配置文件的c文件加入到项目内，然后添加相应的头文件路径。到这里基本上freertos移植完成了。剩下一些裁剪功能，配置等等在相应的配置文件来处理。</p></li></ul><h2 id="2-3配置文件以及内存管理算法细节"><a href="#2-3配置文件以及内存管理算法细节" class="headerlink" title="2&#x2F;3配置文件以及内存管理算法细节"></a>2&#x2F;3配置文件以及内存管理算法细节</h2><ul><li><p>配置文件主要是对FreeRTOS.h这个头文件的内容进行一些裁剪，并且里面有些如果不定义就会报错；如图必须需要定义的；其他具体的配置内容可以参考FreeRTOS.h这个头文件来进行裁剪和进行配置</p><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/freertos%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89.png"></p></li><li><p>FreeRTOSConfig.h模板如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FREERTOS_CONFIG_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FREERTOS_CONFIG_H</span><br><br><span class="hljs-comment">/* 头文件 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> SystemCoreClock;<br><br><span class="hljs-comment">/* 基础配置项 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_PREEMPTION                            1                       <span class="hljs-comment">/* 1: 抢占式调度器, 0: 协程式调度器, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION         1                       <span class="hljs-comment">/* 1: 使用硬件计算下一个要运行的任务, 0: 使用软件算法计算下一个要运行的任务, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TICKLESS_IDLE                         0                       <span class="hljs-comment">/* 1: 使能tickless低功耗模式, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configCPU_CLOCK_HZ                              SystemCoreClock         <span class="hljs-comment">/* 定义CPU主频, 单位: Hz, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSYSTICK_CLOCK_HZ                          (configCPU_CLOCK_HZ / 8)<span class="hljs-comment">/* 定义SysTick时钟频率，当SysTick时钟频率与内核时钟频率不同时才可以定义, 单位: Hz, 默认: 不定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTICK_RATE_HZ                              1000                    <span class="hljs-comment">/* 定义系统时钟节拍频率, 单位: Hz, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_PRIORITIES                            32                      <span class="hljs-comment">/* 定义最大优先级数, 最大优先级=configMAX_PRIORITIES-1, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMINIMAL_STACK_SIZE                        128                     <span class="hljs-comment">/* 定义空闲任务的栈空间大小, 单位: Word, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_TASK_NAME_LEN                         16                      <span class="hljs-comment">/* 定义任务名最大字符数, 默认: 16 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_16_BIT_TICKS                          0                       <span class="hljs-comment">/* 1: 定义系统时钟节拍计数器的数据类型为16位无符号数, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configIDLE_SHOULD_YIELD                         1                       <span class="hljs-comment">/* 1: 使能在抢占式调度下,同优先级的任务能抢占空闲任务, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TASK_NOTIFICATIONS                    1                       <span class="hljs-comment">/* 1: 使能任务间直接的消息传递,包括信号量、事件标志组和消息邮箱, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTASK_NOTIFICATION_ARRAY_ENTRIES           1                       <span class="hljs-comment">/* 定义任务通知数组的大小, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_MUTEXES                               1                       <span class="hljs-comment">/* 1: 使能互斥信号量, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_RECURSIVE_MUTEXES                     1                       <span class="hljs-comment">/* 1: 使能递归互斥信号量, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_COUNTING_SEMAPHORES                   1                       <span class="hljs-comment">/* 1: 使能计数信号量, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_ALTERNATIVE_API                       0                       <span class="hljs-comment">/* 已弃用!!! */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configQUEUE_REGISTRY_SIZE                       8                       <span class="hljs-comment">/* 定义可以注册的信号量和消息队列的个数, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_QUEUE_SETS                            1                       <span class="hljs-comment">/* 1: 使能队列集, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TIME_SLICING                          1                       <span class="hljs-comment">/* 1: 使能时间片调度, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_NEWLIB_REENTRANT                      0                       <span class="hljs-comment">/* 1: 任务创建时分配Newlib的重入结构体, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configENABLE_BACKWARD_COMPATIBILITY             0                       <span class="hljs-comment">/* 1: 使能兼容老版本, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configNUM_THREAD_LOCAL_STORAGE_POINTERS         0                       <span class="hljs-comment">/* 定义线程本地存储指针的个数, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSTACK_DEPTH_TYPE                          uint16_t                <span class="hljs-comment">/* 定义任务堆栈深度的数据类型, 默认: uint16_t */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMESSAGE_BUFFER_LENGTH_TYPE                size_t                  <span class="hljs-comment">/* 定义消息缓冲区中消息长度的数据类型, 默认: size_t */</span></span><br><br><span class="hljs-comment">/* 内存分配相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSUPPORT_STATIC_ALLOCATION                 0                       <span class="hljs-comment">/* 1: 支持静态申请内存, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION                1                       <span class="hljs-comment">/* 1: 支持动态申请内存, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTOTAL_HEAP_SIZE                           ((size_t)(10 * 1024))   <span class="hljs-comment">/* FreeRTOS堆中可用的RAM总量, 单位: Byte, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configAPPLICATION_ALLOCATED_HEAP                0                       <span class="hljs-comment">/* 1: 用户手动分配FreeRTOS内存堆(ucHeap), 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSTACK_ALLOCATION_FROM_SEPARATE_HEAP       0                       <span class="hljs-comment">/* 1: 用户自行实现任务创建时使用的内存申请与释放函数, 默认: 0 */</span></span><br><br><span class="hljs-comment">/* 钩子函数相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_IDLE_HOOK                             0                       <span class="hljs-comment">/* 1: 使能空闲任务钩子函数, 无默认需定义  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TICK_HOOK                             0                       <span class="hljs-comment">/* 1: 使能系统时钟节拍中断钩子函数, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configCHECK_FOR_STACK_OVERFLOW                  0                       <span class="hljs-comment">/* 1: 使能栈溢出检测方法1, 2: 使能栈溢出检测方法2, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_MALLOC_FAILED_HOOK                    0                       <span class="hljs-comment">/* 1: 使能动态内存申请失败钩子函数, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_DAEMON_TASK_STARTUP_HOOK              0                       <span class="hljs-comment">/* 1: 使能定时器服务任务首次执行前的钩子函数, 默认: 0 */</span></span><br><br><span class="hljs-comment">/* 运行时间和任务状态统计相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configGENERATE_RUN_TIME_STATS                   0                       <span class="hljs-comment">/* 1: 使能任务运行时间统计功能, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> configGENERATE_RUN_TIME_STATS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/TIMER/btim.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()        ConfigureTimeForRunTimeStats()</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> FreeRTOSRunTimeTicks;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portGET_RUN_TIME_COUNTER_VALUE()                FreeRTOSRunTimeTicks</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TRACE_FACILITY                        1                       <span class="hljs-comment">/* 1: 使能可视化跟踪调试, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS            1                       <span class="hljs-comment">/* 1: configUSE_TRACE_FACILITY为1时，会编译vTaskList()和vTaskGetRunTimeStats()函数, 默认: 0 */</span></span><br><br><span class="hljs-comment">/* 协程相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_CO_ROUTINES                           0                       <span class="hljs-comment">/* 1: 启用协程, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_CO_ROUTINE_PRIORITIES                 2                       <span class="hljs-comment">/* 定义协程的最大优先级, 最大优先级=configMAX_CO_ROUTINE_PRIORITIES-1, 无默认configUSE_CO_ROUTINES为1时需定义 */</span></span><br><br><span class="hljs-comment">/* 软件定时器相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TIMERS                                1                               <span class="hljs-comment">/* 1: 使能软件定时器, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_TASK_PRIORITY                       ( configMAX_PRIORITIES - 1 )    <span class="hljs-comment">/* 定义软件定时器任务的优先级, 无默认configUSE_TIMERS为1时需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_QUEUE_LENGTH                        5                               <span class="hljs-comment">/* 定义软件定时器命令队列的长度, 无默认configUSE_TIMERS为1时需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_TASK_STACK_DEPTH                    ( configMINIMAL_STACK_SIZE * 2) <span class="hljs-comment">/* 定义软件定时器任务的栈空间大小, 无默认configUSE_TIMERS为1时需定义 */</span></span><br><br><span class="hljs-comment">/* 可选函数, 1: 使能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskPrioritySet                        1                       <span class="hljs-comment">/* 设置任务优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_uxTaskPriorityGet                       1                       <span class="hljs-comment">/* 获取任务优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskDelete                             1                       <span class="hljs-comment">/* 删除任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskSuspend                            1                       <span class="hljs-comment">/* 挂起任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xResumeFromISR                          1                       <span class="hljs-comment">/* 恢复在中断中挂起的任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskDelayUntil                         1                       <span class="hljs-comment">/* 任务绝对延时 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskDelay                              1                       <span class="hljs-comment">/* 任务延时 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetSchedulerState                  1                       <span class="hljs-comment">/* 获取任务调度器状态 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetCurrentTaskHandle               1                       <span class="hljs-comment">/* 获取当前任务的任务句柄 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_uxTaskGetStackHighWaterMark             1                       <span class="hljs-comment">/* 获取任务堆栈历史剩余最小值 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetIdleTaskHandle                  1                       <span class="hljs-comment">/* 获取空闲任务的任务句柄 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_eTaskGetState                           1                       <span class="hljs-comment">/* 获取任务状态 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xEventGroupSetBitFromISR                1                       <span class="hljs-comment">/* 在中断中设置事件标志位 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTimerPendFunctionCall                  1                       <span class="hljs-comment">/* 将函数的执行挂到定时器服务任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskAbortDelay                         1                       <span class="hljs-comment">/* 中断任务延时 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetHandle                          1                       <span class="hljs-comment">/* 通过任务名获取任务句柄 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskResumeFromISR                      1                       <span class="hljs-comment">/* 恢复在中断中挂起的任务 */</span></span><br><br><span class="hljs-comment">/* 中断嵌套行为配置 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __NVIC_PRIO_BITS</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> configPRIO_BITS __NVIC_PRIO_BITS</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> configPRIO_BITS 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configLIBRARY_LOWEST_INTERRUPT_PRIORITY         15                  <span class="hljs-comment">/* 中断最低优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    5                   <span class="hljs-comment">/* FreeRTOS可管理的最高中断优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configKERNEL_INTERRUPT_PRIORITY                 ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_SYSCALL_INTERRUPT_PRIORITY            ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_API_CALL_INTERRUPT_PRIORITY           configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><br><span class="hljs-comment">/* FreeRTOS中断服务函数相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandler                              PendSV_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandler                                 SVC_Handler</span><br><br><span class="hljs-comment">/* 断言 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vAssertCalled(char, int) printf(<span class="hljs-string">&quot;Error: %s, %d\r\n&quot;</span>, char, int)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configASSERT( x ) <span class="hljs-keyword">if</span>( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )</span><br><br><span class="hljs-comment">/* FreeRTOS MPU 特殊定义 */</span><br><span class="hljs-comment">//#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0</span><br><span class="hljs-comment">//#define configTOTAL_MPU_REGIONS                                8</span><br><span class="hljs-comment">//#define configTEX_S_C_B_FLASH                                  0x07UL</span><br><span class="hljs-comment">//#define configTEX_S_C_B_SRAM                                   0x07UL</span><br><span class="hljs-comment">//#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY            1</span><br><span class="hljs-comment">//#define configALLOW_UNPRIVILEGED_CRITICAL_SECTIONS             1</span><br><br><span class="hljs-comment">/* ARMv8-M 安全侧端口相关定义。 */</span><br><span class="hljs-comment">//#define secureconfigMAX_SECURE_CONTEXTS         5</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* FREERTOS_CONFIG_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>FreeRTOS提供的五种内存管理算法</p><ul><li><table><thead><tr><th align="center">文件</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">heap_1.c</td><td align="center">分配简单，时间确定</td><td align="center">只分配空间，不能释放</td></tr><tr><td align="center">heap_2.c</td><td align="center">动态分配、最佳匹配</td><td align="center">内存碎片化、时间不定</td></tr><tr><td align="center">heap_3.c</td><td align="center">调用标准C库的函数</td><td align="center">速度慢、时间不定</td></tr><tr><td align="center">heap_4.c</td><td align="center">第二种方法的增强版，可以合并相邻空闲内存，解决碎片化</td><td align="center">时间不定</td></tr><tr><td align="center">heap_5.c</td><td align="center">在第四种方法上支持分隔内存块，解决碎片化</td><td align="center">时间不定</td></tr></tbody></table></li><li><p>heap_1的实现方法；它只提供分配函数，不提供释放函数，具体实现就是直接定义一个大数组如图所示：<img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/heap1%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89.png"></p><p>这个实现只是在要求使用 RAM 时将一个单一的数组细分为更小的块 。 数组的总大小（堆的总大小）通过 configTOTAL_HEAP_SIZE （定义于 FreeRTOSConfig.h 中）设置 。</p></li><li><p>heap_2实现方法；heap_2也是在数组上分配内存，跟heap_1不一样的地方在于heap_2使用<strong>最佳匹配算法</strong>(best fit)来分配内存，它支持vPortFree，例如有有三块空闲内存5B,25B,100B现在要申请20B的空间，那么就会将25B的空间划分为20B跟5B。但是这样可能就会造成碎片，就算释放掉申请的20B空间，它也不会把原先的5B空间合并成一个，如果5B的空间一直没人用的话，就会成碎片。</p></li><li><p>heap_3实现方法；他直接调用标准C库的malloc函数跟free函数，但是FreeRTOS中会先暂停调度器，再去调用这些函数，实现了线程安全</p></li><li><p>heap_4实现方法；heap_4使用<strong>首次适应算法</strong>(first fit)来分配内存,例如有三块空闲内存5B,100B,25B现在要申请20B的空间，那么它会找到第一个满足20B的内存，这里就是先找到100B，把它分为20B跟80B的空间，当释放掉申请的内存时候，它会把释放的20B的内存跟80B的内存从新合并成一块100B的内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。</p></li><li><p>heap_5实现方法；heap_5分配内存、释放内存的算法跟heap_4是一样的。但是heap_5不局限于管理一个大数组，可以管理很多块内存、分隔的内存。但是必须记录每块内存的地址以及大小，用结构体保存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">* <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapRegion</span></span><br><span class="hljs-class">* &#123;</span><br>*  <span class="hljs-type">uint8_t</span> *pucStartAddress; &lt;&lt; Start address of a block of memory that will be part of the heap.<br>*  <span class="hljs-type">size_t</span> xSizeInBytes;      &lt;&lt; Size of the block of memory.<br>* &#125; HeapRegion_t;<br></code></pre></td></tr></table></figure><p>如果要定义多块内存，就用该结构体数组形式来表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">* HeapRegion_t xHeapRegions[] =<br>* &#123;<br>*  &#123; ( <span class="hljs-type">uint8_t</span> * ) <span class="hljs-number">0x80000000</span>UL, <span class="hljs-number">0x10000</span> &#125;, &lt;&lt; Defines a block of <span class="hljs-number">0x10000</span> bytes starting at address <span class="hljs-number">0x80000000</span><br>*  &#123; ( <span class="hljs-type">uint8_t</span> * ) <span class="hljs-number">0x90000000</span>UL, <span class="hljs-number">0xa0000</span> &#125;, &lt;&lt; Defines a block of <span class="hljs-number">0xa0000</span> bytes starting at address of <span class="hljs-number">0x90000000</span><br>*  &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span> &#125;                &lt;&lt; Terminates the <span class="hljs-built_in">array</span>.<br>* &#125;;<br>*<br></code></pre></td></tr></table></figure></li><li><p>在实际使用的时候我们只需要选择其中一个内存管理算法就行。每个算法提供的申请内存的函数都是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( <span class="hljs-type">size_t</span> xWantedSize )</span><br>&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>释放函数都是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortFree</span><span class="hljs-params">( <span class="hljs-type">void</span> * pv )</span><br>&#123;<br>    .......<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="3、FreeRTOS源码"><a href="#3、FreeRTOS源码" class="headerlink" title="3、FreeRTOS源码"></a>3、FreeRTOS源码</h1><h2 id="3-1内核的列表"><a href="#3-1内核的列表" class="headerlink" title="3&#x2F;1内核的列表"></a>3&#x2F;1内核的列表</h2><ul><li><p>在FreeRTOS中列表是个很重要的数据结构，实质就是一个双向链表；FreeRTOS中定义了就绪列表、等待列表、挂起列表、延时列表、终止列表。任务切换等操作都是通过查找对应的列表来实现的。在list.h文件内都是有关列表的定义，以及函数的声明。</p></li><li><p>列表项的数据结构定义，及示意图；</p><ul><li><p>普通列表项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    configLIST_VOLATILE TickType_t xItemValue;          <span class="hljs-comment">/*&lt; The value being listed.  In most cases this is used to sort the list in ascending order. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxNext</span>;</span>     <span class="hljs-comment">/*&lt; Pointer to the next ListItem_t in the list. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxPrevious</span>;</span> <span class="hljs-comment">/*&lt; Pointer to the previous ListItem_t in the list. */</span><br>    <span class="hljs-type">void</span> * pvOwner;                                     <span class="hljs-comment">/*&lt; Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxContainer</span>;</span>     <span class="hljs-comment">/*&lt; Pointer to the list in which this list item is placed (if any). */</span><br>    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE          <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/%E5%88%97%E8%A1%A8%E9%A1%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p>迷你列表项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xMINI_LIST_ITEM</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    configLIST_VOLATILE TickType_t xItemValue;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxNext</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxPrevious</span>;</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xMINI_LIST_ITEM</span> <span class="hljs-title">MiniListItem_t</span>;</span><br></code></pre></td></tr></table></figure><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/%E8%BF%B7%E4%BD%A0%E5%88%97%E8%A1%A8%E9%A1%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li></ul></li><li><p>列表数据结构定义，及其示意图；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_INTEGRITY_CHECK_VALUE      <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    <span class="hljs-keyword">volatile</span> UBaseType_t uxNumberOfItems;<br>    ListItem_t * configLIST_VOLATILE pxIndex; <span class="hljs-comment">/*&lt; Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */</span><br>    MiniListItem_t xListEnd;                  <span class="hljs-comment">/*&lt; List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */</span><br>    listSECOND_LIST_INTEGRITY_CHECK_VALUE     <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>&#125; List_t;<br></code></pre></td></tr></table></figure><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/%E5%88%97%E8%A1%A8%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p>切记列表里面的迷你列表项，不算做列表中的列表项的个数</p></li><li><p>FreeRTOS列表操作函数</p><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">void vListInitialise( List_t * const pxList )</td><td align="center">初始化列表头</td></tr><tr><td align="center">void vListInitialiseItem( ListItem_t * const pxItem )</td><td align="center">初始化列表项</td></tr><tr><td align="center">void vListInsert( List_t * const pxList,<br>                  ListItem_t * const pxNewListItem )</td><td align="center">按照列表项里的列表值进行顺序插入列表</td></tr><tr><td align="center">void vListInsertEnd( List_t * const pxList,<br>                     ListItem_t * const pxNewListItem )</td><td align="center">列表末端插入，这里特别要注意，这里并不一定是插到xListEnd后面，具体是插在pxIndex指向的列表项前面</td></tr><tr><td align="center">UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )</td><td align="center">删除列表项，返回移除后列表中列表项的多少</td></tr></tbody></table></li></ul><h2 id="3-2任务操作相关函数"><a href="#3-2任务操作相关函数" class="headerlink" title="3&#x2F;2任务操作相关函数"></a>3&#x2F;2任务操作相关函数</h2><ul><li><p>任务创建函数和删除函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*动态创建*/</span><br>BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">( </span><br><span class="hljs-params"> TaskFunction_t pxTaskCode, <span class="hljs-comment">//任务函数的函数指针</span></span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, <span class="hljs-comment">//任务名字</span></span><br><span class="hljs-params"> <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="hljs-comment">//任务堆栈大小</span></span><br><span class="hljs-params"> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters, <span class="hljs-comment">//传递给任务函数的参数</span></span><br><span class="hljs-params"> UBaseType_t uxPriority, <span class="hljs-comment">//任务优先级</span></span><br><span class="hljs-params"> TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask<span class="hljs-comment">//任务函数的函数句柄，就是任务控制块</span></span><br><span class="hljs-params">)</span>; <br><span class="hljs-comment">/*静态创建*/</span><br>TaskHandle_t <span class="hljs-title function_">xTaskCreateStatic</span><span class="hljs-params">( </span><br><span class="hljs-params"> TaskFunction_t pxTaskCode, </span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, </span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> ulStackDepth, </span><br><span class="hljs-params"> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters, </span><br><span class="hljs-params"> UBaseType_t uxPriority, </span><br><span class="hljs-params"> StackType_t * <span class="hljs-type">const</span> puxStackBuffer,<span class="hljs-comment">//任务的栈指针，内存由用户分配</span></span><br><span class="hljs-params"> StaticTask_t * <span class="hljs-type">const</span> pxTaskBuffer<span class="hljs-comment">//任务控制块的指针，内存由用户分配</span></span><br><span class="hljs-params">)</span>; <br><span class="hljs-comment">/*任务删除*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">(TaskHandle_t xTaskToDelete<span class="hljs-comment">//任务的句柄); </span></span><br></code></pre></td></tr></table></figure></li><li><p>任务挂起和恢复</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">(TaskHandle_t xTaskToSuspend)</span>;<span class="hljs-comment">//挂起任务，会阻塞任务</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskResume</span><span class="hljs-params">(TaskHandle_t xTaskToResume)</span>;<span class="hljs-comment">//恢复任务</span><br>BaseType_t <span class="hljs-title function_">xTaskResumeFromISR</span><span class="hljs-params">(TaskHandle_t xTaskToResume)</span><span class="hljs-comment">//在中断中要用这个来恢复任务</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-3任务间通信"><a href="#3-3任务间通信" class="headerlink" title="3&#x2F;3任务间通信"></a>3&#x2F;3任务间通信</h2><h3 id="3-3-1消息队列和队列集"><a href="#3-3-1消息队列和队列集" class="headerlink" title="3&#x2F;3&#x2F;1消息队列和队列集"></a>3&#x2F;3&#x2F;1消息队列和队列集</h3><ul><li><p>消息队列；是一种先进先出的存储机制，消息队列里面可以存储任何数据类型；但是要求任务在写队列的时候，要严格按照数据类型格式来写。如图所示：</p><p><img src="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/photo/%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p>队列创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//动态创建，返回队列的起始地址</span><br>xQueueCreate(uxQueueLength，uxItemSize)<br></code></pre></td></tr></table></figure></li><li><p>队列读写函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">xQueueSend()<span class="hljs-comment">//尾部写队列</span><br>xQueueSendFromISR()<span class="hljs-comment">//中断中写</span><br>    <br>xQueueReceive()<span class="hljs-comment">//读队列</span><br>xQueueReceiveFromISR() <span class="hljs-comment">//中断中对</span><br></code></pre></td></tr></table></figure></li><li><p>注意，读写队列都可能导致任务阻塞，写的时候队列满，阻塞任务；读的时候队列空，阻塞任务；</p></li><li><p>队列集：队列集就是把存储不同数据类型的队列，管理起来；方便任务读取不同的队列。</p></li><li><p>队列集操作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">xQueueCreateSet()<span class="hljs-comment">//创建队列集</span><br>xQueueAddToSet()<span class="hljs-comment">//添加队列到队列集</span><br>xQueueRemoveFromSet()<span class="hljs-comment">//移除队列</span><br>xQueueSelectFromSet()<span class="hljs-comment">//获取队列集中有效消息的队列</span><br>xQueueSelectFromSetFromISR()<span class="hljs-comment">//在中断中获取队列集中的有效队列消息</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-3-2信号量"><a href="#3-3-2信号量" class="headerlink" title="3&#x2F;3&#x2F;2信号量"></a>3&#x2F;3&#x2F;2信号量</h3><ul><li><p>任务同步与互斥；任务同步就是一个任务要等待另一个任务操作完，才能进行下一步操作；互斥就是，两个任务在同一时间只能对某一个临界区资源进行操作；所以同步与互斥是成对出现的。</p></li><li><p>二值信号量：实质是一个队列项只有一个的队列，所以队列要么空和要么满；来解决任务间同步与互斥的问题。</p></li><li><p>计数型信号量：实质是一个多项的队列，但是这个队列，并不传递数据。仅仅是来表示可用资源数有多少；</p></li><li><p>互斥信号量：在二值信号量的基础上，加了优先级继承的机制，让获得信号量的任务优先级暂时提高，防止中等优先级任务打断，导致最高优先级任务一直阻塞。切记，不能用到中断，因为中断不是任务，没有优先级。并且中断中不能等待互斥量而被阻塞。</p></li></ul><h3 id="3-3-3空闲任务"><a href="#3-3-3空闲任务" class="headerlink" title="3&#x2F;3&#x2F;3空闲任务"></a>3&#x2F;3&#x2F;3空闲任务</h3><ul><li>在启动任务调度器的时候，内核默认创建了一个优先级最低的任务，就是空闲任务，这个任务主要在没有其他用户任务运行时，才会执行。主要作用是内存清理，以及统计任务。里面有个钩子函数，主要设置处理进入低功耗模式，这里是设置处理器；freertos有自带的低功耗区分一下。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式常见协议总结</title>
    <link href="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1、UART串口通信"><a href="#1、UART串口通信" class="headerlink" title="1、UART串口通信"></a>1、UART串口通信</h1><h2 id="1-1简介"><a href="#1-1简介" class="headerlink" title="1.1简介"></a>1.1简介</h2><ul><li><p>通用异步收发器 <strong>UART</strong>（Universal AsynchronousReceiver&#x2F;Transmitter)，是一种串行、异步、全双工的通信协议。高电平代表’1‘，低电平代表’0‘。特别注意固定格式位，起始位以0为通信起步，停止位以1作为结束位。</p></li><li><p>整体结构如图：</p><p><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/%E7%BB%93%E6%9E%84%E7%AE%80%E5%9B%BE.png"></p></li></ul><h2 id="1-2参数配置"><a href="#1-2参数配置" class="headerlink" title="1.2参数配置"></a>1.2参数配置</h2><ul><li><p>数据传输格式</p><p><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/UART%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.png" alt="数据格式"></p><ul><li>起始位总是以低电平有效，停止位以高电平有效。</li><li>数据位：数据位可以是5、6、7、8，9位等，构成一个字符（一般都是8位）。如ASCII码（7位），扩展BCD码（8位）。先发送<strong>最低位</strong>，最后发送<strong>最高位</strong>，使用低电平表示‘0’高电平表示‘1’完成数据位的传输。</li><li>奇偶检验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。</li></ul></li><li><p>波特率</p><ul><li>数据传输的速率用波特率来表示。通俗讲就是让通信双方知道什么时间点来采样数据。例如:通信波特率是115200bps，即代表1秒可以传输115200位的数据。</li></ul></li></ul><h2 id="1-3示例"><a href="#1-3示例" class="headerlink" title="1.3示例"></a>1.3示例</h2><ul><li><p>在stm32中如何使用串口，来实现printf函数与PC串口助手进行通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//值得的注意点：printf函数最终调用的是fputc(int ch, FILE *f)来输出字符串的，但是这个函数在stdio.h文件里面仅仅是定义了但是没有实现，所以必须重定义这个函数。</span><br>    <span class="hljs-comment">/*以下示例均以UART1来作为示例*/</span><br>    <span class="hljs-comment">/*HAL库函数版本实现串口的中断接收和发送*/</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">    &#123;</span><br>        __IO <span class="hljs-type">uint32_t</span> SR;         <span class="hljs-comment">/*!&lt; USART Status register,                   Address offset: 0x00 */</span><br>        __IO <span class="hljs-type">uint32_t</span> DR;         <span class="hljs-comment">/*!&lt; USART Data register,                     Address offset: 0x04 */</span><br>        __IO <span class="hljs-type">uint32_t</span> BRR;        <span class="hljs-comment">/*!&lt; USART Baud rate register,                Address offset: 0x08 */</span><br>        __IO <span class="hljs-type">uint32_t</span> CR1;        <span class="hljs-comment">/*!&lt; USART Control register 1,                Address offset: 0x0C */</span><br>        __IO <span class="hljs-type">uint32_t</span> CR2;        <span class="hljs-comment">/*!&lt; USART Control register 2,                Address offset: 0x10 */</span><br>        __IO <span class="hljs-type">uint32_t</span> CR3;        <span class="hljs-comment">/*!&lt; USART Control register 3,                Address offset: 0x14 */</span><br>        __IO <span class="hljs-type">uint32_t</span> GTPR;       <span class="hljs-comment">/*!&lt; USART Guard time and prescaler register, Address offset: 0x18 */</span><br>    &#125; USART_TypeDef;<span class="hljs-comment">//这是底层寄存器封装</span><br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PERIPH_BASE           0x40000000UL</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000UL)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> USART1_BASE           (APB2PERIPH_BASE + 0x00003800UL)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> USART1              ((USART_TypeDef *)USART1_BASE)</span><br>    <br>    <span class="hljs-comment">/*重定义fputc(int ch, FILE *f)*/</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> ((USART1-&gt;SR &amp; <span class="hljs-number">0X40</span>) == <span class="hljs-number">0</span>);     <span class="hljs-comment">/* 等待上一个字符发送完成 */</span><br>        USART_UX-&gt;DR = (<span class="hljs-type">uint8_t</span>)ch;           <span class="hljs-comment">/* 将要发送的字符 ch 写入到DR寄存器 */</span><br>        <span class="hljs-keyword">return</span> ch;<br>    &#125;<br>    <span class="hljs-comment">/*初始化串口1,省略大部分代码，保留核心函数*/</span><br>    UART_HandleTypeDef g_uart1_handle;  <span class="hljs-comment">/* UART句柄 */</span><br>    HAL_UART_Init(&amp;g_uart1_handle)内部调用--&gt;HAL_UART_MspInit(&amp;g_uart1_handle)--&gt; HAL_GPIO_Init()函数来配置相关引脚的复用输入输出--&gt;HAL_NVIC_EnableIRQ()使能串口中断--&gt;HAL_NVIC_SetPriority()设置中断优先级<br>    <br>        HAL_UART_Receive_IT(&amp;g_uart1_handle, (<span class="hljs-type">uint8_t</span> *)g_rx_buffer, RXBUFFERSIZE)开启串口接收中断天<br>    <br>        USART1_IRQHandler()串口<span class="hljs-number">1</span>中断服务函数--&gt;HAL_UART_IRQHandler()HAL串口中断公共服务函--&gt;HAL_UART_RxCpltCallback()中断接收回调函数 <br></code></pre></td></tr></table></figure></li></ul><h1 id="2、集成电路总线-IIC"><a href="#2、集成电路总线-IIC" class="headerlink" title="2、集成电路总线(IIC)"></a>2、集成电路总线(IIC)</h1><h2 id="2-1简介"><a href="#2-1简介" class="headerlink" title="2.1简介"></a>2.1简介</h2><ul><li>IIC使用两根信号线进行通信：一根时钟线SCL，一根数据线SDA。IIC将SCL处于高时SDA拉低的动作作为开始信号，SCL处于高时SDA拉高的动作作为结束信号；传输数据时，SDA在SCL低电平时改变数据，在SCL高电平时保持数据，每个SCL脉冲的高电平传递1位数据。IIC是半双工同步通信协议</li></ul><h2 id="2-2总线特性与硬件结构"><a href="#2-2总线特性与硬件结构" class="headerlink" title="2.2总线特性与硬件结构"></a>2.2总线特性与硬件结构</h2><ul><li><p>IIC总线上所有器件的SDA、SCL引脚输出驱动都为 <strong>开漏(OD)</strong> 结构，通过外接上拉电阻实现总线上所有节点SDA、SCL信号的<strong>线与</strong>逻辑关系；</p></li><li><p>总线上的所有设备通过软件寻址且具有唯一的地址（7位或10位）。7位“从机专用地址码”，其高4位为由生产厂家制定的<strong>设备类型地址</strong>，低3位为器件引脚定义地址（由使用者定义）；10位地址不常见；</p></li><li><p>支持多主机。在总线上存在多个主机时，通过冲突检测和仲裁机制防止多个主机同时发起数据传输时存在的冲突；</p></li><li><p>通信模式</p><ul><li><table><thead><tr><th align="center">模式</th><th align="center">速度</th></tr></thead><tbody><tr><td align="center">标准模式（Standard Mode）</td><td align="center">100kb&#x2F;s</td></tr><tr><td align="center">快速模式（Fast Mode）</td><td align="center">400kb&#x2F;s</td></tr><tr><td align="center">增强快速模式（Fast Mode Plus）</td><td align="center">1Mb&#x2F;s</td></tr><tr><td align="center">高速模式（High Speed Mode）</td><td align="center">3.4Mb&#x2F;s</td></tr><tr><td align="center">极速模式（Ultra-FastMode）</td><td align="center">5Mb&#x2F;s</td></tr></tbody></table></li></ul></li><li><p>硬件结构</p><ul><li>IIC使用两根信号线进行通信，要求两根线都使用 <strong>开漏输出接上拉电阻</strong> 的配置，以此实现总线上所有节点SDA、SCL信号的 <strong>线与</strong> 逻辑关系。</li><li><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/IIC%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E4%BD%93%E5%9B%BE.png" alt="结构图"></li><li>IIC允许一对多通信，但是同一时间只能有一个丛机跟主机通信</li></ul></li></ul><h2 id="2-3工作时序"><a href="#2-3工作时序" class="headerlink" title="2.3工作时序"></a>2.3工作时序</h2><ul><li><strong>数据有效性以及采集过程</strong><ul><li>IIC 的数据读取动作都在 <strong>SCL为高</strong> 时产生，<strong>SCL为低</strong>时是数据改变的时期，无论SDA如何变化都不影响读取。所以，传输数据的过程中，当SCL为高时，数据应当保持稳定，避免数据的采集出错。</li></ul></li><li><strong>开始和结束信号</strong><ul><li><strong>开始信号：</strong>SCL为高时，SDA从高到低的跳变产生开始信号</li><li><strong>结束信号：</strong>SCL为高时，SDA从低到高的跳变产生结束信号</li></ul></li><li><strong>重复开始信号（ReSTART&#x2F;Sr）：</strong> 在结束时不给出STOP信号，而以一个时钟周期内再次给出开始信号作为替代</li><li><strong>字节格式：</strong>SDA数据线上的每个字节<strong>必须是8位</strong>，对于每次传输的<strong>字节数没有限制</strong>。每个字节（8位）数据传送完后紧跟着应答信号（ACK，第9位）。数据的先后顺序为：<strong>高位在前</strong> 。</li><li><strong>应答信号（ACK）：</strong>协议规定数据传输过程必须包含应答（ACK）。接收器通过应答告知发送的字节已被成功接收，之后发送器可以进行下一个字节的传输。<strong>主机产生数据传输过程中的所有时钟，包括用于应答的第9个时钟。发送器在应答时钟周期内释放对SDA总线的控制，</strong>这样接收器可以通过将SDA线拉低告知发送器：数据已被成功接收。（<strong>特别注意，ACK信号是主机发送完数据后，必须必须释放SDA总线后，丛机来控制SDA总线发出的信号</strong>）<ul><li>应答信号分为两种：<ul><li>当第9位(应答位)为 <strong>低电平</strong> 时，为 <strong>ACK</strong> 信号</li><li>当第9位(应答位)为 <strong>高电平</strong> 时，为 <strong>NACK</strong>信号</li></ul></li></ul></li></ul><h2 id="2-4地址设备为7位的通信过程"><a href="#2-4地址设备为7位的通信过程" class="headerlink" title="2.4地址设备为7位的通信过程"></a>2.4地址设备为7位的通信过程</h2><ul><li>完整通信示意图：<ul><li><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/7bit%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E9%80%9A%E4%BF%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="示意图"></li><li><strong>START信号后，第一个字节包含设备7位地址以及1位读写位，读写位表示主机将要对丛机进行的操作。发送完这个字节之后，主机释放SDA总线等待从机给出ACK应答。如果从机给出了ACK应答，表示从机地址正确（有从机响应）并且已知晓是读还是写，便可以开始读写数据。如果从机没有给出ACK应答，则说明接收设备可能没有收到数据（如寻址的设备不存在或是设备正在忙碌）或无法解析收到的数据，如果是这样，则由主机来决定如何处理（STOP或ReSTART）。</strong><ul><li>情况一：主机写，丛机收，传输过程传输方向不变<ul><li><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/%E4%B8%BB%E5%8F%91%E4%B8%9B%E6%94%B6.png" alt="示意图"></li></ul></li><li>情况二：主机收，丛机发送，传输过程传输方向改变<ul><li><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/%E4%B8%BB%E6%94%B6%E4%B8%9B%E5%8F%91.png" alt="示意图"></li></ul></li></ul></li></ul></li></ul><h2 id="2-4实例操作"><a href="#2-4实例操作" class="headerlink" title="2.4实例操作"></a>2.4实例操作</h2><ul><li><p>情况一：用GPIO来模拟IIC通信过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*以F103为例子，SCL--&gt;PB6,SDA--&gt;PB7，精简代码，不是所有都列出来*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCL(x)do&#123;x? HAL_GPIO_WritePin(GPIOB,GPIO_PIN6,GPIO_PIN_SET):</span><br> \HAL_GPIO_WritePin(GPIOB,GPIO_PIN6,GPIO_PIN_RESET);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDA(x)do&#123;x? HAL_GPIO_WritePin(GPIOB,GPIO_PIN7,GPIO_PIN_SET):</span><br> \HAL_GPIO_WritePin(GPIOB,GPIO_PIN7,GPIO_PIN_RESET);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)<br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//初始化函数</span><br>&#123;<br>    GPIO_InitTypeDef gpio_init_struct;<br>    <br><span class="hljs-comment">/*首先是初始化这两个IO口，SCL配置为推挽输出，SDA配置为开漏输出（这样保证无论在哪种通信下，都不需要去切换IO口的     方向，因为开漏输出也可以读取IO的电平）*/</span><br>    <br>    ...配置省略<br>        <br>HAL_GPIO_Init(GPIOB, &amp;gpio_init_struct);<br>stop();<span class="hljs-comment">//初始化后先停止</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//起始信号</span><br>&#123;<br>    <span class="hljs-comment">/*SCL为高时，SDA从高到低的跳变产生开始信号*/</span><br>    SDA(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SDA(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    <br>    SCL(<span class="hljs-number">0</span>);<span class="hljs-comment">//这个操作是钳住IIC总线，准备接受或者发送数据</span><br>    delay_us(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//停止信号</span><br>&#123;<br>    <span class="hljs-comment">/*SCL为高时，SDA从低到高的跳变产生结束信号*/</span><br>    SDA(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SDA(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">master_ack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//主机应答信号</span><br>&#123;<br>    SDA(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    <br>    SDA(<span class="hljs-number">1</span>);<span class="hljs-comment">//释放总线</span><br>    delay_us(<span class="hljs-number">2</span>);      <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">master_nack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//主机不应答信号</span><br>&#123;<br>    SDA(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);     <br>&#125;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">slave_ack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> timeout;<br>    <span class="hljs-type">uint8_t</span> res=<span class="hljs-number">0</span>;<br>    SDA(<span class="hljs-number">1</span>);<span class="hljs-comment">//主机释放总线，此时丛机可以操作SDA线</span><br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<span class="hljs-comment">//拉高时钟线，可以传输数据了</span><br>    delay_us(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_7))<span class="hljs-comment">//等待SDA线的电平被从机拉低</span><br>    &#123;<br>        timeout++;<br>        <span class="hljs-keyword">if</span>(timeout&gt;<span class="hljs-number">250</span>)<br>        &#123;<br>            stop();<span class="hljs-comment">//超时</span><br>            res=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    SCL(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">iic_send</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span><span class="hljs-comment">//发送8位数据</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>    &#123;<br>        SDA((data&amp;<span class="hljs-number">0x80</span>)&gt;&gt;<span class="hljs-number">7</span>);<span class="hljs-comment">//因为IIC是先传输最高位的</span><br>        delay_us(<span class="hljs-number">2</span>);<br>        SCL(<span class="hljs-number">1</span>);<br>        delay_us(<span class="hljs-number">2</span>);<br>        SCL(<span class="hljs-number">0</span>);<br>        delay_us(<span class="hljs-number">2</span>);<br>        data&lt;&lt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    SDA(<span class="hljs-number">1</span>);<span class="hljs-comment">//释放总线</span><br>&#125;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">iic_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> ack)</span><span class="hljs-comment">//读取8位数据   </span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> res;<br>    <span class="hljs-type">uint8_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>    &#123;<br>        res&lt;&lt;=<span class="hljs-number">1</span>;<br>        SCL(<span class="hljs-number">1</span>);<br>        delay_us(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_7)<br>           &#123;<br>               res++;<br>           &#125;<br>        SCL(<span class="hljs-number">0</span>);<br>  delay_us(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!ack)<br>    &#123;<br>         master_nack();      <br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>         master_ack();       <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;       <br>&#125; <br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p>情况二：硬件IIC，用HAL库函数实现（F1系列HAL库硬件IIC可能会有BUG）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/////////////////////////</span><br>I2C_HandleTypeDef handle_iic<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">iic_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//硬件IIC初始化函数</span><br>&#123;<br>    <span class="hljs-comment">/*具体句柄配置省略，设置i2c速度、模式、丛机地址位数等等*/</span><br>    ...省略代码<br>        HAL_I2C_Iint(&amp;handle_iic);<span class="hljs-comment">/*这是IIC的初始化，还需要对应GPIO的初始化，这个函数内部会调用HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)这个函数*/</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_I2C_MspInit</span><span class="hljs-params">(I2C_HandleTypeDef* hi2c)</span><br>&#123;<br>    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span>(hi2c-&gt;I2C1)<br>    &#123;<br>        ...具体GPIO配置省略<br>        HAL_GPIO_Init();<br>        __HAL_RCC_I2C1_CLK_ENABLE();<br>        HAL_NVIC_SetPriority(I2C1_EV_IRQn, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);<br>        HAL_NVIC_SetPriority(I2C1_ER_IRQn, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*HAL库提供三种类型读写函（阻塞、非阻塞（其中包括中断和DMA））*/</span><br><span class="hljs-comment">//阻塞IIC发送、接受代码原型</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Transmit</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Receive</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_IsDeviceReady</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint32_t</span> Trials, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br><br><span class="hljs-comment">//非阻塞普通中断IIC发送、接受代码原型</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Transmit_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Receive_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br><br><span class="hljs-comment">//非阻塞DMA中断IIC发送、接受代码原型</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Transmit_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Receive_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p><strong>通过硬件IIC读取AT24C02代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><br><span class="hljs-comment">//AT24Cxx这是一个IIC接口的EEPROM存储芯片</span><br><span class="hljs-comment">//读写地址</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Write 0xA0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Read  0xA1</span><br><span class="hljs-comment">//三次写入的字符串</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str1[]=&#123;<span class="hljs-string">&quot;xyz666&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str2[]=&#123;<span class="hljs-string">&quot;1234567&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str3[]=&#123;<span class="hljs-string">&quot;abcdefg&quot;</span>&#125;;<br><span class="hljs-comment">//读取缓存区</span><br><span class="hljs-type">uint8_t</span> ReadBuffer[<span class="hljs-number">50</span>];<br><span class="hljs-comment">/* USER CODE END PV */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//阻塞方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str1,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>)==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>);<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_IT(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str2,<span class="hljs-keyword">sizeof</span>(str2))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_IT(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//DMA中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_DMA(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str3,<span class="hljs-keyword">sizeof</span>(str3))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_DMA(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li></ul><h1 id="3、串行外设接口（SPI）"><a href="#3、串行外设接口（SPI）" class="headerlink" title="3、串行外设接口（SPI）"></a>3、串行外设接口（SPI）</h1><h2 id="3-1简介"><a href="#3-1简介" class="headerlink" title="3.1简介"></a>3.1简介</h2><ul><li>SPI，是一<strong>种高速的，全双工，同步</strong>的通信总线，并且在芯片的管脚上只占用四根线。SPI分为主、从两种模式，一个SPI通讯系统需要包含一个（且只能是一个）主设备，一个或多个从设备。提供时钟的为主设备（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起。当存在多个从设备时，通过各自的片选信号进行管理。</li><li>4线SPI示意图<ul><li><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/4%E7%BA%BFSPI%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="示意图"></li><li><strong>MISO</strong>： <strong>主设备输入&#x2F;从设备输出引脚</strong>。该引脚在从模式下发送数据，在主模式下接收数据。</li><li><strong>MOSI</strong>： <strong>主设备输出&#x2F;从设备输入引脚</strong>。该引脚在主模式下发送数据，在从模式下接收数据。</li><li><strong>SCLK</strong>：<strong>串行时钟信号</strong>，由主设备产生。</li><li><strong>CS&#x2F;SS</strong>：<strong>从设备片选信号</strong>，由主设备控制。它的功能是用来作为“片选引脚”，也<strong>就是选择指定的从设备</strong>，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。</li></ul></li><li>SPI工作原理<ul><li>在主机和从机都有一个串行移位寄存器，主机通过向它的 SPI 串行寄存 器写入一个字节来发起一次传输。串行移位寄存器通过 MOSI 信号线将字节传送给从机，从机 也将自己的串行移位寄存器中的内容通过 MISO 信号线返回给主机。这样，两个移位寄存器中 的内容就被交换。外设的写操作和读操作是同步完成的。<strong>如果只是进行写操作，主机只需忽略 接收到的字节。反之，若主机要读取从机的一个字节，就必须发送一个空字节引发从机传输。</strong></li></ul></li><li>SPI传输方式<ul><li><strong>SPI总共有三种传输方式：全双工、单工以及半双工传输方式。</strong></li></ul></li></ul><h2 id="3-2工作时序"><a href="#3-2工作时序" class="headerlink" title="3.2工作时序"></a>3.2工作时序</h2><ul><li><p>SPI四种不同工作模式由CPOL(时钟极性)和CPHA（时钟相位）来控制</p><ul><li><table><thead><tr><th align="center">SPI工作模式</th><th align="center">CPOL</th><th align="center">CPHA</th><th align="center">SCL空闲状态</th><th align="center">采样边沿</th><th align="center">采样时刻</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">低电平</td><td align="center">上升沿</td><td align="center">奇数边沿</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">低电平</td><td align="center">下降沿</td><td align="center">偶数边沿</td></tr><tr><td align="center">2</td><td align="center">1</td><td align="center">0</td><td align="center">高电平</td><td align="center">下降沿</td><td align="center">奇数边沿</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">1</td><td align="center">高电平</td><td align="center">上升沿</td><td align="center">偶数边沿</td></tr></tbody></table></li><li><p>以CPOL&#x3D;0,CPHA&#x3D;0为示例时序图，其他同理</p><ul><li><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/SPI%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="时序图"></li><li>由图可以看出来，在传输开始前以及传输完成后，CPOL即SCL都为低电平，表示空闲的时候SCL为低电平状态，由于采样边沿是上升沿，即在第1、3、5、7…..等这些边沿进行采样。</li></ul></li></ul></li></ul><h2 id="3-3实例操作"><a href="#3-3实例操作" class="headerlink" title="3.3实例操作"></a>3.3实例操作</h2><ul><li><p><strong>基于stm32的HAL库配置SPI</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><br><span class="hljs-comment">//AT24Cxx这是一个IIC接口的EEPROM存储芯片</span><br><span class="hljs-comment">//读写地址</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Write 0xA0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Read  0xA1</span><br><span class="hljs-comment">//三次写入的字符串</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str1[]=&#123;<span class="hljs-string">&quot;xyz666&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str2[]=&#123;<span class="hljs-string">&quot;1234567&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str3[]=&#123;<span class="hljs-string">&quot;abcdefg&quot;</span>&#125;;<br><span class="hljs-comment">//读取缓存区</span><br><span class="hljs-type">uint8_t</span> ReadBuffer[<span class="hljs-number">50</span>];<br><span class="hljs-comment">/* USER CODE END PV */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//阻塞方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str1,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>)==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>);<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_IT(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str2,<span class="hljs-keyword">sizeof</span>(str2))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_IT(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//DMA中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_DMA(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str3,<span class="hljs-keyword">sizeof</span>(str3))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_DMA(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p><strong>SPI-&gt;norflash存储芯片的读写</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*仅仅介绍几个函数，具体的请参考完整代码*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_init</span><span class="hljs-params">()</span><br>&#123;<br>    GPIO_InitTypeDef gpio_init_struct;<span class="hljs-comment">//主要为了配置片选引脚</span><br>    ...配置代码省略<br>    HAL_GPIO_Init(GPIOX,&amp;gpio_init_struct)<br>    spi_init();<br>    spi_set_speed(SPI_SPEED_2);<span class="hljs-comment">//这个设置SPI速度的</span><br>    <span class="hljs-comment">/*有些flash芯片需要开启4字节地址模式*/</span>   <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_send_address</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> address)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (g_norflash_type == W25Q256) <span class="hljs-comment">/*  只有W25Q256支持4字节地址模式 */</span><br>    &#123;<br>        spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)((address)&gt;&gt;<span class="hljs-number">24</span>)); <span class="hljs-comment">/* 发送 bit31 ~ bit24 地址 */</span><br>    &#125; <br>    spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)((address)&gt;&gt;<span class="hljs-number">16</span>));     <span class="hljs-comment">/* 发送 bit23 ~ bit16 地址 */</span><br>    spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)((address)&gt;&gt;<span class="hljs-number">8</span>));      <span class="hljs-comment">/* 发送 bit15 ~ bit8  地址 */</span><br>    spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)address);             <span class="hljs-comment">/* 发送 bit7  ~ bit0  地址 */</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pbuf, <span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint16_t</span> datalen)</span><br>&#123;<br>    <span class="hljs-type">uint16_t</span> i;<br><br>    HAL_GPIO_WritePin(GPIOX,GPIO_PIN,GPIO_PIN_RESET);<span class="hljs-comment">//拉低片选选中芯片</span><br>    spi2_read_write_byte(FLASH_ReadData);       <span class="hljs-comment">/* 发送读取命令 */</span><br>    norflash_send_address(addr);                <span class="hljs-comment">/* 发送地址 */</span><br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;datalen;i++)<br>    &#123;<br>        pbuf[i] = spi2_read_write_byte(<span class="hljs-number">0XFF</span>);   <span class="hljs-comment">/* 循环读取 */</span><br>    &#125;<br>    <br>    HAL_GPIO_WritePin(GPIOX,GPIO_PIN,GPIO_PIN_SET);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pbuf, <span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint16_t</span> datalen)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> secpos;<br>    <span class="hljs-type">uint16_t</span> secoff;<br>    <span class="hljs-type">uint16_t</span> secremain;<br>    <span class="hljs-type">uint16_t</span> i;<br>    <span class="hljs-type">uint8_t</span> *norflash_buf;<br><br>    norflash_buf = g_norflash_buf;<br>    secpos = addr / <span class="hljs-number">4096</span>;       <span class="hljs-comment">/* 扇区地址 */</span><br>    secoff = addr % <span class="hljs-number">4096</span>;       <span class="hljs-comment">/* 在扇区内的偏移 */</span><br>    secremain = <span class="hljs-number">4096</span> - secoff;  <span class="hljs-comment">/* 扇区剩余空间大小 */</span><br>    <span class="hljs-keyword">if</span> (datalen &lt;= secremain)<br>    &#123;<br>        secremain = datalen;    <span class="hljs-comment">/* 不大于4096个字节 */</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        norflash_read(norflash_buf, secpos * <span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>);   <span class="hljs-comment">/* 读出整个扇区的内容 */</span><br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; secremain; i++)   <span class="hljs-comment">/* 校验数据 */</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (norflash_buf[secoff + i] != <span class="hljs-number">0XFF</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;      <span class="hljs-comment">/* 需要擦除, 直接退出for循环 */</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &lt; secremain)   <span class="hljs-comment">/* 需要擦除 */</span><br>        &#123;<br>            norflash_erase_sector(secpos);  <span class="hljs-comment">/* 擦除这个扇区 */</span><br><br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; secremain; i++)   <span class="hljs-comment">/* 复制 */</span><br>            &#123;<br>                norflash_buf[i + secoff] = pbuf[i];<br>            &#125;<br><br>            norflash_write_nocheck(norflash_buf, secpos * <span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>);  <span class="hljs-comment">/* 写入整个扇区 */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">/* 写已经擦除了的,直接写入扇区剩余区间. */</span><br>        &#123;<br>            norflash_write_nocheck(pbuf, addr, secremain);  <span class="hljs-comment">/* 直接写扇区 */</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (datalen == secremain)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">/* 写入结束了 */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">/* 写入未结束 */</span><br>        &#123;<br>            secpos++;               <span class="hljs-comment">/* 扇区地址增1 */</span><br>            secoff = <span class="hljs-number">0</span>;             <span class="hljs-comment">/* 偏移位置为0 */</span><br><br>            pbuf += secremain;      <span class="hljs-comment">/* 指针偏移 */</span><br>            addr += secremain;      <span class="hljs-comment">/* 写地址偏移 */</span><br>            datalen -= secremain;   <span class="hljs-comment">/* 字节数递减 */</span><br><br>            <span class="hljs-keyword">if</span> (datalen &gt; <span class="hljs-number">4096</span>)<br>            &#123;<br>                secremain = <span class="hljs-number">4096</span>;   <span class="hljs-comment">/* 下一个扇区还是写不完 */</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                secremain = datalen;<span class="hljs-comment">/* 下一个扇区可以写完了 */</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p><strong>扩展</strong></p><ul><li>SPI不仅仅只有4线的，还有6线的。多出来两根数据线，这样可以一个时钟周期传输两个字节</li></ul></li></ul><h1 id="4、控制局域网总线（CAN）"><a href="#4、控制局域网总线（CAN）" class="headerlink" title="4、控制局域网总线（CAN）"></a>4、控制局域网总线（CAN）</h1><h2 id="4-1简介"><a href="#4-1简介" class="headerlink" title="4.1简介"></a>4.1简介</h2><ul><li>控制器局域网总线（CAN，Controller Area Network）是一种用于实时应用的串行通讯协议总线，它可以使用双绞线来传输信号，是世界上应用最广泛的现场总线之一。CAN协议用于汽车中各种不同元件之间的通信，以此取代昂贵而笨重的配电线束。该协议的健壮性使其用途延伸到其他自动化和工业应用。CAN协议的特性包括完整性的串行数据通讯、提供实时支持、传输速率高达1Mb&#x2F;s、同时具有11位的寻址以及检错能力。</li></ul><h2 id="4-2CAN总线结构"><a href="#4-2CAN总线结构" class="headerlink" title="4.2CAN总线结构"></a>4.2CAN总线结构</h2><ul><li><strong>闭环总线结构</strong>：如图所示，总线两端各连接一个120欧的电阻，两根信号线形成回路。这种CAN总线网络由ISO 11898标准定义，是高速、短距离的CAN网络，通信速率为125kbit&#x2F;s到1Mbit&#x2F;s。在1Mbit&#x2F;s通讯速率时，总线长度最长达40m。<ul><li><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/%E9%97%AD%E7%8E%AFCAN%E7%BB%93%E6%9E%84.png" alt="总线结构图"></li></ul></li><li><strong>开环总线结构</strong>：两根信号线独立，各自串联一个2.2k欧的电阻。这种CAN总线网络由ISO11519-2标准定义，是低速、远距离的CAN网络，通信速率最高125kbit&#x2F;s。在40kbit&#x2F;s速率时，总线最长距离可达1000m。<ul><li><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/%E5%BC%80%E7%8E%AF%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="示意图"></li></ul></li><li><strong>CAN总线特性</strong>：CAN总线由两根信号线，CANH和CANL，没有时钟同步信号。所以CAN是一种异步通信方式。两根信号线的电压差CANH-CANL表示CAN总线的电平，与传输的逻辑信号1或0对应。对应于逻辑1的称为隐性（Recessive）电平，对应于逻辑0成为显性（Dominant）电平。<ul><li><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/%E9%80%BB%E8%BE%91%E7%94%B5%E5%B9%B3%E4%BF%A1%E5%8F%B7.png" alt="示意图"></li><li>在开环跟闭环的结构里面，隐形电平和显型电平对应的电压值略有不同</li><li>隐性电平表示逻辑1</li><li>显性电平表示逻辑0</li></ul></li><li><strong>CAN总线特点</strong>:<ul><li><strong>实时性：</strong> CAN总线具有优越的实时性能，适用于需要及时传输数据的应用，如汽车控制系统、工业自动化等。仲裁机制和帧优先级的设计保证了低延迟和可预测性。<strong>多主机系统：</strong> CAN支持多主机系统，多个节点可以同时发送和接收数据。<strong>差分信号传输：</strong> CAN使用差分信号传输，通过两个线路（CAN_H和CAN_L）之间的电压差来传递信息。这种差分传输方式提供了良好的抗干扰性能。<strong>仲裁机制：</strong> CAN总线采用非破坏性仲裁机制，通过比较消息标识符的优先级来决定哪个节点有权继续发送数据。这种机制确保了总线上数据传输的有序性，避免了冲突。<strong>广播通信：</strong> CAN总线采用广播通信方式，即发送的数据帧可以被总线上的所有节点接收。<strong>错误检测和处理：</strong>CAN总线具有强大的错误检测和处理机制。通过CRC检查和其他错误检测手段。<strong>多种帧类型：</strong>CAN总线上的节点没有地址的概念。CAN总线上的数据是以帧为单位传输的，帧又分为数据帧、遥控帧等多种帧类型，帧包含需要传输的数据或控制信息。<strong>特定标识符</strong>：每一个帧有一个标识符（Identifier，一下简称ID）。ID不是地址，它表示传输数据的类型，也可以用于总线仲裁时确定优先级。<strong>滤波特性：</strong>每个CAN节点都接收数据，但是可以对接收的帧根据ID进行过滤。<strong>半双工：</strong>CAN总线通信时半双工的，即总线不能同时发送和接收。在多个节点竞争总线进行发送时，通过ID的优先级进行仲裁。<strong>无时钟信号：</strong>CAN总线没有用于同步的时钟信号，所以需要规定CAN总线通信的波特率，所以节点都是用同样的波特率进行通信。</li></ul></li></ul><h2 id="4-3CAN通信的重点（各种帧）"><a href="#4-3CAN通信的重点（各种帧）" class="headerlink" title="4.3CAN通信的重点（各种帧）"></a>4.3CAN通信的重点（各种帧）</h2><ul><li><p>CAN网络中通信通过5种类型的帧进行的。</p><ul><li><p>5种帧类型以及用途如下表</p><ul><li><table><thead><tr><th align="left">帧类型</th><th align="left">帧用途</th></tr></thead><tbody><tr><td align="left">数据帧（Data frame）</td><td align="left">节点发送的包含ID和数据的帧，用于发送单元向接收单元传送数据的帧。</td></tr><tr><td align="left">遥控帧（Remote frame）</td><td align="left">节点向网络上的其他节点发出的某个ID的数据请求，发送节点收到遥控帧后就可以发送相应ID的数据帧</td></tr><tr><td align="left">错误帧（Error frame）</td><td align="left">节点检测出错误时，向其他节点发送的通知错误的帧</td></tr><tr><td align="left">过载帧（Overload frame）</td><td align="left">接收单元未做好接收数据的准备时发送的帧，发送节点收到过载帧后可以暂缓发送数据帧</td></tr><tr><td align="left">帧间空间（Inter-frame space）</td><td align="left">用于将数据帧、遥控帧与前后的帧分隔开的帧</td></tr></tbody></table></li></ul></li></ul></li><li><p><strong>标准格式数据帧</strong>：由7个段构成，如下图</p><ul><li><p><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/CAN%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="数据帧"></p><ul><li>帧起始:一位显性电平；</li><li>仲裁段禁止ID高7位全为隐性电平；</li><li>控制段，保留位r0必须以显性电平发送。DLC表示数据段的字节数</li><li>CRC段，根据多项式生成CRC校验码</li><li>ACK段：发送方的ACK发送2个位的隐性位，接收单元ACK，在ACK位发送一个显性位，通知接收正常</li><li>帧结束：7个隐性位构成。</li></ul></li></ul></li><li><p><strong>标准遥控帧</strong>：由6段构成，图示省略</p><ul><li>跟数据帧少了一个数据段<ul><li>遥控帧的RTR位为隐性位，没有数据段</li><li>遥控帧的数据长度码DLC以请求数据帧的数据长度码表示</li></ul></li></ul></li><li><p><strong>错误帧</strong>：用于在接收和发送消息时检测出错误通知错误的帧。错误帧由错误标志和错误界定符构成。如图所示</p><ul><li><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/%E9%94%99%E8%AF%AF%E5%B8%A7.png" alt="错误帧"><ul><li>主动错误标志：6 个位的显性位。</li><li>被动错误标志：6 个位的隐性位。</li><li>错误界定符由 8 个位的隐性位构成。</li></ul></li></ul></li><li><p><strong>过载帧</strong>：过载帧是用于接收单元通知其尚未完成接收准备的帧。过载帧由过载标志和过载界定符构成。</p><ul><li>过载标志：6 个位的显性位。过载标志的构成与主动错误标志的构成相同。过载界定符：8 个位的隐性位。过载界定符的构成与错误界定符的构成相同。</li></ul></li><li><p><strong>帧间隔</strong>：帧间隔是用于分隔数据帧和遥控帧的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。</p><ul><li>间隔：3 个位的隐性位。总线空闲：隐性电平，无长度限制（0 亦可）。本状态下，可视为总线空闲，要发送的单元可开始访问总线。延迟传送（发送暂时停止）：8 个位的隐性位。只在处于被动错误状态的单元刚发送一个消息后的帧间隔中包含的段。</li></ul></li></ul><h2 id="4-4CAN总线优先级及同步"><a href="#4-4CAN总线优先级及同步" class="headerlink" title="4.4CAN总线优先级及同步"></a>4.4CAN总线优先级及同步</h2><ul><li><p><strong>优先级决定</strong>：在总线空闲态，最先开始发送消息的单元获得发送权。多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的单元可继续发送。</p></li><li><p><strong>数据帧和遥控帧的优先级</strong>：具有相同 ID 的数据帧和遥控帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权，可继续发送。</p></li><li><p><strong>CAN通信错误种类</strong>：如下表</p><ul><li><img src="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/photo/CAN%E9%80%9A%E4%BF%A1%E9%94%99%E8%AF%AF.png" alt="错误表"></li></ul></li><li><p><strong>位时序</strong>：由发送单元在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为 4 段。同步段（SS）传播时间段（PTS）</p><p>相位缓冲段 1（PBS1）相位缓冲段 2（PBS2）这些段又由可称为 Time Quantum（以下称为 Tq）的最小时间单位构成。</p></li><li><p><strong>CAN通信同步的方法</strong>：CAN 协议的通信方法为 NRZ（Non-Return to Zero）方式。各个位的开头或者结尾都没有附加同步信号。发送单元以与位时序同步的方式开始发送数据。另外，接收单元根据总线上电平的变化进行同步并进行接收工作。但是，发送单元和接收单元存在的时钟频率误差及传输路径上的（电缆、驱动器等）相位延迟会引起同步偏差。因此接收单元通过硬件同步或者再同步的方法调整时序进行接收。</p></li></ul><h2 id="4-5CAN实例操作"><a href="#4-5CAN实例操作" class="headerlink" title="4.5CAN实例操作"></a>4.5CAN实例操作</h2><ul><li><p>基于stm32的CAN通信</p><ul><li><p>CAN 发送流程为：程序选择 1 个空置的邮箱（TME&#x3D;1）→设置标识符（ID），数据长度和 发送数据→设置 CAN_TIxR 的 TXRQ 位为 1，请求发送→邮箱挂号（等待成为最高优先级）→ 预定发送（等待总线空闲）→发送→邮箱空置。</p></li><li><p>CAN 接收到的有效报文，被存储在 3 级邮箱深度的 FIFO 中。CAN 接收流程为：FIFO 空→收到有效报文→挂号1（存入 FIFO 的一个邮箱，这个由硬件 控制，我们不需要理会）→收到有效报文→挂号2→收到有效报文→挂号_3→收到有效报文溢 出。</p></li><li><p>重点是构造发送的数据消息，跟接收的数据消息配置。</p></li><li><p>并且配置的时候有多种模式可选择，比如回环模式和正常模式</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*HAL库配置CAN控制器,简略代码，列出关键,以CAN1为例子*/</span><br>CAN_HandleTypeDef   g_canx_handler;     <span class="hljs-comment">/* CANx句柄 */</span><br>CAN_TxHeaderTypeDef g_canx_txheader;    <span class="hljs-comment">/* 发送参数句柄 */</span><br>CAN_RxHeaderTypeDef g_canx_rxheader;    <span class="hljs-comment">/* 接收参数句柄 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">can_init</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> tsjw, <span class="hljs-type">uint32_t</span> tbs2, <span class="hljs-type">uint32_t</span> tbs1, <span class="hljs-type">uint16_t</span> brp, <span class="hljs-type">uint32_t</span> mode)</span><br>&#123;<br>    <span class="hljs-comment">/*CAN的各种配置*/</span><br>    ...代码省略<br>    HAL_CAN_Init(&amp;g_canx_handler);<span class="hljs-comment">//HAL_CAN_Init()-&gt;内部调用HAL_CAN_MspInit()</span><br>    <span class="hljs-comment">/*配置CAN的过滤操作*/</span><br>    CAN_FilterTypeDef sFilterConfig;<br>    ...配置过程省略<br>    HAL_CAN_ConfigFilter(&amp;g_canx_handler, &amp;sFilterConfig)<br>    <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_CAN_MspInit</span><span class="hljs-params">(CAN_HandleTypeDef *hcan)</span><span class="hljs-comment">//用来配置CAN相关的引脚的状态</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (CAN1 == hcan-&gt;Instance)<br>    &#123;<br>        __HAL_RCC_GPIOX_CLK_ENABLE();<br>        __HAL_RCC_CAN1_CLK_ENABLE();<br>        GPIO_InitTypeDef gpio_initure;<br>        ...具体配置省略<br>        HAL_GPIO_Init(GPIOX, &amp;gpio_initure);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">can_send_msg</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> id, <span class="hljs-type">uint8_t</span> *msg, <span class="hljs-type">uint8_t</span> len)</span><br>&#123;<br>      <span class="hljs-type">uint32_t</span> TxMailbox = CAN_TX_MAILBOX0;<br>    <br>      g_canx_txheader.StdId = id;         <span class="hljs-comment">/* 标准标识符 */</span><br>      g_canx_txheader.ExtId = id;         <span class="hljs-comment">/* 扩展标识符(29位) 标准标识符情况下，该成员无效*/</span><br>      g_canx_txheader.IDE = CAN_ID_STD;   <span class="hljs-comment">/* 使用标准标识符 */</span><br>      g_canx_txheader.RTR = CAN_RTR_DATA; <span class="hljs-comment">/* 数据帧 */</span><br>      g_canx_txheader.DLC = len;<br><br>  <span class="hljs-keyword">if</span> (HAL_CAN_AddTxMessage(&amp;g_canx_handler, &amp;g_canx_txheader, msg, &amp;TxMailbox) != HAL_OK) <span class="hljs-comment">/* 发送消息 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">while</span> (HAL_CAN_GetTxMailboxesFreeLevel(&amp;g_canx_handler) != <span class="hljs-number">3</span>); <span class="hljs-comment">/* 等待发送完成,所有邮箱(有三个邮箱)为空 */</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">can_receive_msg</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> id, <span class="hljs-type">uint8_t</span> *buf)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (HAL_CAN_GetRxFifoFillLevel(&amp;g_canx_handler, CAN_RX_FIFO0) == <span class="hljs-number">0</span>)     <span class="hljs-comment">/* 没有接收到数据 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (HAL_CAN_GetRxMessage(&amp;g_canx_handler, CAN_RX_FIFO0, &amp;g_canx_rxheader, buf) != HAL_OK)  <span class="hljs-comment">/* 读取数据 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (g_canx_rxheader.StdId!= id || g_canx_rxheader.IDE != CAN_ID_STD || g_canx_rxheader.RTR != CAN_RTR_DATA)       <span class="hljs-comment">/* 接收到的ID不对 / 不是标准帧 / 不是数据帧 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>  &#125;<br><br>  <span class="hljs-keyword">return</span> g_canx_rxheader.DLC;<br>&#125;<br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
