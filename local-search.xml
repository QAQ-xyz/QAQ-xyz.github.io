<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>rttread移植</title>
    <link href="/2024/12/10/rttread%E7%A7%BB%E6%A4%8D/"/>
    <url>/2024/12/10/rttread%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1、rtthread介绍"><a href="#1、rtthread介绍" class="headerlink" title="1、rtthread介绍"></a>1、rtthread介绍</h1><ul><li>RT-Thread 是一款完全由国内团队开发维护的嵌入式实时操作系统（RTOS），具有完全的自主知识产权。经过 16 个年头的沉淀，伴随着物联网的兴起，它正演变成一个功能强大、组件丰富的物联网操作系统。</li><li>rtthread官网提供了很多个版本，针对于不同的应用情况：标准版、nano版、smart版本。我们移植的是nano版本，是一个去除了很多第三方组件的只保留操作系统的内核基本功能：线程管理、线程间通信、时钟管理、中断管理、内存管理。</li><li>支持的CPU架构有：ARM架构下的Cortex M0&#x2F; M3&#x2F; M4&#x2F; M7 等；RISC-V架构及其他。</li><li>nano版本源码也可以保留了finsh组件，让rtthread也可以像linux那样有终端界面，通过命令行来进行相应的命令操作。</li></ul><h1 id="2、rtthread源码"><a href="#2、rtthread源码" class="headerlink" title="2、rtthread源码"></a>2、rtthread源码</h1><h2 id="2-1nano版本的源码获取"><a href="#2-1nano版本的源码获取" class="headerlink" title="2&#x2F;1nano版本的源码获取"></a>2&#x2F;1nano版本的源码获取</h2><ul><li>进入官网下载界面选择nano版本下载;<a href="https://www.rt-thread.org/download.html#download-rt-thread-nano">rt-thread.org&#x2F;download.html#download-rt-thread-nano</a></li></ul><h2 id="2-2源码目录及文件分析"><a href="#2-2源码目录及文件分析" class="headerlink" title="2&#x2F;2源码目录及文件分析"></a>2&#x2F;2源码目录及文件分析</h2><ul><li>源码目录</li></ul><p><img src="/./../photo/rtt%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95.png"></p><ul><li>重点rtt内核相关文件</li></ul><p><img src="/./../photo/rttsrc%E7%9B%AE%E5%BD%95.png"></p><ul><li><p>需要移植的文件</p><ul><li><p><strong>板级支持包和rtt配置文件：bsp文件夹下面的board.c和rtconfig.h</strong></p></li><li><p><strong>可选的第三方组件；components文件夹下面的finsh组件和device驱动框架</strong></p></li><li><p><strong>include文件夹所有内容</strong></p></li><li><p><strong>libcpu文件下对应的架构文件；这里使用的是stm32h743vit6所以要移植该文件夹下的arm-&gt;cortex-m7文件夹下面的所有内容</strong></p></li><li><p><strong>src文件夹下所有内核源码</strong></p></li></ul></li></ul><h1 id="3、具体移植细节"><a href="#3、具体移植细节" class="headerlink" title="3、具体移植细节"></a>3、具体移植细节</h1><h2 id="3-1基于gcc工程的移植"><a href="#3-1基于gcc工程的移植" class="headerlink" title="3&#x2F;1基于gcc工程的移植"></a>3&#x2F;1基于gcc工程的移植</h2><ul><li>按照如下cubemx配置一个简单的gcc工程，参考另外一篇cubemx搭建工程文章。这里主要配置一些led引脚和串口1。串口1来作为finsh组件终端通信。另外这里使用的是stm32h7系列的，我们开启数据cache和指令cache</li></ul><p><img src="/./../photo/h743cache.png"></p><ul><li>stm32h743有2M的flash和1M的RAM所以堆栈可以设置大些。然后生成Makefile工程</li></ul><p><img src="/./../photo/743%E5%A0%86%E6%A0%88%E8%AE%BE%E7%BD%AE.png"></p><ul><li>创建好的工程目录如下。</li></ul><p><img src="/./../photo/743rtt-gcc.png"></p><ul><li>在目录中创建一个rtthread目录，然后将下载的nano源码全都拷贝过来，并且删除一些不必要的文件。</li></ul><p><img src="/./../photo/rtt%E5%88%A0%E9%99%A41.png"></p><p><img src="/./../photo/rtt%E5%88%A0%E9%99%A42.png"></p><p><img src="/./../photo/rtt%E5%88%A0%E9%99%A43.png"></p><p><img src="/./../photo/rtt%E5%88%A0%E9%99%A44.png"></p><ul><li>到上面，需要的文件都已经移植好了，然后修改工程里面的Makefile文件，将刚刚添加进来的c文件和h文件包含到编译依赖里面；用vscode打开刚刚新建的工程。修改Makefile文件内容。</li></ul><p><img src="/./../photo/rttmk1.png"></p><p><img src="/./../photo/rttmk2.png"></p><p><img src="/./../photo/rttmk3.png"></p><p><img src="/./../photo/rttmk4.png"></p><ul><li>然后屏蔽掉芯片原厂提供的中断文件中的三个中断。void HardFault_Handler(void)；void PendSV_Handler(void)；void SysTick_Handler(void)；因为rtthread内核实现了这三个函数。这三个函数一般在it.c文件里面定义的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief This function handles Hard fault interrupt.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HardFault_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">/* USER CODE BEGIN HardFault_IRQn 0 */</span><br><br>  <span class="hljs-comment">/* USER CODE END HardFault_IRQn 0 */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-comment">/* USER CODE BEGIN W1_HardFault_IRQn 0 */</span><br>    <span class="hljs-comment">/* USER CODE END W1_HardFault_IRQn 0 */</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief This function handles Pendable request for system service.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PendSV_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief This function handles System tick timer.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br>  HAL_IncTick();<br><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>gcc编译的话还要修改启动文件的入口函数，为什么要修改呢？修改启动文件；</li></ul><p><img src="/./../photo/rttgcc%E5%85%A5%E5%8F%A3.png"></p><p><img src="/./../photo/rttgcc%E5%90%AF%E5%8A%A8.png"></p><ul><li>rtthread启动流程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C">entry()-&gt;rtthread_startup()-&gt;<br>&#123;<br>    rt_hw_interrupt_disable();<br><br>    <span class="hljs-comment">/* board level initialization</span><br><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> please initialize heap inside board initialization.</span><br><span class="hljs-comment">     */</span><br>    rt_hw_board_init();-&gt;板级初始化<br><br>    <span class="hljs-comment">/* show RT-Thread version */</span><br>    rt_show_version();-&gt;这里的先实现串口打印功能<br><br>    <span class="hljs-comment">/* timer system initialization */</span><br>    rt_system_timer_init();<br><br>    <span class="hljs-comment">/* scheduler system initialization */</span><br>    rt_system_scheduler_init();<br><br>    <span class="hljs-comment">/* create init_thread */</span><br>    rt_application_init();-&gt;这个里面创建了一个线程；而这个线程的线程函数会调用main函数<br><br>    <span class="hljs-comment">/* timer thread initialization */</span><br>    rt_system_timer_thread_init();<br><br>    <span class="hljs-comment">/* idle thread initialization */</span><br>    rt_thread_idle_init();<br><br>    <span class="hljs-comment">/* start scheduler */</span><br>    rt_system_scheduler_start();-&gt;这里启动了调度器后，就会进入刚刚创建这个线程函数<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>至此rtthread的nano版本已经移植完了，可以在main函数里面创建不同的线程了；</li></ul><h2 id="3-2移植第三方finsh组件，来实现命令行交互"><a href="#3-2移植第三方finsh组件，来实现命令行交互" class="headerlink" title="3&#x2F;2移植第三方finsh组件，来实现命令行交互"></a>3&#x2F;2移植第三方finsh组件，来实现命令行交互</h2><ul><li><p>修改makefile，将rtthread&#x2F;components&#x2F;finsh里面的c文件和h文件都添加进编译文件里面。具体看上面怎么添加的，同理添加。</p></li><li><p>修改链接文件ld，在text段里面添加虚线之内的代码</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs ld">.text :<br>  &#123;<br>    . = ALIGN(4);<br>    *(.text)           /* .text sections (code) */<br>    *(.text*)          /* .text* sections (code) */<br>    *(.glue_7)         /* glue arm to thumb code */<br>    *(.glue_7t)        /* glue thumb to arm code */<br>    *(.eh_frame)<br><br>    KEEP (*(.init))<br>    KEEP (*(.fini))<br><br>    /*RT-thread GCC Add start---------------------------------*/    <br>    /* section information for finsh shell */<br>    . = ALIGN(4);<br>    __fsymtab_start = .;<br>    KEEP(*(FSymTab))<br>    __fsymtab_end = .;<br>    . = ALIGN(4);<br>    __vsymtab_start = .;<br>    KEEP(*(VSymTab))<br>    __vsymtab_end = .;<br>    . = ALIGN(4);<br><br>    /* section information for initial. */<br>    . = ALIGN(4);<br>    __rt_init_start = .;<br>    KEEP(*(SORT(.rti_fn*)))<br>    __rt_init_end = .;<br>    . = ALIGN(4);<br>    /* RT-thread GCC Add end ------------------------------------*/<br><br>    . = ALIGN(4);<br>    _etext = .;        /* define a global symbols at end of code */<br>  &#125; &gt;FLASH<br></code></pre></td></tr></table></figure><ul><li>实现两个函数，这两个函数都是弱定义的，即rtthread里面终端接收和发送函数。在finsh_port.c文件里面实现以下两个函数。具体还要包含相应的uart文件，这里使用的是串口1；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> <span class="hljs-title function_">rt_hw_console_getchar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> ch = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_RXNE) != RESET)<br>    &#123;<br><br>        ch = huart1.Instance-&gt;RDR &amp; <span class="hljs-number">0xff</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_ORE) != RESET)<br>        &#123;<br>            __HAL_UART_CLEAR_OREFLAG(&amp;huart1);<br>        &#125;<br>        rt_thread_mdelay(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ch;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_console_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-type">rt_size_t</span> i = <span class="hljs-number">0</span>, size = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;\r&#x27;</span>;<br><br>    __HAL_UNLOCK(&amp;huart1);<br><br>    size = rt_strlen(str);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (*(str + i) == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        &#123;<br>            HAL_UART_Transmit(&amp;huart1, (<span class="hljs-type">uint8_t</span> *)&amp;a, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>        HAL_UART_Transmit(&amp;huart1, (<span class="hljs-type">uint8_t</span> *)(str + i), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在配置文件rtconfig.h里面添加包含finsh组件的配置文件finsh_config.h;</li></ul><p><img src="/./../photo/rttfinsh1.png"></p><ul><li>屏蔽重复定义的宏，这样防止出现警告。有些在finsh_config.h里面已经宏定义过了。屏蔽掉rtconfig.h里面的相关内容。</li></ul><p><img src="/./../photo/rttfinsh2.png"></p><ul><li>第三方组件也移植好了，在终端make。生成hex文件，下载进cpu内。打开Mobaxterm建立一个串口通信。连接好串口，然后打开终端。复位cpu，可以在终端看到如下，表示移植成功。</li></ul><p><img src="/./../photo/rttfinshxterm.png" alt=""></p><ul><li>finsh常用的内置命令如下</li></ul><p><img src="/./../photo/finshcmd.png" alt=""></p><ul><li>其他kile以及IAR编译道理相同，更加简单，一样只需要添加相应c文件到工程里面，将头文件添加到IDE的搜索路径。</li></ul><h1 id="4、rtthread常用的API"><a href="#4、rtthread常用的API" class="headerlink" title="4、rtthread常用的API"></a>4、rtthread常用的API</h1><ul><li>线程管理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*线程动态创建函数*/</span><br><span class="hljs-type">rt_thread_t</span> <span class="hljs-title function_">rt_thread_create</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * name,<span class="hljs-comment">//线程的名称</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span>(*)(<span class="hljs-type">void</span> *parameter) entry,<span class="hljs-comment">//线程的入口函数</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> * parameter,<span class="hljs-comment">//入口函数的传入参数</span></span><br><span class="hljs-params">    <span class="hljs-type">rt_uint32_t</span> stack_size,<span class="hljs-comment">//线程堆栈的大小</span></span><br><span class="hljs-params">    <span class="hljs-type">rt_uint8_t</span> priority,<span class="hljs-comment">//线程的优先级</span></span><br><span class="hljs-params">    <span class="hljs-type">rt_uint32_t</span> tick <span class="hljs-comment">//线程的时间片大小。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。</span></span><br><span class="hljs-params">)</span><br>    <br><span class="hljs-comment">/*线程启动函数函数*/</span>   <br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_startup</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span><span class="hljs-comment">//参数是线程的句柄</span><br><br><span class="hljs-comment">/*线程删除函数*/</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delete</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span><br>    <br><span class="hljs-comment">/*线程挂起函数*/</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_suspend</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span><br><br><span class="hljs-comment">/*线程恢复函数*/</span>   <br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_resume</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>    <br>    <br><span class="hljs-comment">/*线程延时相关函数函数*/</span> <br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_sleep</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delay</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_mdelay</span><span class="hljs-params">(<span class="hljs-type">rt_int32_t</span> ms)</span><br></code></pre></td></tr></table></figure><ul><li>软件定时器相关函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*动态创建软件定时器*/</span><br><br><span class="hljs-type">rt_timer_t</span> <span class="hljs-title function_">rt_timer_create</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * name,<span class="hljs-comment">//定时器名称</span></span><br><span class="hljs-params"><span class="hljs-type">void</span>(*)(<span class="hljs-type">void</span> *parameter) timeout,<span class="hljs-comment">//超时回调函数</span></span><br><span class="hljs-params"><span class="hljs-type">void</span> * parameter,<span class="hljs-comment">//超时回调函数的传入参数</span></span><br><span class="hljs-params"><span class="hljs-type">rt_tick_t</span> time,<span class="hljs-comment">//定时超时时间</span></span><br><span class="hljs-params"><span class="hljs-type">rt_uint8_t</span> flag <span class="hljs-comment">//定时器的标志位</span></span><br><span class="hljs-params">)</span><br><br><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_delete</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_start</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_stop</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span><br></code></pre></td></tr></table></figure><ul><li>线程通信函数：这里有信号量、互斥量、事件、邮箱、消息队列等等。可以参考官网编程手册</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS移植</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于FreeRtos+STM32智能车载终端系统</title>
    <link href="/2023/12/05/%E5%9F%BA%E4%BA%8EFreeRtos-STM32%E6%99%BA%E8%83%BD%E8%BD%A6%E8%BD%BD%E7%BB%88%E7%AB%AF%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/12/05/%E5%9F%BA%E4%BA%8EFreeRtos-STM32%E6%99%BA%E8%83%BD%E8%BD%A6%E8%BD%BD%E7%BB%88%E7%AB%AF%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="1、项目概述"><a href="#1、项目概述" class="headerlink" title="1、项目概述"></a>1、项目概述</h1><p>​基于freertos实时操作系统加stm32完成一个智能车载终端系统。主要实现功能：车载娱乐播放、车内温湿度记录、模拟汽车启动，加速，减速；语音控制、黑匣子以及录音功能、实现人机交互，移动互联进行车内数据上云，界面设计。</p><h1 id="2、硬件目录和功能"><a href="#2、硬件目录和功能" class="headerlink" title="2、硬件目录和功能"></a>2、硬件目录和功能</h1><table><thead><tr><th align="center">器件</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">stm32f103zet6</td><td align="center">主控CPU</td></tr><tr><td align="center">VS1053模块</td><td align="center">音频解码以及录音</td></tr><tr><td align="center">DS18B20模块</td><td align="center">测量车内温度</td></tr><tr><td align="center">对射光电传感器</td><td align="center">测量车速</td></tr><tr><td align="center">AT24C64模块</td><td align="center">黑匣子存储功能</td></tr><tr><td align="center">esp8266</td><td align="center">wifi互联功能</td></tr><tr><td align="center">LD3320模块</td><td align="center">语音识别</td></tr><tr><td align="center">TFT串口屏幕</td><td align="center">车载终端界面</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>stm32mp157启动及裸机程序处理</title>
    <link href="/2023/06/16/stm32mp157%E5%90%AF%E5%8A%A8%E5%8F%8A%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%A4%84%E7%90%86/"/>
    <url>/2023/06/16/stm32mp157%E5%90%AF%E5%8A%A8%E5%8F%8A%E8%A3%B8%E6%9C%BA%E7%A8%8B%E5%BA%8F%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="1、stm32mp157启动方式"><a href="#1、stm32mp157启动方式" class="headerlink" title="1、stm32mp157启动方式"></a>1、stm32mp157启动方式</h1><p>​相对于MCU的启动方式，MPU的启动要复杂很多。对于MPU的芯片来说，启动方式都是大差不差，大致如下进行；看似先从启动bootloader，但是实际这个bootloader也需要运行的地方。所以大部分的芯片内部都有一小段存放厂商写好的一个裸机程序放在ROM里面，这里的ROM不是指的flash之类的。而是芯片内部的ROM，然后还有一个内部的RAM，这个不是DDR。</p><p>​stm32mp1的启动方式有以下几种，根据芯片的BOOT0和BOOT1和BOOT2引脚来设置。</p>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FAT文件系统移植</title>
    <link href="/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/"/>
    <url>/2023/06/12/FAT%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1、FAT文件系统简介"><a href="#1、FAT文件系统简介" class="headerlink" title="1、FAT文件系统简介"></a>1、FAT文件系统简介</h1><ul><li><p>FAT是一种文件格式，而FATFS是一个文件系统，为什么要文件系统呢？文件系统可以帮助我们更好的管理存储空间，另外让我们操作文件更加的简便，屏蔽掉具体实现细节，提供API函数供我们来读写，控制文件。FATFS是一个完全用C语言（ANSIC C89）编写的专为嵌入式设备设计的小型文件系统，可以很好的兼容各种硬件平台，并且支持RTOS，支持挂载最多十个存储设备。</p></li><li><p>FATFS的层次结构如下：</p><p><img src="/./../photo/fatfs%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE.png"></p></li></ul><h1 id="2、移植准备"><a href="#2、移植准备" class="headerlink" title="2、移植准备"></a>2、移植准备</h1><h2 id="2-1移植文件下载及源码介绍"><a href="#2-1移植文件下载及源码介绍" class="headerlink" title="2&#x2F;1移植文件下载及源码介绍"></a>2&#x2F;1移植文件下载及源码介绍</h2><ul><li><p>官网下载fatfs的源码；官网链接:<a href="http://elm-chan.org/fsw/ff/00index_e.html;%E5%9C%A8Resources%E9%87%8C%E9%9D%A2%E4%B8%8B%E8%BD%BD%E6%BA%90%E4%BB%A3%E7%A0%81%EF%BC%9B%E5%A6%82%E5%9B%BE%EF%BC%9A">http://elm-chan.org/fsw/ff/00index_e.html;在Resources里面下载源代码；如图：</a></p><p><img src="/./../photo/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%98%E7%BD%91.png"></p></li><li><p>下载后解压源码目录如下：</p><p><img src="/./../photo/fat%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95.png"></p></li><li><p>sourece目录下源码作用</p><p><img src="/./../photo/fatfs%E8%B5%84%E6%BA%90%E7%9B%AE%E5%BD%95.png"></p></li></ul><h2 id="2-2移植具体细节修改"><a href="#2-2移植具体细节修改" class="headerlink" title="2&#x2F;2移植具体细节修改"></a>2&#x2F;2移植具体细节修改</h2><ol><li><p>修改ffconf.h文件来配置需要的功能</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_MKFS1 /开启定时格式化</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_FASTSEEK1 /使能快速定位</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_LABEL1 /使能磁盘名称读取和设置</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_STRFUNC1 /使能支持字符串操作</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_CODE_PAGE936 /语言设置为GBK</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_USE_LFN3 /支持长文件名，3表示长文件名存在堆区，通过ff_memalloc来动态分配</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FF_VOLUMES      2 /表示支持的逻辑存储设备数，1到10之间</span><br><span class="hljs-comment">/*这些是基础配置，更多看具体文件内说明，按需裁剪*/</span><br></code></pre></td></tr></table></figure></li><li><p>修改diskio.c文件里面的具体操作函数,修改格式可以按照diskio.c里面的格式来修改</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">DSTATUS <span class="hljs-title function_">disk_initialize</span> <span class="hljs-params">( BYTE pdrv)</span> /pdrv是逻辑块号<br>&#123;<br>    /相关存储设备初始化函数/<br>&#125;<br>f_mount-&gt;disk_initialize<br>    <br>DSTATUS <span class="hljs-title function_">disk_status</span> <span class="hljs-params">(BYTE pdrv)</span> <br>&#123;<br>    /读取设备状态相关的函数/<br>&#125;<br><br>DRESULT <span class="hljs-title function_">disk_read</span> <span class="hljs-params">(BYTE pdrv, BYTE *buff, DWORD sector, UINT count)</span><br>&#123;<br>    /具体的存储芯片读写函数/<br>&#125;<br>f_read-&gt;disk_read<br>    <br>DRESULT <span class="hljs-title function_">disk_write</span> <span class="hljs-params">( BYTE pdrv, <span class="hljs-type">const</span> BYTE *buff, DWORD sector, UINT count)</span><br>&#123;<br>    /具体的写函数/<br>&#125;<br><br>f_write-&gt;disk_write<br><br>DRESULT <span class="hljs-title function_">disk_ioctl</span> <span class="hljs-params">(BYTE pdrv, BYTE cmd, <span class="hljs-type">void</span> *buff)</span><br>&#123;<br>    /具体的命令控制函数/<br>&#125;<br>f_ioctl-&gt;disk_ioctl<br></code></pre></td></tr></table></figure></li></ol><h1 id="3、实例操作，挂载SD卡作为文件系统"><a href="#3、实例操作，挂载SD卡作为文件系统" class="headerlink" title="3、实例操作，挂载SD卡作为文件系统"></a>3、实例操作，挂载SD卡作为文件系统</h1><h2 id="3-1用cubemx快速生成SDMMC操作SD卡工程"><a href="#3-1用cubemx快速生成SDMMC操作SD卡工程" class="headerlink" title="3&#x2F;1用cubemx快速生成SDMMC操作SD卡工程"></a>3&#x2F;1用cubemx快速生成SDMMC操作SD卡工程</h2><ul><li><p>用cubemx快速生成一个模版文件；新建一个cubemx的工程，并且选取具体的芯片型号</p><p><img src="/./../photo/cubemx%E9%80%89%E6%8B%A9.png"></p></li><li><p>我选用的是stm32h743vit6，具体配置如下</p><p><img src="/./../photo/743%E6%97%B6%E9%92%9F%E9%80%89%E6%8B%A9.png"></p></li><li><p>时钟树配置各种外设设置</p><p><img src="/./../photo/743%E6%97%B6%E9%92%9F%E6%A0%91%E9%85%8D%E7%BD%AE.png"></p></li><li><p>配置串口一为PC通信串口，根据需求开启DMA和中断，配置波特率等等；</p><p><img src="/./../photo/743%E4%B8%B2%E5%8F%A3%E9%85%8D%E7%BD%AE.png"></p><p><img src="/./../photo/743%E6%B3%A2%E7%89%B9%E7%8E%87%E8%AE%BE%E7%BD%AE.png"></p></li><li><p>配置SDMMC参数</p><p><img src="/./../photo/743SDMMC%E9%85%8D%E7%BD%AE.png"></p></li><li><p>设置Project Manager。这里我是生成makefile工程</p><p><img src="/./../photo/743%E9%A1%B9%E7%9B%AE.png"></p><p><img src="/./../photo/743%E9%A1%B9%E7%9B%AE1.png"></p></li><li><p>用vscode打开整个生成的项目文件夹</p><p>首先进行串口一重定向，来实现c标准库里面的printf函数；找到syscalls.c文件，修改里面的_io_putchar函数；如图所示：</p><p><img src="/./../photo/743%E4%B8%B2%E5%8F%A3%E9%87%8D%E5%AE%9A%E5%90%91.png"></p><p>SDMMC初始化程序在sdmmc.c文件中,我使用的是SDMMC1这个控制器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*部分代码*/</span><br>SD_HandleTypeDef hsd1;<br><span class="hljs-type">void</span> <span class="hljs-title function_">MX_SDMMC1_SD_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  hsd1.Instance = SDMMC1;<br>  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;<br>  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;<br>  hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;<br>  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_ENABLE;<br>  hsd1.Init.ClockDiv = <span class="hljs-number">3</span>;<br>  <span class="hljs-keyword">if</span> (HAL_SD_Init(&amp;hsd1) != HAL_OK)<br>  &#123;<br>    Error_Handler();<br>  &#125;<br>&#125;<span class="hljs-comment">//SDMMC初始程序；HAL_SD_Init这个函数内部会调用HAL_SD_MspInit；因此在Msp函数内进行相关引脚初始化</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_SD_MspInit</span><span class="hljs-params">(SD_HandleTypeDef* sdHandle)</span><br>&#123;<br>  GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;<br>  RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = &#123;<span class="hljs-number">0</span>&#125;;<br>  <span class="hljs-keyword">if</span>(sdHandle-&gt;Instance==SDMMC1)<br>  &#123;<br><br>    PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SDMMC;<br>    PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;<br>    <span class="hljs-keyword">if</span> (HAL_RCCEx_PeriphCLKConfig(&amp;PeriphClkInitStruct) != HAL_OK)<br>    &#123;<br>      Error_Handler();<br>    &#125;<br>    __HAL_RCC_SDMMC1_CLK_ENABLE();<br>    __HAL_RCC_GPIOC_CLK_ENABLE();<br>    __HAL_RCC_GPIOD_CLK_ENABLE();<br>    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11<br>                          |GPIO_PIN_12;<br>    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;<br>    GPIO_InitStruct.Pull = GPIO_PULLUP;<br>    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<br>    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;<br>    HAL_GPIO_Init(GPIOC, &amp;GPIO_InitStruct);<br><br>    GPIO_InitStruct.Pin = GPIO_PIN_2;<br>    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;<br>    GPIO_InitStruct.Pull = GPIO_PULLUP;<br>    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;<br>    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO1;<br>    HAL_GPIO_Init(GPIOD, &amp;GPIO_InitStruct);<br><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>HAL库提供相关SD卡操作函数；注意SD卡读写操作都是以块为单位来操作的；SD卡本质是nand flash，所以不能把数据从0写成1，只能先擦除；先擦除，再写入。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//阻塞方式读取和写入函数；</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_ReadBlocks</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd, <span class="hljs-type">uint32_t</span> NumberOfBlocks,<span class="hljs-type">uint32_t</span> Timeout)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_WriteBlocks</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd,<span class="hljs-type">uint32_t</span> NumberOfBlocks, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_Erase</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">uint32_t</span> BlockStartAdd, <span class="hljs-type">uint32_t</span> BlockEndAdd)</span>;<span class="hljs-comment">//扇区擦除函数</span><br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_ReadBlocks_IT</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd,<span class="hljs-type">uint32_t</span> NumberOfBlocks)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_WriteBlocks_IT</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd,<span class="hljs-type">uint32_t</span> NumberOfBlocks)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_ReadBlocks_DMA</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd,<span class="hljs-type">uint32_t</span> NumberOfBlocks)</span>;<br><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_SD_WriteBlocks_DMA</span><span class="hljs-params">(SD_HandleTypeDef *hsd, <span class="hljs-type">const</span> <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint32_t</span> BlockAdd, <span class="hljs-type">uint32_t</span> NumberOfBlocks)</span>;<br></code></pre></td></tr></table></figure></li><li><p>写个程序测试一下，先擦除SD卡块0，擦除后，先读取看一下擦除后内容是什么；再往块0里面写入0xAB;再读取看一下。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">SD_test</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> BlockStartAdd, <span class="hljs-type">uint32_t</span> BlockEndAdd)</span><br>&#123; <br>  <span class="hljs-type">uint32_t</span> address=<span class="hljs-number">0</span>;<br>  <span class="hljs-type">uint8_t</span> rxbuf[<span class="hljs-number">512</span>];<br>  <span class="hljs-type">uint8_t</span> txbuf[<span class="hljs-number">512</span>];<br>  <span class="hljs-built_in">memset</span>(rxbuf,<span class="hljs-number">0</span>,<span class="hljs-keyword">sizeof</span>(rxbuf));<br>  <span class="hljs-built_in">memset</span>(txbuf,<span class="hljs-number">0xAB</span>,<span class="hljs-keyword">sizeof</span>(txbuf));<br>  HAL_StatusTypeDef status =HAL_SD_Erase(&amp;hsd1,BlockStartAdd,BlockEndAdd);<br>  <span class="hljs-keyword">if</span> (status == HAL_OK)<br>   &#123;<br>      <span class="hljs-keyword">while</span> (HAL_SD_GetCardState(&amp;hsd1) != HAL_SD_CARD_TRANSFER) &#123;&#125;<br>   &#125;<br>   <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;擦除完成,等待两秒开始读取数据\r\n&quot;</span>);<br>   HAL_Delay(<span class="hljs-number">2000</span>);<br>  status=ReadSDCard(address,rxbuf,<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (status == HAL_OK)<br>   &#123;<br>      <span class="hljs-keyword">while</span> (HAL_SD_GetCardState(&amp;hsd1) != HAL_SD_CARD_TRANSFER) &#123;&#125;<br>   &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">512</span>;i++)<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;擦除后扇区读到的数据为:0x%X\r\n&quot;</span>,rxbuf[i]);<br>   &#125;<br>  HAL_Delay(<span class="hljs-number">5000</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;开始向擦除扇区写入数据&quot;</span>);<br>  status=WriteSDCard(address,txbuf,<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (status == HAL_OK)<br>   &#123;<br>      <span class="hljs-keyword">while</span> (HAL_SD_GetCardState(&amp;hsd1) != HAL_SD_CARD_TRANSFER) &#123;&#125;<br>   &#125;<br>  HAL_Delay(<span class="hljs-number">2000</span>);<br>  <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写入完成,等待两秒开始读取数据\r\n&quot;</span>); <br>  status=ReadSDCard(address,rxbuf,<span class="hljs-number">1</span>);<br>  <span class="hljs-keyword">if</span> (status == HAL_OK)<br>   &#123;<br>      <span class="hljs-keyword">while</span> (HAL_SD_GetCardState(&amp;hsd1) != HAL_SD_CARD_TRANSFER) &#123;&#125;<br>   &#125;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-type">uint16_t</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">512</span>;i++)<br>   &#123;<br>      <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;从新写入后扇区读到的数据为:0x%X\r\n&quot;</span>,rxbuf[i]);<br>   &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在main函数里面调用，打开串口调试助手，选择相应端口。可以看到打印信息</p><p><img src="/./../photo/743SD%E4%B8%B2%E5%8F%A3%E6%B5%8B%E8%AF%95.png"></p><p><img src="/./../photo/743SD%E4%B8%B2%E5%8F%A3%E6%B5%8B%E8%AF%951.png"></p></li></ul><h2 id="3-2按照上述移植方法，来修改相应文件"><a href="#3-2按照上述移植方法，来修改相应文件" class="headerlink" title="3&#x2F;2按照上述移植方法，来修改相应文件"></a>3&#x2F;2按照上述移植方法，来修改相应文件</h2><ul><li><p>在cubemx来生成文件系统，按照如下配置，来增加FATfs系统。在上述SDMMC配置情况下，添加如下配置；</p><p><img src="/./../photo/743fatfs%E9%85%8D%E7%BD%AE.png"></p><p>fatfs要求有一个SD卡检测引脚，可以任选引脚作为输入，然后接地就行。</p><p><img src="/./../photo/743fat%E8%BE%93%E5%85%A5%E6%A3%80%E6%B5%8B%E5%BC%95%E8%84%9A.png"></p><p>在挂载的时候，如果出现FR_DISK_ERR这个错误，那就开启SDMMC&#x2F;SDIO的硬件流控。</p><p><img src="/./../photo/743sdmmc%E7%A1%AC%E4%BB%B6%E6%B5%81%E6%8E%A7%E5%BC%80%E5%90%AF.png"></p></li><li><p>生成代码后，修改源码，来实现上述需要的函数，打开diskio.c这个文件里面可以看到，disk_initialize、disk_status、disk_read、disk_disk_write、disk_ioctl这些函数都是调用某个结构体里面的指针数组所指向的函数；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs C">DSTATUS <span class="hljs-title function_">disk_initialize</span> <span class="hljs-params">(</span><br><span class="hljs-params">BYTE pdrv<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span><br><span class="hljs-params">)</span><br>&#123;<br>  DSTATUS stat = RES_OK;<br><br>  <span class="hljs-keyword">if</span>(disk.is_initialized[pdrv] == <span class="hljs-number">0</span>)<br>  &#123;<br>    stat = disk.drv[pdrv]-&gt;disk_initialize(disk.lun[pdrv]);<br>    <span class="hljs-keyword">if</span>(stat == RES_OK)<br>    &#123;<br>      disk.is_initialized[pdrv] = <span class="hljs-number">1</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> stat;<br>&#125;<br>DSTATUS <span class="hljs-title function_">disk_status</span> <span class="hljs-params">(</span><br><span class="hljs-params">BYTE pdrv<span class="hljs-comment">/* Physical drive number to identify the drive */</span></span><br><span class="hljs-params">)</span><br>&#123;<br>  DSTATUS stat;<br><br>  stat = disk.drv[pdrv]-&gt;disk_status(disk.lun[pdrv]);<br>  <span class="hljs-keyword">return</span> stat;<br>&#125;<br>DRESULT <span class="hljs-title function_">disk_read</span> <span class="hljs-params">(</span><br><span class="hljs-params">BYTE pdrv,<span class="hljs-comment">/* Physical drive nmuber to identify the drive */</span></span><br><span class="hljs-params">BYTE *buff,<span class="hljs-comment">/* Data buffer to store read data */</span></span><br><span class="hljs-params">DWORD sector,        <span class="hljs-comment">/* Sector address in LBA */</span></span><br><span class="hljs-params">UINT count<span class="hljs-comment">/* Number of sectors to read */</span></span><br><span class="hljs-params">)</span><br>&#123;<br>  DRESULT res;<br><br>  res = disk.drv[pdrv]-&gt;disk_read(disk.lun[pdrv], buff, sector, count);<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br>......等等函数<br></code></pre></td></tr></table></figure></li><li><p>从上面可以看到都是调用disk这个结构体里面的drv指针数组所指向的函数。disk结构体在ff_gen_drv.h这个文件下定义的；disk里面的drv结构体就是我们要实现的函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  <span class="hljs-type">uint8_t</span>                 is_initialized[_VOLUMES];<span class="hljs-comment">//记录每个磁盘是否被初始化过</span><br>  <span class="hljs-type">const</span> Diskio_drvTypeDef *drv[_VOLUMES];<span class="hljs-comment">//指针数组，指向每个磁盘的操作函数</span><br>  <span class="hljs-type">uint8_t</span>                 lun[_VOLUMES];<span class="hljs-comment">//记录磁盘号</span><br>  <span class="hljs-keyword">volatile</span> <span class="hljs-type">uint8_t</span>        nbr;<br><br>&#125;Disk_drvTypeDef;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>  DSTATUS (*disk_initialize) (BYTE);                     <span class="hljs-comment">/*!&lt; Initialize Disk Drive                     */</span><br>  DSTATUS (*disk_status)     (BYTE);                     <span class="hljs-comment">/*!&lt; Get Disk Status                           */</span><br>  DRESULT (*disk_read)       (BYTE, BYTE*, DWORD, UINT);       <span class="hljs-comment">/*!&lt; Read Sector(s)                            */</span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _USE_WRITE == 1</span><br>  DRESULT (*disk_write)      (BYTE, <span class="hljs-type">const</span> BYTE*, DWORD, UINT); <span class="hljs-comment">/*!&lt; Write Sector(s) when _USE_WRITE = 0       */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _USE_WRITE == 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> _USE_IOCTL == 1</span><br>  DRESULT (*disk_ioctl)      (BYTE, BYTE, <span class="hljs-type">void</span>*);              <span class="hljs-comment">/*!&lt; I/O control operation when _USE_IOCTL = 1 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _USE_IOCTL == 1 */</span></span><br><br>&#125;Diskio_drvTypeDef;<br></code></pre></td></tr></table></figure></li><li><p>新建一个.c文件来实现这些函数。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">const</span> Diskio_drvTypeDef  SD_Driver =<br>&#123;<br>  SD_initialize,<br>  SD_status,<br>  SD_read,<br><span class="hljs-meta">#<span class="hljs-keyword">if</span>  _USE_WRITE == 1</span><br>  SD_write,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _USE_WRITE == 1 */</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span>  _USE_IOCTL == 1</span><br>  SD_ioctl,<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* _USE_IOCTL == 1 */</span></span><br>&#125;;<br><span class="hljs-comment">//下面就是具体函数</span><br>DSTATUS <span class="hljs-title function_">SD_initialize</span><span class="hljs-params">(BYTE lun)</span><br>&#123;<br>Stat = STA_NOINIT;<br><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> !defined(DISABLE_SD_INIT)</span><br><br>  <span class="hljs-keyword">if</span>(BSP_SD_Init() == MSD_OK)<br>  &#123;<br>    Stat = SD_CheckStatus(lun);<br>  &#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  Stat = SD_CheckStatus(lun);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">return</span> Stat;<br>&#125;<br><br>DSTATUS <span class="hljs-title function_">SD_status</span><span class="hljs-params">(BYTE lun)</span><br>&#123;<br>  <span class="hljs-keyword">return</span> SD_CheckStatus(lun);<br>&#125;<br><br>DRESULT <span class="hljs-title function_">SD_read</span><span class="hljs-params">(BYTE lun, BYTE *buff, DWORD sector, UINT count)</span><br>&#123;<br>  DRESULT res = RES_ERROR;<br><br>  <span class="hljs-keyword">if</span>(BSP_SD_ReadBlocks((<span class="hljs-type">uint32_t</span>*)buff,<br>                       (<span class="hljs-type">uint32_t</span>) (sector),<br>                       count, SD_TIMEOUT) == MSD_OK)<br>  &#123;<br>    <span class="hljs-comment">/* wait until the read operation is finished */</span><br>    <span class="hljs-keyword">while</span>(BSP_SD_GetCardState()!= MSD_OK)<br>    &#123;<br>    &#125;<br>    res = RES_OK;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>DRESULT <span class="hljs-title function_">SD_write</span><span class="hljs-params">(BYTE lun, <span class="hljs-type">const</span> BYTE *buff, DWORD sector, UINT count)</span><br>&#123;<br>  DRESULT res = RES_ERROR;<br><br>  <span class="hljs-keyword">if</span>(BSP_SD_WriteBlocks((<span class="hljs-type">uint32_t</span>*)buff,<br>                        (<span class="hljs-type">uint32_t</span>)(sector),<br>                        count, SD_TIMEOUT) == MSD_OK)<br>  &#123;<br><span class="hljs-comment">/* wait until the Write operation is finished */</span><br>    <span class="hljs-keyword">while</span>(BSP_SD_GetCardState() != MSD_OK)<br>    &#123;<br>    &#125;<br>    res = RES_OK;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>DRESULT <span class="hljs-title function_">SD_ioctl</span><span class="hljs-params">(BYTE lun, BYTE cmd, <span class="hljs-type">void</span> *buff)</span><br>&#123;<br>  DRESULT res = RES_ERROR;<br>  BSP_SD_CardInfo CardInfo;<br><br>  <span class="hljs-keyword">if</span> (Stat &amp; STA_NOINIT) <span class="hljs-keyword">return</span> RES_NOTRDY;<br><br>  <span class="hljs-keyword">switch</span> (cmd)<br>  &#123;<br>  <span class="hljs-comment">/* Make sure that no pending write process */</span><br>  <span class="hljs-keyword">case</span> CTRL_SYNC :<br>    res = RES_OK;<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-comment">/* Get number of sectors on the disk (DWORD) */</span><br>  <span class="hljs-keyword">case</span> GET_SECTOR_COUNT :<br>    BSP_SD_GetCardInfo(&amp;CardInfo);<br>    *(DWORD*)buff = CardInfo.LogBlockNbr;<br>    res = RES_OK;<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-comment">/* Get R/W sector size (WORD) */</span><br>  <span class="hljs-keyword">case</span> GET_SECTOR_SIZE :<br>    BSP_SD_GetCardInfo(&amp;CardInfo);<br>    *(WORD*)buff = CardInfo.LogBlockSize;<br>    res = RES_OK;<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-comment">/* Get erase block size in unit of sector (DWORD) */</span><br>  <span class="hljs-keyword">case</span> GET_BLOCK_SIZE :<br>    BSP_SD_GetCardInfo(&amp;CardInfo);<br>    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;<br>    res = RES_OK;<br>    <span class="hljs-keyword">break</span>;<br><br>  <span class="hljs-keyword">default</span>:<br>    res = RES_PARERR;<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>到这里可能有个疑问，FATfs调用的是disk这个结构体里面drv的函数，他怎么知道要调用哪个具体的drv指针呢。虽然我们定义了drv这个函数指针结构体，但是我们没有链接。fatfs中是如何连接呢，调用如下函数：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">MX_FATFS_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">/*## FatFS: Link the SD driver ###########################*/</span><br>  retSD = FATFS_LinkDriver(&amp;SD_Driver, SDPath);<br>&#125;<br><span class="hljs-comment">//这个就是fatfs初始化的时候，将我们上述实现的drv结构体和磁盘号都连接到fatfs定义的disk这个结构体内了。</span><br></code></pre></td></tr></table></figure></li><li><p>到这里FATFS已经完全移植完了。我们可以另外添加各种存储设备，spi flash、emmc、USB虚拟存储设备等等都可以，只需要定义多个Diskio_drvTypeDef结构体，并且链接到系统调用的disk结构体中。</p></li></ul><h2 id="3-3测试一下移植的是否成功"><a href="#3-3测试一下移植的是否成功" class="headerlink" title="3&#x2F;3测试一下移植的是否成功"></a>3&#x2F;3测试一下移植的是否成功</h2><ul><li><p>在mian函数之前写好测试函数，并且设置好串口。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C">FRESULT fres; <br><br><span class="hljs-type">void</span> <span class="hljs-title function_">FatFs_Test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br>    UINT bytes_written, bytes_read;<br><br><br>    fres = f_mount(&amp;SDFatFS, SDPath, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to mount filesystem: %d\n&quot;</span>, fres);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件系统挂载成功！\r\n&quot;</span>);<br><br><br>    fres = f_open(&amp;SDFile, <span class="hljs-string">&quot;test.txt&quot;</span>, FA_CREATE_ALWAYS | FA_WRITE);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to open file: %d\n&quot;</span>, fres);<br>        f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;创建test.txt文件成功\n&quot;</span>);<br><br><br>    <span class="hljs-built_in">strcpy</span>(buffer, <span class="hljs-string">&quot;Hello, STM32H743vit6!&quot;</span>);<br>    fres = f_write(&amp;SDFile, buffer, <span class="hljs-built_in">strlen</span>(buffer), &amp;bytes_written);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK || bytes_written == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to write to file: %d\n&quot;</span>, fres);<br>        f_close(&amp;SDFile);<br>        f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;写入文件成功\n&quot;</span>);<br><br><br>    f_close(&amp;SDFile);<br><br><br>    fres = f_open(&amp;SDFile, <span class="hljs-string">&quot;test.txt&quot;</span>, FA_READ);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to open file for reading: %d\n&quot;</span>, fres);<br>        f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;打开test.txt文件成功\n&quot;</span>);<br><br> <br>    fres = f_read(&amp;SDFile, buffer, <span class="hljs-keyword">sizeof</span>(buffer) - <span class="hljs-number">1</span>, &amp;bytes_read);<br>    <span class="hljs-keyword">if</span> (fres != FR_OK || bytes_read == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Failed to read from file: %d\n&quot;</span>, fres);<br>        f_close(&amp;SDFile);<br>        f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    buffer[bytes_read] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;文件里面的数据为: %s\n&quot;</span>, buffer);<br><br> <br>    f_close(&amp;SDFile);<br><br><br>    f_mount(<span class="hljs-literal">NULL</span>, SDPath, <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;取消挂载文件系统成功\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在main函数内调用，打开串口可以看到，然后make编译程序。如下：</p><p><img src="/./../photo/743fat%E4%B8%B2%E5%8F%A3%E6%B5%8B%E8%AF%95.png"></p></li><li><p>另外注意，如果使用了操作系统，则在应该在任务之外挂载文件系统。不然可能会导致，任务结束后，文件系统会丢失。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS总结</title>
    <link href="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1、FreeRTOS简介"><a href="#1、FreeRTOS简介" class="headerlink" title="1、FreeRTOS简介"></a>1、FreeRTOS简介</h1><h2 id="1-1嵌入式操作系统简介"><a href="#1-1嵌入式操作系统简介" class="headerlink" title="1&#x2F;1嵌入式操作系统简介"></a>1&#x2F;1嵌入式操作系统简介</h2><ul><li>操作系统是允许多个任务“同时运行”的，操作系统的这个特性被称为多任务。然而实际 上，一个 CPU 核心在某一时刻只能运行一个任务，而操作系统中任务调度器的责任就是决定在 某一时刻 CPU 究竟要运行哪一个任务，任务调度器使得 CPU 在各个任务之间来回切换并处理 任务，由于切换处理任务的速度非常快，因此就给人造成了一种同一时刻有多个任务同时运行 的错觉。</li></ul><h2 id="1-2为什么要引入FreeRTOS"><a href="#1-2为什么要引入FreeRTOS" class="headerlink" title="1&#x2F;2为什么要引入FreeRTOS"></a>1&#x2F;2为什么要引入FreeRTOS</h2><ul><li>FreeRTOS是嵌入式实时操作系统的一种，但是它具备的优点：可移植性强、可裁剪、支持多种任务通讯、同步机制、高效的软件定时器、任务数量、优先级数量不限、运行效率高、支持抢占式、合作式调度、开源、免费、可商用。功能强大，技术成熟的实时操作系统。引入实时操作系统后，可以同步处理多个任务，让CPU执行效率更高。不像裸机结构，针对某个任务需要不断查询，造成CPU资源浪费。</li></ul><h2 id="1-3如何获取FreeRTOS"><a href="#1-3如何获取FreeRTOS" class="headerlink" title="1&#x2F;3如何获取FreeRTOS"></a>1&#x2F;3如何获取FreeRTOS</h2><ul><li>FreeRTOS是用C语言编写的一个操作系统，可以在官网获取到源码。<a href="https://www.freertos.org/zh-cn-cmn-s/">FreeRTOS官网链接</a></li></ul><p>进入官网后点击下载，即可获取最新的FreeRTOS的源码，如图所示：</p><p><img src="/./../photo/%E5%AE%98%E7%BD%91%E5%9B%BE.png"></p><h2 id="1-2FreeRTOS源码目录及其介绍"><a href="#1-2FreeRTOS源码目录及其介绍" class="headerlink" title="1&#x2F;2FreeRTOS源码目录及其介绍"></a>1&#x2F;2FreeRTOS源码目录及其介绍</h2><ul><li>下载解压后，如图所示 ：</li></ul><p><img src="/./../photo/%E6%BA%90%E7%A0%81.png"></p><ul><li><p>源码目录内容介绍：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs DTS">├─FreeRTOS<br>│  ├─Demo<span class="hljs-comment">// 各种开发工具的完整Demo，开发者可以方便的以此搭建出自己的项目，甚至直接使用</span><br>│  │  ├─Common<span class="hljs-comment">// 所有例程都可以使用的演示例程文件</span><br>│  │  └─其他<span class="hljs-comment">// 对应平台和开发工具的项目例程（命名：平台_开发工具，例如：CORTEX_M4F_M0_LPC43xx_Keil）</span><br>│  ├─License<span class="hljs-comment">// 使用修改过的 GPL</span><br>│  └─Source<span class="hljs-comment">// FreeRTOS的源码</span><br>│      ├─include<span class="hljs-comment">// 源码对应的头文件</span><br>│      └─portable<span class="hljs-comment">// 每个支持的处理器架构需要一小段与处理器架构相关的RTOS代码。该目录下即为和开发平台相关的代码</span><br>│            ├─MemMang<span class="hljs-comment">// FreeRTOS内存管理方案（一般要根据平台来选择以下5个之一）</span><br>│            │     heap_1.c<br>│            │     heap_2.c<br>│            │     heap_3.c<br>│            │     heap_4.c<br>│            │     heap_5.c<br>│            └─其他<span class="hljs-comment">// 其他开发工具相关的代码，需要根据自己的开发工具进行选择</span><br>│      croutine.c<span class="hljs-comment">// 协线程（协程）文件，和任务类似，在系统资源比较缺乏下使用</span><br>│      event_groups.c<span class="hljs-comment">// 事件标志组</span><br>│      list.c<span class="hljs-comment">// 列表结构描述，在内核整体控制上都使用了列表格式数据处理,一切数据结构的基础</span><br>│      queue.c<span class="hljs-comment">// 队列，任务和任务之间的通讯处理</span><br>│      tasks.c<span class="hljs-comment">// 所有任务相关函数</span><br>│      timers.c<span class="hljs-comment">// 软件定时器，以任务形式存在</span><br>|      stream_buffer.c<span class="hljs-comment">// 10.0.0 新增</span><br>└─FreeRTOS-Plus<span class="hljs-comment">// FreeRTOS+组件和演示例程</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="2、FreeRTOS移植"><a href="#2、FreeRTOS移植" class="headerlink" title="2、FreeRTOS移植"></a>2、FreeRTOS移植</h1><h2 id="2-1源码具体分类"><a href="#2-1源码具体分类" class="headerlink" title="2&#x2F;1源码具体分类"></a>2&#x2F;1源码具体分类</h2><ul><li><p><strong>操作系统内核核心文件</strong>：内核的核心文件，包括任务管理、调度算法、消息通知…等等重要文件</p><ul><li><img src="/./../photo/freertos%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></li></ul></li><li><p><strong>硬件架构相关的文件</strong>：这个里面的内容都是与具体处理器架构相关的文件，根据不同的架构选择不同的文件，如图所示，这个里面的文件是操作系统跟硬件架构相适配，保证系统正常运行</p><ul><li><p>例如ARM架构下的cortex-m3和cortex-m4架构的文件如图</p><p><img src="/./../photo/freertos%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></p></li></ul></li><li><p><strong>内存管理算法文件，以及配置文件</strong>；FreeRTOS提供了5种内存管理算法。为了方便裁剪系统，官方DEMO文件中定义了一个FreeRTOSConfig.h的头文件，里面都是一些宏开关，可以根据需求，来裁剪系统，使不需要的配置不被编译进目标文件。</p><ul><li><p>内存管理文件如图</p><p><img src="/./../photo/freertos%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></p></li><li><p>配置文件模板：这个配置文件，没有固定的文件，官方只是在示例中给出一些模板，用户可以根据这个模板来自己修改内容，另外可以模仿直接从写一份；如图所示</p><p><img src="/./../photo/freertos%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></p></li></ul></li></ul><h2 id="2-2基于CORTEX-M3-M4系列的移植"><a href="#2-2基于CORTEX-M3-M4系列的移植" class="headerlink" title="2&#x2F;2基于CORTEX-M3&#x2F;M4系列的移植"></a>2&#x2F;2基于CORTEX-M3&#x2F;M4系列的移植</h2><ul><li><p>移植前需要稍微了解一下这两个架构异常和中断类型；</p><ul><li><p>如图就是cm3的异常表</p><p><img src="/./../photo/cm4%E5%BC%82%E5%B8%B8%E8%A1%A8.png"></p></li><li><p>这里我们主要关注这三个异常</p><ul><li><p>SYSTICK异常：cortex-m系列的产品里面的系统滴答定时器产生的异常，在freertos中使用滴答定时器作为系统的心跳，以此来实现时间片轮转的调度功能；每当时间片（就是滴答定时器计数到了）到了，调用相应的中断服务函数来检查是否需要切换任务。在freertos的port.c中定义了相应的中断服务函数，如图；</p><p><img src="/./../photo/systick%E5%87%BD%E6%95%B0.png"></p></li><li><p>PendSV异常：根据上述，SYSTICK这个异常只是检查是否要进行任务切换，真正要实现任务切换的是触发PendSV异常，在freertos的port.c中定义了相应的中断服务函数，如图；</p><p><img src="/./../photo/pendsv%E5%87%BD%E6%95%B0.png"></p></li><li><p>SVC异常：这个异常在freertos中一般只会使用一次，它也是用来进行任务调度的，但是只在vTaskStartScheduler(void)这个函数里面调用一次，在freertos中定义了相关的中断服务函数。这个函数调用流程为（vTaskStartScheduler( void )-&gt;xPortStartScheduler( void )-&gt;prvPortStartFirstTask(void)在这个函数里面会触发svc异常）</p><p><img src="/./../photo/svc%E5%87%BD%E6%95%B0.png"></p></li></ul></li></ul></li><li><p>修改启动文件，启动文件里面定义了中断服务函数的名称，需要用freertos中的这三个函数名替换掉三个函数</p><p><img src="/./../photo/%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6.png"></p></li><li><p>注释掉HAL库下的中断服务函数：stm32fxxx_it.c文件里面注释掉这三个函数。</p></li><li><p>最后就是将上述操作系统内核核心文件、架构文件、配置文件的c文件加入到项目内，然后添加相应的头文件路径。到这里基本上freertos移植完成了。剩下一些裁剪功能，配置等等在相应的配置文件来处理。</p></li></ul><h2 id="2-3配置文件以及内存管理算法细节"><a href="#2-3配置文件以及内存管理算法细节" class="headerlink" title="2&#x2F;3配置文件以及内存管理算法细节"></a>2&#x2F;3配置文件以及内存管理算法细节</h2><ul><li><p>配置文件主要是对FreeRTOS.h这个头文件的内容进行一些裁剪，并且里面有些如果不定义就会报错；如图必须需要定义的；其他具体的配置内容可以参考FreeRTOS.h这个头文件来进行裁剪和进行配置</p><p><img src="/./../photo/freertos%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89.png"></p></li><li><p>FreeRTOSConfig.h模板如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FREERTOS_CONFIG_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FREERTOS_CONFIG_H</span><br><br><span class="hljs-comment">/* 头文件 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> SystemCoreClock;<br><br><span class="hljs-comment">/* 基础配置项 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_PREEMPTION                            1                       <span class="hljs-comment">/* 1: 抢占式调度器, 0: 协程式调度器, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION         1                       <span class="hljs-comment">/* 1: 使用硬件计算下一个要运行的任务, 0: 使用软件算法计算下一个要运行的任务, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TICKLESS_IDLE                         0                       <span class="hljs-comment">/* 1: 使能tickless低功耗模式, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configCPU_CLOCK_HZ                              SystemCoreClock         <span class="hljs-comment">/* 定义CPU主频, 单位: Hz, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSYSTICK_CLOCK_HZ                          (configCPU_CLOCK_HZ / 8)<span class="hljs-comment">/* 定义SysTick时钟频率，当SysTick时钟频率与内核时钟频率不同时才可以定义, 单位: Hz, 默认: 不定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTICK_RATE_HZ                              1000                    <span class="hljs-comment">/* 定义系统时钟节拍频率, 单位: Hz, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_PRIORITIES                            32                      <span class="hljs-comment">/* 定义最大优先级数, 最大优先级=configMAX_PRIORITIES-1, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMINIMAL_STACK_SIZE                        128                     <span class="hljs-comment">/* 定义空闲任务的栈空间大小, 单位: Word, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_TASK_NAME_LEN                         16                      <span class="hljs-comment">/* 定义任务名最大字符数, 默认: 16 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_16_BIT_TICKS                          0                       <span class="hljs-comment">/* 1: 定义系统时钟节拍计数器的数据类型为16位无符号数, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configIDLE_SHOULD_YIELD                         1                       <span class="hljs-comment">/* 1: 使能在抢占式调度下,同优先级的任务能抢占空闲任务, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TASK_NOTIFICATIONS                    1                       <span class="hljs-comment">/* 1: 使能任务间直接的消息传递,包括信号量、事件标志组和消息邮箱, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTASK_NOTIFICATION_ARRAY_ENTRIES           1                       <span class="hljs-comment">/* 定义任务通知数组的大小, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_MUTEXES                               1                       <span class="hljs-comment">/* 1: 使能互斥信号量, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_RECURSIVE_MUTEXES                     1                       <span class="hljs-comment">/* 1: 使能递归互斥信号量, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_COUNTING_SEMAPHORES                   1                       <span class="hljs-comment">/* 1: 使能计数信号量, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_ALTERNATIVE_API                       0                       <span class="hljs-comment">/* 已弃用!!! */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configQUEUE_REGISTRY_SIZE                       8                       <span class="hljs-comment">/* 定义可以注册的信号量和消息队列的个数, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_QUEUE_SETS                            1                       <span class="hljs-comment">/* 1: 使能队列集, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TIME_SLICING                          1                       <span class="hljs-comment">/* 1: 使能时间片调度, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_NEWLIB_REENTRANT                      0                       <span class="hljs-comment">/* 1: 任务创建时分配Newlib的重入结构体, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configENABLE_BACKWARD_COMPATIBILITY             0                       <span class="hljs-comment">/* 1: 使能兼容老版本, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configNUM_THREAD_LOCAL_STORAGE_POINTERS         0                       <span class="hljs-comment">/* 定义线程本地存储指针的个数, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSTACK_DEPTH_TYPE                          uint16_t                <span class="hljs-comment">/* 定义任务堆栈深度的数据类型, 默认: uint16_t */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMESSAGE_BUFFER_LENGTH_TYPE                size_t                  <span class="hljs-comment">/* 定义消息缓冲区中消息长度的数据类型, 默认: size_t */</span></span><br><br><span class="hljs-comment">/* 内存分配相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSUPPORT_STATIC_ALLOCATION                 0                       <span class="hljs-comment">/* 1: 支持静态申请内存, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION                1                       <span class="hljs-comment">/* 1: 支持动态申请内存, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTOTAL_HEAP_SIZE                           ((size_t)(10 * 1024))   <span class="hljs-comment">/* FreeRTOS堆中可用的RAM总量, 单位: Byte, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configAPPLICATION_ALLOCATED_HEAP                0                       <span class="hljs-comment">/* 1: 用户手动分配FreeRTOS内存堆(ucHeap), 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSTACK_ALLOCATION_FROM_SEPARATE_HEAP       0                       <span class="hljs-comment">/* 1: 用户自行实现任务创建时使用的内存申请与释放函数, 默认: 0 */</span></span><br><br><span class="hljs-comment">/* 钩子函数相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_IDLE_HOOK                             0                       <span class="hljs-comment">/* 1: 使能空闲任务钩子函数, 无默认需定义  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TICK_HOOK                             0                       <span class="hljs-comment">/* 1: 使能系统时钟节拍中断钩子函数, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configCHECK_FOR_STACK_OVERFLOW                  0                       <span class="hljs-comment">/* 1: 使能栈溢出检测方法1, 2: 使能栈溢出检测方法2, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_MALLOC_FAILED_HOOK                    0                       <span class="hljs-comment">/* 1: 使能动态内存申请失败钩子函数, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_DAEMON_TASK_STARTUP_HOOK              0                       <span class="hljs-comment">/* 1: 使能定时器服务任务首次执行前的钩子函数, 默认: 0 */</span></span><br><br><span class="hljs-comment">/* 运行时间和任务状态统计相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configGENERATE_RUN_TIME_STATS                   0                       <span class="hljs-comment">/* 1: 使能任务运行时间统计功能, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> configGENERATE_RUN_TIME_STATS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/TIMER/btim.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()        ConfigureTimeForRunTimeStats()</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> FreeRTOSRunTimeTicks;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portGET_RUN_TIME_COUNTER_VALUE()                FreeRTOSRunTimeTicks</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TRACE_FACILITY                        1                       <span class="hljs-comment">/* 1: 使能可视化跟踪调试, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS            1                       <span class="hljs-comment">/* 1: configUSE_TRACE_FACILITY为1时，会编译vTaskList()和vTaskGetRunTimeStats()函数, 默认: 0 */</span></span><br><br><span class="hljs-comment">/* 协程相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_CO_ROUTINES                           0                       <span class="hljs-comment">/* 1: 启用协程, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_CO_ROUTINE_PRIORITIES                 2                       <span class="hljs-comment">/* 定义协程的最大优先级, 最大优先级=configMAX_CO_ROUTINE_PRIORITIES-1, 无默认configUSE_CO_ROUTINES为1时需定义 */</span></span><br><br><span class="hljs-comment">/* 软件定时器相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TIMERS                                1                               <span class="hljs-comment">/* 1: 使能软件定时器, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_TASK_PRIORITY                       ( configMAX_PRIORITIES - 1 )    <span class="hljs-comment">/* 定义软件定时器任务的优先级, 无默认configUSE_TIMERS为1时需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_QUEUE_LENGTH                        5                               <span class="hljs-comment">/* 定义软件定时器命令队列的长度, 无默认configUSE_TIMERS为1时需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_TASK_STACK_DEPTH                    ( configMINIMAL_STACK_SIZE * 2) <span class="hljs-comment">/* 定义软件定时器任务的栈空间大小, 无默认configUSE_TIMERS为1时需定义 */</span></span><br><br><span class="hljs-comment">/* 可选函数, 1: 使能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskPrioritySet                        1                       <span class="hljs-comment">/* 设置任务优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_uxTaskPriorityGet                       1                       <span class="hljs-comment">/* 获取任务优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskDelete                             1                       <span class="hljs-comment">/* 删除任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskSuspend                            1                       <span class="hljs-comment">/* 挂起任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xResumeFromISR                          1                       <span class="hljs-comment">/* 恢复在中断中挂起的任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskDelayUntil                         1                       <span class="hljs-comment">/* 任务绝对延时 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskDelay                              1                       <span class="hljs-comment">/* 任务延时 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetSchedulerState                  1                       <span class="hljs-comment">/* 获取任务调度器状态 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetCurrentTaskHandle               1                       <span class="hljs-comment">/* 获取当前任务的任务句柄 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_uxTaskGetStackHighWaterMark             1                       <span class="hljs-comment">/* 获取任务堆栈历史剩余最小值 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetIdleTaskHandle                  1                       <span class="hljs-comment">/* 获取空闲任务的任务句柄 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_eTaskGetState                           1                       <span class="hljs-comment">/* 获取任务状态 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xEventGroupSetBitFromISR                1                       <span class="hljs-comment">/* 在中断中设置事件标志位 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTimerPendFunctionCall                  1                       <span class="hljs-comment">/* 将函数的执行挂到定时器服务任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskAbortDelay                         1                       <span class="hljs-comment">/* 中断任务延时 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetHandle                          1                       <span class="hljs-comment">/* 通过任务名获取任务句柄 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskResumeFromISR                      1                       <span class="hljs-comment">/* 恢复在中断中挂起的任务 */</span></span><br><br><span class="hljs-comment">/* 中断嵌套行为配置 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __NVIC_PRIO_BITS</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> configPRIO_BITS __NVIC_PRIO_BITS</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> configPRIO_BITS 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configLIBRARY_LOWEST_INTERRUPT_PRIORITY         15                  <span class="hljs-comment">/* 中断最低优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    5                   <span class="hljs-comment">/* FreeRTOS可管理的最高中断优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configKERNEL_INTERRUPT_PRIORITY                 ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_SYSCALL_INTERRUPT_PRIORITY            ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_API_CALL_INTERRUPT_PRIORITY           configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><br><span class="hljs-comment">/* FreeRTOS中断服务函数相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandler                              PendSV_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandler                                 SVC_Handler</span><br><br><span class="hljs-comment">/* 断言 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vAssertCalled(char, int) printf(<span class="hljs-string">&quot;Error: %s, %d\r\n&quot;</span>, char, int)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configASSERT( x ) <span class="hljs-keyword">if</span>( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )</span><br><br><span class="hljs-comment">/* FreeRTOS MPU 特殊定义 */</span><br><span class="hljs-comment">//#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0</span><br><span class="hljs-comment">//#define configTOTAL_MPU_REGIONS                                8</span><br><span class="hljs-comment">//#define configTEX_S_C_B_FLASH                                  0x07UL</span><br><span class="hljs-comment">//#define configTEX_S_C_B_SRAM                                   0x07UL</span><br><span class="hljs-comment">//#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY            1</span><br><span class="hljs-comment">//#define configALLOW_UNPRIVILEGED_CRITICAL_SECTIONS             1</span><br><br><span class="hljs-comment">/* ARMv8-M 安全侧端口相关定义。 */</span><br><span class="hljs-comment">//#define secureconfigMAX_SECURE_CONTEXTS         5</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* FREERTOS_CONFIG_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>FreeRTOS提供的五种内存管理算法</p><ul><li><table><thead><tr><th align="center">文件</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">heap_1.c</td><td align="center">分配简单，时间确定</td><td align="center">只分配空间，不能释放</td></tr><tr><td align="center">heap_2.c</td><td align="center">动态分配、最佳匹配</td><td align="center">内存碎片化、时间不定</td></tr><tr><td align="center">heap_3.c</td><td align="center">调用标准C库的函数</td><td align="center">速度慢、时间不定</td></tr><tr><td align="center">heap_4.c</td><td align="center">第二种方法的增强版，可以合并相邻空闲内存，解决碎片化</td><td align="center">时间不定</td></tr><tr><td align="center">heap_5.c</td><td align="center">在第四种方法上支持分隔内存块，解决碎片化</td><td align="center">时间不定</td></tr></tbody></table></li><li><p>heap_1的实现方法；它只提供分配函数，不提供释放函数，具体实现就是直接定义一个大数组如图所示：<img src="/./../photo/heap1%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89.png"></p><p>这个实现只是在要求使用 RAM 时将一个单一的数组细分为更小的块 。 数组的总大小（堆的总大小）通过 configTOTAL_HEAP_SIZE （定义于 FreeRTOSConfig.h 中）设置 。</p></li><li><p>heap_2实现方法；heap_2也是在数组上分配内存，跟heap_1不一样的地方在于heap_2使用<strong>最佳匹配算法</strong>(best fit)来分配内存，它支持vPortFree，例如有有三块空闲内存5B,25B,100B现在要申请20B的空间，那么就会将25B的空间划分为20B跟5B。但是这样可能就会造成碎片，就算释放掉申请的20B空间，它也不会把原先的5B空间合并成一个，如果5B的空间一直没人用的话，就会成碎片。</p></li><li><p>heap_3实现方法；他直接调用标准C库的malloc函数跟free函数，但是FreeRTOS中会先暂停调度器，再去调用这些函数，实现了线程安全</p></li><li><p>heap_4实现方法；heap_4使用<strong>首次适应算法</strong>(first fit)来分配内存,例如有三块空闲内存5B,100B,25B现在要申请20B的空间，那么它会找到第一个满足20B的内存，这里就是先找到100B，把它分为20B跟80B的空间，当释放掉申请的内存时候，它会把释放的20B的内存跟80B的内存从新合并成一块100B的内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。</p></li><li><p>heap_5实现方法；heap_5分配内存、释放内存的算法跟heap_4是一样的。但是heap_5不局限于管理一个大数组，可以管理很多块内存、分隔的内存。但是必须记录每块内存的地址以及大小，用结构体保存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">* <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapRegion</span></span><br><span class="hljs-class">* &#123;</span><br>*  <span class="hljs-type">uint8_t</span> *pucStartAddress; &lt;&lt; Start address of a block of memory that will be part of the heap.<br>*  <span class="hljs-type">size_t</span> xSizeInBytes;      &lt;&lt; Size of the block of memory.<br>* &#125; HeapRegion_t;<br></code></pre></td></tr></table></figure><p>如果要定义多块内存，就用该结构体数组形式来表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">* HeapRegion_t xHeapRegions[] =<br>* &#123;<br>*  &#123; ( <span class="hljs-type">uint8_t</span> * ) <span class="hljs-number">0x80000000</span>UL, <span class="hljs-number">0x10000</span> &#125;, &lt;&lt; Defines a block of <span class="hljs-number">0x10000</span> bytes starting at address <span class="hljs-number">0x80000000</span><br>*  &#123; ( <span class="hljs-type">uint8_t</span> * ) <span class="hljs-number">0x90000000</span>UL, <span class="hljs-number">0xa0000</span> &#125;, &lt;&lt; Defines a block of <span class="hljs-number">0xa0000</span> bytes starting at address of <span class="hljs-number">0x90000000</span><br>*  &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span> &#125;                &lt;&lt; Terminates the <span class="hljs-built_in">array</span>.<br>* &#125;;<br>*<br></code></pre></td></tr></table></figure></li><li><p>在实际使用的时候我们只需要选择其中一个内存管理算法就行。每个算法提供的申请内存的函数都是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( <span class="hljs-type">size_t</span> xWantedSize )</span><br>&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>释放函数都是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortFree</span><span class="hljs-params">( <span class="hljs-type">void</span> * pv )</span><br>&#123;<br>    .......<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="3、FreeRTOS源码"><a href="#3、FreeRTOS源码" class="headerlink" title="3、FreeRTOS源码"></a>3、FreeRTOS源码</h1><h2 id="3-1内核的列表"><a href="#3-1内核的列表" class="headerlink" title="3&#x2F;1内核的列表"></a>3&#x2F;1内核的列表</h2><ul><li><p>在FreeRTOS中列表是个很重要的数据结构，实质就是一个双向链表；FreeRTOS中定义了就绪列表、等待列表、挂起列表、延时列表、终止列表。任务切换等操作都是通过查找对应的列表来实现的。在list.h文件内都是有关列表的定义，以及函数的声明。</p></li><li><p>列表项的数据结构定义，及示意图；</p><ul><li><p>普通列表项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    configLIST_VOLATILE TickType_t xItemValue;          <span class="hljs-comment">/*&lt; The value being listed.  In most cases this is used to sort the list in ascending order. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxNext</span>;</span>     <span class="hljs-comment">/*&lt; Pointer to the next ListItem_t in the list. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxPrevious</span>;</span> <span class="hljs-comment">/*&lt; Pointer to the previous ListItem_t in the list. */</span><br>    <span class="hljs-type">void</span> * pvOwner;                                     <span class="hljs-comment">/*&lt; Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxContainer</span>;</span>     <span class="hljs-comment">/*&lt; Pointer to the list in which this list item is placed (if any). */</span><br>    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE          <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/./../photo/%E5%88%97%E8%A1%A8%E9%A1%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p>迷你列表项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xMINI_LIST_ITEM</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    configLIST_VOLATILE TickType_t xItemValue;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxNext</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxPrevious</span>;</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xMINI_LIST_ITEM</span> <span class="hljs-title">MiniListItem_t</span>;</span><br></code></pre></td></tr></table></figure><p><img src="/./../photo/%E8%BF%B7%E4%BD%A0%E5%88%97%E8%A1%A8%E9%A1%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li></ul></li><li><p>列表数据结构定义，及其示意图；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_INTEGRITY_CHECK_VALUE      <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    <span class="hljs-keyword">volatile</span> UBaseType_t uxNumberOfItems;<br>    ListItem_t * configLIST_VOLATILE pxIndex; <span class="hljs-comment">/*&lt; Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */</span><br>    MiniListItem_t xListEnd;                  <span class="hljs-comment">/*&lt; List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */</span><br>    listSECOND_LIST_INTEGRITY_CHECK_VALUE     <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>&#125; List_t;<br></code></pre></td></tr></table></figure><p><img src="/./../photo/%E5%88%97%E8%A1%A8%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p>切记列表里面的迷你列表项，不算做列表中的列表项的个数</p></li><li><p>FreeRTOS列表操作函数</p><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">void vListInitialise( List_t * const pxList )</td><td align="center">初始化列表头</td></tr><tr><td align="center">void vListInitialiseItem( ListItem_t * const pxItem )</td><td align="center">初始化列表项</td></tr><tr><td align="center">void vListInsert( List_t * const pxList,<br/>                  ListItem_t * const pxNewListItem )</td><td align="center">按照列表项里的列表值进行顺序插入列表</td></tr><tr><td align="center">void vListInsertEnd( List_t * const pxList,<br/>                     ListItem_t * const pxNewListItem )</td><td align="center">列表末端插入，这里特别要注意，这里并不一定是插到xListEnd后面，具体是插在pxIndex指向的列表项前面</td></tr><tr><td align="center">UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )</td><td align="center">删除列表项，返回移除后列表中列表项的多少</td></tr></tbody></table></li></ul><h2 id="3-2任务操作相关函数"><a href="#3-2任务操作相关函数" class="headerlink" title="3&#x2F;2任务操作相关函数"></a>3&#x2F;2任务操作相关函数</h2><ul><li><p>任务创建函数和删除函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*动态创建*/</span><br>BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">( </span><br><span class="hljs-params"> TaskFunction_t pxTaskCode, <span class="hljs-comment">//任务函数的函数指针</span></span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, <span class="hljs-comment">//任务名字</span></span><br><span class="hljs-params"> <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="hljs-comment">//任务堆栈大小</span></span><br><span class="hljs-params"> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters, <span class="hljs-comment">//传递给任务函数的参数</span></span><br><span class="hljs-params"> UBaseType_t uxPriority, <span class="hljs-comment">//任务优先级</span></span><br><span class="hljs-params"> TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask<span class="hljs-comment">//任务函数的函数句柄，就是任务控制块</span></span><br><span class="hljs-params">)</span>; <br><span class="hljs-comment">/*静态创建*/</span><br>TaskHandle_t <span class="hljs-title function_">xTaskCreateStatic</span><span class="hljs-params">( </span><br><span class="hljs-params"> TaskFunction_t pxTaskCode, </span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, </span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> ulStackDepth, </span><br><span class="hljs-params"> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters, </span><br><span class="hljs-params"> UBaseType_t uxPriority, </span><br><span class="hljs-params"> StackType_t * <span class="hljs-type">const</span> puxStackBuffer,<span class="hljs-comment">//任务的栈指针，内存由用户分配</span></span><br><span class="hljs-params"> StaticTask_t * <span class="hljs-type">const</span> pxTaskBuffer<span class="hljs-comment">//任务控制块的指针，内存由用户分配</span></span><br><span class="hljs-params">)</span>; <br><span class="hljs-comment">/*任务删除*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">(TaskHandle_t xTaskToDelete<span class="hljs-comment">//任务的句柄); </span></span><br></code></pre></td></tr></table></figure></li><li><p>任务挂起和恢复</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">(TaskHandle_t xTaskToSuspend)</span>;<span class="hljs-comment">//挂起任务，会阻塞任务</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskResume</span><span class="hljs-params">(TaskHandle_t xTaskToResume)</span>;<span class="hljs-comment">//恢复任务</span><br>BaseType_t <span class="hljs-title function_">xTaskResumeFromISR</span><span class="hljs-params">(TaskHandle_t xTaskToResume)</span><span class="hljs-comment">//在中断中要用这个来恢复任务</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-3任务间通信"><a href="#3-3任务间通信" class="headerlink" title="3&#x2F;3任务间通信"></a>3&#x2F;3任务间通信</h2><h3 id="3-3-1消息队列和队列集"><a href="#3-3-1消息队列和队列集" class="headerlink" title="3&#x2F;3&#x2F;1消息队列和队列集"></a>3&#x2F;3&#x2F;1消息队列和队列集</h3><ul><li><p>消息队列；是一种先进先出的存储机制，消息队列里面可以存储任何数据类型；但是要求任务在写队列的时候，要严格按照数据类型格式来写。如图所示：</p><p><img src="/./../photo/%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p>队列创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//动态创建，返回队列的起始地址</span><br>xQueueCreate(uxQueueLength，uxItemSize)<br></code></pre></td></tr></table></figure></li><li><p>队列读写函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">xQueueSend()<span class="hljs-comment">//尾部写队列</span><br>xQueueSendFromISR()<span class="hljs-comment">//中断中写</span><br>    <br>xQueueReceive()<span class="hljs-comment">//读队列</span><br>xQueueReceiveFromISR() <span class="hljs-comment">//中断中对</span><br></code></pre></td></tr></table></figure></li><li><p>注意，读写队列都可能导致任务阻塞，写的时候队列满，阻塞任务；读的时候队列空，阻塞任务；</p></li><li><p>队列集：队列集就是把存储不同数据类型的队列，管理起来；方便任务读取不同的队列。</p></li><li><p>队列集操作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">xQueueCreateSet()<span class="hljs-comment">//创建队列集</span><br>xQueueAddToSet()<span class="hljs-comment">//添加队列到队列集</span><br>xQueueRemoveFromSet()<span class="hljs-comment">//移除队列</span><br>xQueueSelectFromSet()<span class="hljs-comment">//获取队列集中有效消息的队列</span><br>xQueueSelectFromSetFromISR()<span class="hljs-comment">//在中断中获取队列集中的有效队列消息</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-3-2信号量"><a href="#3-3-2信号量" class="headerlink" title="3&#x2F;3&#x2F;2信号量"></a>3&#x2F;3&#x2F;2信号量</h3><ul><li><p>任务同步与互斥；任务同步就是一个任务要等待另一个任务操作完，才能进行下一步操作；互斥就是，两个任务在同一时间只能对某一个临界区资源进行操作；所以同步与互斥是成对出现的。</p></li><li><p>二值信号量：实质是一个队列项只有一个的队列，所以队列要么空和要么满；来解决任务间同步与互斥的问题。</p></li><li><p>计数型信号量：实质是一个多项的队列，但是这个队列，并不传递数据。仅仅是来表示可用资源数有多少；</p></li><li><p>互斥信号量：在二值信号量的基础上，加了优先级继承的机制，让获得信号量的任务优先级暂时提高，防止中等优先级任务打断，导致最高优先级任务一直阻塞。切记，不能用到中断，因为中断不是任务，没有优先级。并且中断中不能等待互斥量而被阻塞。</p></li></ul><h3 id="3-3-3空闲任务"><a href="#3-3-3空闲任务" class="headerlink" title="3&#x2F;3&#x2F;3空闲任务"></a>3&#x2F;3&#x2F;3空闲任务</h3><ul><li>在启动任务调度器的时候，内核默认创建了一个优先级最低的任务，就是空闲任务，这个任务主要在没有其他用户任务运行时，才会执行。主要作用是内存清理，以及统计任务。里面有个钩子函数，主要设置处理进入低功耗模式，这里是设置处理器；freertos有自带的低功耗区分一下。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式常见协议总结</title>
    <link href="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1、UART串口通信"><a href="#1、UART串口通信" class="headerlink" title="1、UART串口通信"></a>1、UART串口通信</h1><h2 id="1-1简介"><a href="#1-1简介" class="headerlink" title="1.1简介"></a>1.1简介</h2><ul><li><p>通用异步收发器 <strong>UART</strong>（Universal AsynchronousReceiver&#x2F;Transmitter)，是一种串行、异步、全双工的通信协议。高电平代表’1‘，低电平代表’0‘。特别注意固定格式位，起始位以0为通信起步，停止位以1作为结束位。</p></li><li><p>整体结构如图：</p><p><img src="/./../photo/%E7%BB%93%E6%9E%84%E7%AE%80%E5%9B%BE.png"></p></li></ul><h2 id="1-2参数配置"><a href="#1-2参数配置" class="headerlink" title="1.2参数配置"></a>1.2参数配置</h2><ul><li><p>数据传输格式</p><p><img src="/./../photo/UART%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.png" alt="数据格式"></p><ul><li>起始位总是以低电平有效，停止位以高电平有效。</li><li>数据位：数据位可以是5、6、7、8，9位等，构成一个字符（一般都是8位）。如ASCII码（7位），扩展BCD码（8位）。先发送<strong>最低位</strong>，最后发送<strong>最高位</strong>，使用低电平表示‘0’高电平表示‘1’完成数据位的传输。</li><li>奇偶检验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。</li></ul></li><li><p>波特率</p><ul><li>数据传输的速率用波特率来表示。通俗讲就是让通信双方知道什么时间点来采样数据。例如:通信波特率是115200bps，即代表1秒可以传输115200位的数据。</li></ul></li></ul><h2 id="1-3示例"><a href="#1-3示例" class="headerlink" title="1.3示例"></a>1.3示例</h2><ul><li><p>在stm32中如何使用串口，来实现printf函数与PC串口助手进行通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//值得的注意点：printf函数最终调用的是fputc(int ch, FILE *f)来输出字符串的，但是这个函数在stdio.h文件里面仅仅是定义了但是没有实现，所以必须重定义这个函数。</span><br>    <span class="hljs-comment">/*以下示例均以UART1来作为示例*/</span><br>    <span class="hljs-comment">/*HAL库函数版本实现串口的中断接收和发送*/</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">    &#123;</span><br>        __IO <span class="hljs-type">uint32_t</span> SR;         <span class="hljs-comment">/*!&lt; USART Status register,                   Address offset: 0x00 */</span><br>        __IO <span class="hljs-type">uint32_t</span> DR;         <span class="hljs-comment">/*!&lt; USART Data register,                     Address offset: 0x04 */</span><br>        __IO <span class="hljs-type">uint32_t</span> BRR;        <span class="hljs-comment">/*!&lt; USART Baud rate register,                Address offset: 0x08 */</span><br>        __IO <span class="hljs-type">uint32_t</span> CR1;        <span class="hljs-comment">/*!&lt; USART Control register 1,                Address offset: 0x0C */</span><br>        __IO <span class="hljs-type">uint32_t</span> CR2;        <span class="hljs-comment">/*!&lt; USART Control register 2,                Address offset: 0x10 */</span><br>        __IO <span class="hljs-type">uint32_t</span> CR3;        <span class="hljs-comment">/*!&lt; USART Control register 3,                Address offset: 0x14 */</span><br>        __IO <span class="hljs-type">uint32_t</span> GTPR;       <span class="hljs-comment">/*!&lt; USART Guard time and prescaler register, Address offset: 0x18 */</span><br>    &#125; USART_TypeDef;<span class="hljs-comment">//这是底层寄存器封装</span><br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PERIPH_BASE           0x40000000UL</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000UL)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> USART1_BASE           (APB2PERIPH_BASE + 0x00003800UL)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> USART1              ((USART_TypeDef *)USART1_BASE)</span><br>    <br>    <span class="hljs-comment">/*重定义fputc(int ch, FILE *f)*/</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> ((USART1-&gt;SR &amp; <span class="hljs-number">0X40</span>) == <span class="hljs-number">0</span>);     <span class="hljs-comment">/* 等待上一个字符发送完成 */</span><br>        USART_UX-&gt;DR = (<span class="hljs-type">uint8_t</span>)ch;           <span class="hljs-comment">/* 将要发送的字符 ch 写入到DR寄存器 */</span><br>        <span class="hljs-keyword">return</span> ch;<br>    &#125;<br>    <span class="hljs-comment">/*初始化串口1,省略大部分代码，保留核心函数*/</span><br>    UART_HandleTypeDef g_uart1_handle;  <span class="hljs-comment">/* UART句柄 */</span><br>    HAL_UART_Init(&amp;g_uart1_handle)内部调用--&gt;HAL_UART_MspInit(&amp;g_uart1_handle)--&gt; HAL_GPIO_Init()函数来配置相关引脚的复用输入输出--&gt;HAL_NVIC_EnableIRQ()使能串口中断--&gt;HAL_NVIC_SetPriority()设置中断优先级<br>    <br>        HAL_UART_Receive_IT(&amp;g_uart1_handle, (<span class="hljs-type">uint8_t</span> *)g_rx_buffer, RXBUFFERSIZE)开启串口接收中断天<br>    <br>        USART1_IRQHandler()串口<span class="hljs-number">1</span>中断服务函数--&gt;HAL_UART_IRQHandler()HAL串口中断公共服务函--&gt;HAL_UART_RxCpltCallback()中断接收回调函数 <br></code></pre></td></tr></table></figure></li></ul><h1 id="2、集成电路总线-IIC"><a href="#2、集成电路总线-IIC" class="headerlink" title="2、集成电路总线(IIC)"></a>2、集成电路总线(IIC)</h1><h2 id="2-1简介"><a href="#2-1简介" class="headerlink" title="2.1简介"></a>2.1简介</h2><ul><li>IIC使用两根信号线进行通信：一根时钟线SCL，一根数据线SDA。IIC将SCL处于高时SDA拉低的动作作为开始信号，SCL处于高时SDA拉高的动作作为结束信号；传输数据时，SDA在SCL低电平时改变数据，在SCL高电平时保持数据，每个SCL脉冲的高电平传递1位数据。IIC是半双工同步通信协议</li></ul><h2 id="2-2总线特性与硬件结构"><a href="#2-2总线特性与硬件结构" class="headerlink" title="2.2总线特性与硬件结构"></a>2.2总线特性与硬件结构</h2><ul><li><p>IIC总线上所有器件的SDA、SCL引脚输出驱动都为 <strong>开漏(OD)</strong> 结构，通过外接上拉电阻实现总线上所有节点SDA、SCL信号的<strong>线与</strong>逻辑关系；</p></li><li><p>总线上的所有设备通过软件寻址且具有唯一的地址（7位或10位）。7位“从机专用地址码”，其高4位为由生产厂家制定的<strong>设备类型地址</strong>，低3位为器件引脚定义地址（由使用者定义）；10位地址不常见；</p></li><li><p>支持多主机。在总线上存在多个主机时，通过冲突检测和仲裁机制防止多个主机同时发起数据传输时存在的冲突；</p></li><li><p>通信模式</p><ul><li><table><thead><tr><th align="center">模式</th><th align="center">速度</th></tr></thead><tbody><tr><td align="center">标准模式（Standard Mode）</td><td align="center">100kb&#x2F;s</td></tr><tr><td align="center">快速模式（Fast Mode）</td><td align="center">400kb&#x2F;s</td></tr><tr><td align="center">增强快速模式（Fast Mode Plus）</td><td align="center">1Mb&#x2F;s</td></tr><tr><td align="center">高速模式（High Speed Mode）</td><td align="center">3.4Mb&#x2F;s</td></tr><tr><td align="center">极速模式（Ultra-FastMode）</td><td align="center">5Mb&#x2F;s</td></tr></tbody></table></li></ul></li><li><p>硬件结构</p><ul><li>IIC使用两根信号线进行通信，要求两根线都使用 <strong>开漏输出接上拉电阻</strong> 的配置，以此实现总线上所有节点SDA、SCL信号的 <strong>线与</strong> 逻辑关系。</li><li><img src="/./../photo/IIC%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E4%BD%93%E5%9B%BE.png" alt="结构图"></li><li>IIC允许一对多通信，但是同一时间只能有一个丛机跟主机通信</li></ul></li></ul><h2 id="2-3工作时序"><a href="#2-3工作时序" class="headerlink" title="2.3工作时序"></a>2.3工作时序</h2><ul><li><strong>数据有效性以及采集过程</strong><ul><li>IIC 的数据读取动作都在 <strong>SCL为高</strong> 时产生，<strong>SCL为低</strong>时是数据改变的时期，无论SDA如何变化都不影响读取。所以，传输数据的过程中，当SCL为高时，数据应当保持稳定，避免数据的采集出错。</li></ul></li><li><strong>开始和结束信号</strong><ul><li><strong>开始信号：</strong>SCL为高时，SDA从高到低的跳变产生开始信号</li><li><strong>结束信号：</strong>SCL为高时，SDA从低到高的跳变产生结束信号</li></ul></li><li><strong>重复开始信号（ReSTART&#x2F;Sr）：</strong> 在结束时不给出STOP信号，而以一个时钟周期内再次给出开始信号作为替代</li><li><strong>字节格式：</strong>SDA数据线上的每个字节<strong>必须是8位</strong>，对于每次传输的<strong>字节数没有限制</strong>。每个字节（8位）数据传送完后紧跟着应答信号（ACK，第9位）。数据的先后顺序为：<strong>高位在前</strong> 。</li><li><strong>应答信号（ACK）：</strong>协议规定数据传输过程必须包含应答（ACK）。接收器通过应答告知发送的字节已被成功接收，之后发送器可以进行下一个字节的传输。<strong>主机产生数据传输过程中的所有时钟，包括用于应答的第9个时钟。发送器在应答时钟周期内释放对SDA总线的控制，</strong>这样接收器可以通过将SDA线拉低告知发送器：数据已被成功接收。（<strong>特别注意，ACK信号是主机发送完数据后，必须必须释放SDA总线后，丛机来控制SDA总线发出的信号</strong>）<ul><li>应答信号分为两种：<ul><li>当第9位(应答位)为 <strong>低电平</strong> 时，为 <strong>ACK</strong> 信号</li><li>当第9位(应答位)为 <strong>高电平</strong> 时，为 <strong>NACK</strong>信号</li></ul></li></ul></li></ul><h2 id="2-4地址设备为7位的通信过程"><a href="#2-4地址设备为7位的通信过程" class="headerlink" title="2.4地址设备为7位的通信过程"></a>2.4地址设备为7位的通信过程</h2><ul><li>完整通信示意图：<ul><li><img src="/./../photo/7bit%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E9%80%9A%E4%BF%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="示意图"></li><li><strong>START信号后，第一个字节包含设备7位地址以及1位读写位，读写位表示主机将要对丛机进行的操作。发送完这个字节之后，主机释放SDA总线等待从机给出ACK应答。如果从机给出了ACK应答，表示从机地址正确（有从机响应）并且已知晓是读还是写，便可以开始读写数据。如果从机没有给出ACK应答，则说明接收设备可能没有收到数据（如寻址的设备不存在或是设备正在忙碌）或无法解析收到的数据，如果是这样，则由主机来决定如何处理（STOP或ReSTART）。</strong><ul><li>情况一：主机写，丛机收，传输过程传输方向不变<ul><li><img src="/./../photo/%E4%B8%BB%E5%8F%91%E4%B8%9B%E6%94%B6.png" alt="示意图"></li></ul></li><li>情况二：主机收，丛机发送，传输过程传输方向改变<ul><li><img src="/./../photo/%E4%B8%BB%E6%94%B6%E4%B8%9B%E5%8F%91.png" alt="示意图"></li></ul></li></ul></li></ul></li></ul><h2 id="2-4实例操作"><a href="#2-4实例操作" class="headerlink" title="2.4实例操作"></a>2.4实例操作</h2><ul><li><p>情况一：用GPIO来模拟IIC通信过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*以F103为例子，SCL--&gt;PB6,SDA--&gt;PB7，精简代码，不是所有都列出来*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCL(x)do&#123;x? HAL_GPIO_WritePin(GPIOB,GPIO_PIN6,GPIO_PIN_SET):</span><br> \HAL_GPIO_WritePin(GPIOB,GPIO_PIN6,GPIO_PIN_RESET);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDA(x)do&#123;x? HAL_GPIO_WritePin(GPIOB,GPIO_PIN7,GPIO_PIN_SET):</span><br> \HAL_GPIO_WritePin(GPIOB,GPIO_PIN7,GPIO_PIN_RESET);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)<br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//初始化函数</span><br>&#123;<br>    GPIO_InitTypeDef gpio_init_struct;<br>    <br><span class="hljs-comment">/*首先是初始化这两个IO口，SCL配置为推挽输出，SDA配置为开漏输出（这样保证无论在哪种通信下，都不需要去切换IO口的     方向，因为开漏输出也可以读取IO的电平）*/</span><br>    <br>    ...配置省略<br>        <br>HAL_GPIO_Init(GPIOB, &amp;gpio_init_struct);<br>stop();<span class="hljs-comment">//初始化后先停止</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//起始信号</span><br>&#123;<br>    <span class="hljs-comment">/*SCL为高时，SDA从高到低的跳变产生开始信号*/</span><br>    SDA(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SDA(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    <br>    SCL(<span class="hljs-number">0</span>);<span class="hljs-comment">//这个操作是钳住IIC总线，准备接受或者发送数据</span><br>    delay_us(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//停止信号</span><br>&#123;<br>    <span class="hljs-comment">/*SCL为高时，SDA从低到高的跳变产生结束信号*/</span><br>    SDA(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SDA(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">master_ack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//主机应答信号</span><br>&#123;<br>    SDA(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    <br>    SDA(<span class="hljs-number">1</span>);<span class="hljs-comment">//释放总线</span><br>    delay_us(<span class="hljs-number">2</span>);      <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">master_nack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//主机不应答信号</span><br>&#123;<br>    SDA(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);     <br>&#125;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">slave_ack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> timeout;<br>    <span class="hljs-type">uint8_t</span> res=<span class="hljs-number">0</span>;<br>    SDA(<span class="hljs-number">1</span>);<span class="hljs-comment">//主机释放总线，此时丛机可以操作SDA线</span><br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<span class="hljs-comment">//拉高时钟线，可以传输数据了</span><br>    delay_us(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_7))<span class="hljs-comment">//等待SDA线的电平被从机拉低</span><br>    &#123;<br>        timeout++;<br>        <span class="hljs-keyword">if</span>(timeout&gt;<span class="hljs-number">250</span>)<br>        &#123;<br>            stop();<span class="hljs-comment">//超时</span><br>            res=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    SCL(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">iic_send</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span><span class="hljs-comment">//发送8位数据</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>    &#123;<br>        SDA((data&amp;<span class="hljs-number">0x80</span>)&gt;&gt;<span class="hljs-number">7</span>);<span class="hljs-comment">//因为IIC是先传输最高位的</span><br>        delay_us(<span class="hljs-number">2</span>);<br>        SCL(<span class="hljs-number">1</span>);<br>        delay_us(<span class="hljs-number">2</span>);<br>        SCL(<span class="hljs-number">0</span>);<br>        delay_us(<span class="hljs-number">2</span>);<br>        data&lt;&lt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    SDA(<span class="hljs-number">1</span>);<span class="hljs-comment">//释放总线</span><br>&#125;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">iic_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> ack)</span><span class="hljs-comment">//读取8位数据   </span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> res;<br>    <span class="hljs-type">uint8_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>    &#123;<br>        res&lt;&lt;=<span class="hljs-number">1</span>;<br>        SCL(<span class="hljs-number">1</span>);<br>        delay_us(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_7)<br>           &#123;<br>               res++;<br>           &#125;<br>        SCL(<span class="hljs-number">0</span>);<br>  delay_us(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!ack)<br>    &#123;<br>         master_nack();      <br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>         master_ack();       <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;       <br>&#125; <br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p>情况二：硬件IIC，用HAL库函数实现（F1系列HAL库硬件IIC可能会有BUG）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/////////////////////////</span><br>I2C_HandleTypeDef handle_iic<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">iic_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//硬件IIC初始化函数</span><br>&#123;<br>    <span class="hljs-comment">/*具体句柄配置省略，设置i2c速度、模式、丛机地址位数等等*/</span><br>    ...省略代码<br>        HAL_I2C_Iint(&amp;handle_iic);<span class="hljs-comment">/*这是IIC的初始化，还需要对应GPIO的初始化，这个函数内部会调用HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)这个函数*/</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_I2C_MspInit</span><span class="hljs-params">(I2C_HandleTypeDef* hi2c)</span><br>&#123;<br>    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span>(hi2c-&gt;I2C1)<br>    &#123;<br>        ...具体GPIO配置省略<br>        HAL_GPIO_Init();<br>        __HAL_RCC_I2C1_CLK_ENABLE();<br>        HAL_NVIC_SetPriority(I2C1_EV_IRQn, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);<br>        HAL_NVIC_SetPriority(I2C1_ER_IRQn, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*HAL库提供三种类型读写函（阻塞、非阻塞（其中包括中断和DMA））*/</span><br><span class="hljs-comment">//阻塞IIC发送、接受代码原型</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Transmit</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Receive</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_IsDeviceReady</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint32_t</span> Trials, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br><br><span class="hljs-comment">//非阻塞普通中断IIC发送、接受代码原型</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Transmit_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Receive_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br><br><span class="hljs-comment">//非阻塞DMA中断IIC发送、接受代码原型</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Transmit_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Receive_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p><strong>通过硬件IIC读取AT24C02代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><br><span class="hljs-comment">//AT24Cxx这是一个IIC接口的EEPROM存储芯片</span><br><span class="hljs-comment">//读写地址</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Write 0xA0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Read  0xA1</span><br><span class="hljs-comment">//三次写入的字符串</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str1[]=&#123;<span class="hljs-string">&quot;xyz666&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str2[]=&#123;<span class="hljs-string">&quot;1234567&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str3[]=&#123;<span class="hljs-string">&quot;abcdefg&quot;</span>&#125;;<br><span class="hljs-comment">//读取缓存区</span><br><span class="hljs-type">uint8_t</span> ReadBuffer[<span class="hljs-number">50</span>];<br><span class="hljs-comment">/* USER CODE END PV */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//阻塞方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str1,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>)==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>);<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_IT(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str2,<span class="hljs-keyword">sizeof</span>(str2))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_IT(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//DMA中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_DMA(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str3,<span class="hljs-keyword">sizeof</span>(str3))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_DMA(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li></ul><h1 id="3、串行外设接口（SPI）"><a href="#3、串行外设接口（SPI）" class="headerlink" title="3、串行外设接口（SPI）"></a>3、串行外设接口（SPI）</h1><h2 id="3-1简介"><a href="#3-1简介" class="headerlink" title="3.1简介"></a>3.1简介</h2><ul><li>SPI，是一<strong>种高速的，全双工，同步</strong>的通信总线，并且在芯片的管脚上只占用四根线。SPI分为主、从两种模式，一个SPI通讯系统需要包含一个（且只能是一个）主设备，一个或多个从设备。提供时钟的为主设备（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起。当存在多个从设备时，通过各自的片选信号进行管理。</li><li>4线SPI示意图<ul><li><img src="/./../photo/4%E7%BA%BFSPI%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="示意图"></li><li><strong>MISO</strong>： <strong>主设备输入&#x2F;从设备输出引脚</strong>。该引脚在从模式下发送数据，在主模式下接收数据。</li><li><strong>MOSI</strong>： <strong>主设备输出&#x2F;从设备输入引脚</strong>。该引脚在主模式下发送数据，在从模式下接收数据。</li><li><strong>SCLK</strong>：<strong>串行时钟信号</strong>，由主设备产生。</li><li><strong>CS&#x2F;SS</strong>：<strong>从设备片选信号</strong>，由主设备控制。它的功能是用来作为“片选引脚”，也<strong>就是选择指定的从设备</strong>，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。</li></ul></li><li>SPI工作原理<ul><li>在主机和从机都有一个串行移位寄存器，主机通过向它的 SPI 串行寄存 器写入一个字节来发起一次传输。串行移位寄存器通过 MOSI 信号线将字节传送给从机，从机 也将自己的串行移位寄存器中的内容通过 MISO 信号线返回给主机。这样，两个移位寄存器中 的内容就被交换。外设的写操作和读操作是同步完成的。<strong>如果只是进行写操作，主机只需忽略 接收到的字节。反之，若主机要读取从机的一个字节，就必须发送一个空字节引发从机传输。</strong></li></ul></li><li>SPI传输方式<ul><li><strong>SPI总共有三种传输方式：全双工、单工以及半双工传输方式。</strong></li></ul></li></ul><h2 id="3-2工作时序"><a href="#3-2工作时序" class="headerlink" title="3.2工作时序"></a>3.2工作时序</h2><ul><li><p>SPI四种不同工作模式由CPOL(时钟极性)和CPHA（时钟相位）来控制</p><ul><li><table><thead><tr><th align="center">SPI工作模式</th><th align="center">CPOL</th><th align="center">CPHA</th><th align="center">SCL空闲状态</th><th align="center">采样边沿</th><th align="center">采样时刻</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">低电平</td><td align="center">上升沿</td><td align="center">奇数边沿</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">低电平</td><td align="center">下降沿</td><td align="center">偶数边沿</td></tr><tr><td align="center">2</td><td align="center">1</td><td align="center">0</td><td align="center">高电平</td><td align="center">下降沿</td><td align="center">奇数边沿</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">1</td><td align="center">高电平</td><td align="center">上升沿</td><td align="center">偶数边沿</td></tr></tbody></table></li><li><p>以CPOL&#x3D;0,CPHA&#x3D;0为示例时序图，其他同理</p><ul><li><img src="/./../photo/SPI%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="时序图"></li><li>由图可以看出来，在传输开始前以及传输完成后，CPOL即SCL都为低电平，表示空闲的时候SCL为低电平状态，由于采样边沿是上升沿，即在第1、3、5、7…..等这些边沿进行采样。</li></ul></li></ul></li></ul><h2 id="3-3实例操作"><a href="#3-3实例操作" class="headerlink" title="3.3实例操作"></a>3.3实例操作</h2><ul><li><p><strong>基于stm32的HAL库配置SPI</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><br><span class="hljs-comment">//AT24Cxx这是一个IIC接口的EEPROM存储芯片</span><br><span class="hljs-comment">//读写地址</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Write 0xA0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Read  0xA1</span><br><span class="hljs-comment">//三次写入的字符串</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str1[]=&#123;<span class="hljs-string">&quot;xyz666&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str2[]=&#123;<span class="hljs-string">&quot;1234567&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str3[]=&#123;<span class="hljs-string">&quot;abcdefg&quot;</span>&#125;;<br><span class="hljs-comment">//读取缓存区</span><br><span class="hljs-type">uint8_t</span> ReadBuffer[<span class="hljs-number">50</span>];<br><span class="hljs-comment">/* USER CODE END PV */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//阻塞方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str1,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>)==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>);<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_IT(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str2,<span class="hljs-keyword">sizeof</span>(str2))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_IT(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//DMA中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_DMA(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str3,<span class="hljs-keyword">sizeof</span>(str3))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_DMA(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p><strong>SPI-&gt;norflash存储芯片的读写</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*仅仅介绍几个函数，具体的请参考完整代码*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_init</span><span class="hljs-params">()</span><br>&#123;<br>    GPIO_InitTypeDef gpio_init_struct;<span class="hljs-comment">//主要为了配置片选引脚</span><br>    ...配置代码省略<br>    HAL_GPIO_Init(GPIOX,&amp;gpio_init_struct)<br>    spi_init();<br>    spi_set_speed(SPI_SPEED_2);<span class="hljs-comment">//这个设置SPI速度的</span><br>    <span class="hljs-comment">/*有些flash芯片需要开启4字节地址模式*/</span>   <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_send_address</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> address)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (g_norflash_type == W25Q256) <span class="hljs-comment">/*  只有W25Q256支持4字节地址模式 */</span><br>    &#123;<br>        spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)((address)&gt;&gt;<span class="hljs-number">24</span>)); <span class="hljs-comment">/* 发送 bit31 ~ bit24 地址 */</span><br>    &#125; <br>    spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)((address)&gt;&gt;<span class="hljs-number">16</span>));     <span class="hljs-comment">/* 发送 bit23 ~ bit16 地址 */</span><br>    spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)((address)&gt;&gt;<span class="hljs-number">8</span>));      <span class="hljs-comment">/* 发送 bit15 ~ bit8  地址 */</span><br>    spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)address);             <span class="hljs-comment">/* 发送 bit7  ~ bit0  地址 */</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pbuf, <span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint16_t</span> datalen)</span><br>&#123;<br>    <span class="hljs-type">uint16_t</span> i;<br><br>    HAL_GPIO_WritePin(GPIOX,GPIO_PIN,GPIO_PIN_RESET);<span class="hljs-comment">//拉低片选选中芯片</span><br>    spi2_read_write_byte(FLASH_ReadData);       <span class="hljs-comment">/* 发送读取命令 */</span><br>    norflash_send_address(addr);                <span class="hljs-comment">/* 发送地址 */</span><br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;datalen;i++)<br>    &#123;<br>        pbuf[i] = spi2_read_write_byte(<span class="hljs-number">0XFF</span>);   <span class="hljs-comment">/* 循环读取 */</span><br>    &#125;<br>    <br>    HAL_GPIO_WritePin(GPIOX,GPIO_PIN,GPIO_PIN_SET);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pbuf, <span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint16_t</span> datalen)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> secpos;<br>    <span class="hljs-type">uint16_t</span> secoff;<br>    <span class="hljs-type">uint16_t</span> secremain;<br>    <span class="hljs-type">uint16_t</span> i;<br>    <span class="hljs-type">uint8_t</span> *norflash_buf;<br><br>    norflash_buf = g_norflash_buf;<br>    secpos = addr / <span class="hljs-number">4096</span>;       <span class="hljs-comment">/* 扇区地址 */</span><br>    secoff = addr % <span class="hljs-number">4096</span>;       <span class="hljs-comment">/* 在扇区内的偏移 */</span><br>    secremain = <span class="hljs-number">4096</span> - secoff;  <span class="hljs-comment">/* 扇区剩余空间大小 */</span><br>    <span class="hljs-keyword">if</span> (datalen &lt;= secremain)<br>    &#123;<br>        secremain = datalen;    <span class="hljs-comment">/* 不大于4096个字节 */</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        norflash_read(norflash_buf, secpos * <span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>);   <span class="hljs-comment">/* 读出整个扇区的内容 */</span><br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; secremain; i++)   <span class="hljs-comment">/* 校验数据 */</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (norflash_buf[secoff + i] != <span class="hljs-number">0XFF</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;      <span class="hljs-comment">/* 需要擦除, 直接退出for循环 */</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &lt; secremain)   <span class="hljs-comment">/* 需要擦除 */</span><br>        &#123;<br>            norflash_erase_sector(secpos);  <span class="hljs-comment">/* 擦除这个扇区 */</span><br><br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; secremain; i++)   <span class="hljs-comment">/* 复制 */</span><br>            &#123;<br>                norflash_buf[i + secoff] = pbuf[i];<br>            &#125;<br><br>            norflash_write_nocheck(norflash_buf, secpos * <span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>);  <span class="hljs-comment">/* 写入整个扇区 */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">/* 写已经擦除了的,直接写入扇区剩余区间. */</span><br>        &#123;<br>            norflash_write_nocheck(pbuf, addr, secremain);  <span class="hljs-comment">/* 直接写扇区 */</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (datalen == secremain)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">/* 写入结束了 */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">/* 写入未结束 */</span><br>        &#123;<br>            secpos++;               <span class="hljs-comment">/* 扇区地址增1 */</span><br>            secoff = <span class="hljs-number">0</span>;             <span class="hljs-comment">/* 偏移位置为0 */</span><br><br>            pbuf += secremain;      <span class="hljs-comment">/* 指针偏移 */</span><br>            addr += secremain;      <span class="hljs-comment">/* 写地址偏移 */</span><br>            datalen -= secremain;   <span class="hljs-comment">/* 字节数递减 */</span><br><br>            <span class="hljs-keyword">if</span> (datalen &gt; <span class="hljs-number">4096</span>)<br>            &#123;<br>                secremain = <span class="hljs-number">4096</span>;   <span class="hljs-comment">/* 下一个扇区还是写不完 */</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                secremain = datalen;<span class="hljs-comment">/* 下一个扇区可以写完了 */</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p><strong>扩展</strong></p><ul><li>SPI不仅仅只有4线的，还有6线的。多出来两根数据线，这样可以一个时钟周期传输两个字节</li></ul></li></ul><h1 id="4、控制局域网总线（CAN）"><a href="#4、控制局域网总线（CAN）" class="headerlink" title="4、控制局域网总线（CAN）"></a>4、控制局域网总线（CAN）</h1><h2 id="4-1简介"><a href="#4-1简介" class="headerlink" title="4.1简介"></a>4.1简介</h2><ul><li>控制器局域网总线（CAN，Controller Area Network）是一种用于实时应用的串行通讯协议总线，它可以使用双绞线来传输信号，是世界上应用最广泛的现场总线之一。CAN协议用于汽车中各种不同元件之间的通信，以此取代昂贵而笨重的配电线束。该协议的健壮性使其用途延伸到其他自动化和工业应用。CAN协议的特性包括完整性的串行数据通讯、提供实时支持、传输速率高达1Mb&#x2F;s、同时具有11位的寻址以及检错能力。</li></ul><h2 id="4-2CAN总线结构"><a href="#4-2CAN总线结构" class="headerlink" title="4.2CAN总线结构"></a>4.2CAN总线结构</h2><ul><li><strong>闭环总线结构</strong>：如图所示，总线两端各连接一个120欧的电阻，两根信号线形成回路。这种CAN总线网络由ISO 11898标准定义，是高速、短距离的CAN网络，通信速率为125kbit&#x2F;s到1Mbit&#x2F;s。在1Mbit&#x2F;s通讯速率时，总线长度最长达40m。<ul><li><img src="/./../photo/%E9%97%AD%E7%8E%AFCAN%E7%BB%93%E6%9E%84.png" alt="总线结构图"></li></ul></li><li><strong>开环总线结构</strong>：两根信号线独立，各自串联一个2.2k欧的电阻。这种CAN总线网络由ISO11519-2标准定义，是低速、远距离的CAN网络，通信速率最高125kbit&#x2F;s。在40kbit&#x2F;s速率时，总线最长距离可达1000m。<ul><li><img src="/./../photo/%E5%BC%80%E7%8E%AF%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="示意图"></li></ul></li><li><strong>CAN总线特性</strong>：CAN总线由两根信号线，CANH和CANL，没有时钟同步信号。所以CAN是一种异步通信方式。两根信号线的电压差CANH-CANL表示CAN总线的电平，与传输的逻辑信号1或0对应。对应于逻辑1的称为隐性（Recessive）电平，对应于逻辑0成为显性（Dominant）电平。<ul><li><img src="/./../photo/%E9%80%BB%E8%BE%91%E7%94%B5%E5%B9%B3%E4%BF%A1%E5%8F%B7.png" alt="示意图"></li><li>在开环跟闭环的结构里面，隐形电平和显型电平对应的电压值略有不同</li><li>隐性电平表示逻辑1</li><li>显性电平表示逻辑0</li></ul></li><li><strong>CAN总线特点</strong>:<ul><li><strong>实时性：</strong> CAN总线具有优越的实时性能，适用于需要及时传输数据的应用，如汽车控制系统、工业自动化等。仲裁机制和帧优先级的设计保证了低延迟和可预测性。<strong>多主机系统：</strong> CAN支持多主机系统，多个节点可以同时发送和接收数据。<strong>差分信号传输：</strong> CAN使用差分信号传输，通过两个线路（CAN_H和CAN_L）之间的电压差来传递信息。这种差分传输方式提供了良好的抗干扰性能。<strong>仲裁机制：</strong> CAN总线采用非破坏性仲裁机制，通过比较消息标识符的优先级来决定哪个节点有权继续发送数据。这种机制确保了总线上数据传输的有序性，避免了冲突。<strong>广播通信：</strong> CAN总线采用广播通信方式，即发送的数据帧可以被总线上的所有节点接收。<strong>错误检测和处理：</strong>CAN总线具有强大的错误检测和处理机制。通过CRC检查和其他错误检测手段。<strong>多种帧类型：</strong>CAN总线上的节点没有地址的概念。CAN总线上的数据是以帧为单位传输的，帧又分为数据帧、遥控帧等多种帧类型，帧包含需要传输的数据或控制信息。<strong>特定标识符</strong>：每一个帧有一个标识符（Identifier，一下简称ID）。ID不是地址，它表示传输数据的类型，也可以用于总线仲裁时确定优先级。<strong>滤波特性：</strong>每个CAN节点都接收数据，但是可以对接收的帧根据ID进行过滤。<strong>半双工：</strong>CAN总线通信时半双工的，即总线不能同时发送和接收。在多个节点竞争总线进行发送时，通过ID的优先级进行仲裁。<strong>无时钟信号：</strong>CAN总线没有用于同步的时钟信号，所以需要规定CAN总线通信的波特率，所以节点都是用同样的波特率进行通信。</li></ul></li></ul><h2 id="4-3CAN通信的重点（各种帧）"><a href="#4-3CAN通信的重点（各种帧）" class="headerlink" title="4.3CAN通信的重点（各种帧）"></a>4.3CAN通信的重点（各种帧）</h2><ul><li><p>CAN网络中通信通过5种类型的帧进行的。</p><ul><li><p>5种帧类型以及用途如下表</p><ul><li><table><thead><tr><th align="left">帧类型</th><th align="left">帧用途</th></tr></thead><tbody><tr><td align="left">数据帧（Data frame）</td><td align="left">节点发送的包含ID和数据的帧，用于发送单元向接收单元传送数据的帧。</td></tr><tr><td align="left">遥控帧（Remote frame）</td><td align="left">节点向网络上的其他节点发出的某个ID的数据请求，发送节点收到遥控帧后就可以发送相应ID的数据帧</td></tr><tr><td align="left">错误帧（Error frame）</td><td align="left">节点检测出错误时，向其他节点发送的通知错误的帧</td></tr><tr><td align="left">过载帧（Overload frame）</td><td align="left">接收单元未做好接收数据的准备时发送的帧，发送节点收到过载帧后可以暂缓发送数据帧</td></tr><tr><td align="left">帧间空间（Inter-frame space）</td><td align="left">用于将数据帧、遥控帧与前后的帧分隔开的帧</td></tr></tbody></table></li></ul></li></ul></li><li><p><strong>标准格式数据帧</strong>：由7个段构成，如下图</p><ul><li><p><img src="/./../photo/CAN%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="数据帧"></p><ul><li>帧起始:一位显性电平；</li><li>仲裁段禁止ID高7位全为隐性电平；</li><li>控制段，保留位r0必须以显性电平发送。DLC表示数据段的字节数</li><li>CRC段，根据多项式生成CRC校验码</li><li>ACK段：发送方的ACK发送2个位的隐性位，接收单元ACK，在ACK位发送一个显性位，通知接收正常</li><li>帧结束：7个隐性位构成。</li></ul></li></ul></li><li><p><strong>标准遥控帧</strong>：由6段构成，图示省略</p><ul><li>跟数据帧少了一个数据段<ul><li>遥控帧的RTR位为隐性位，没有数据段</li><li>遥控帧的数据长度码DLC以请求数据帧的数据长度码表示</li></ul></li></ul></li><li><p><strong>错误帧</strong>：用于在接收和发送消息时检测出错误通知错误的帧。错误帧由错误标志和错误界定符构成。如图所示</p><ul><li><img src="/./../photo/%E9%94%99%E8%AF%AF%E5%B8%A7.png" alt="错误帧"><ul><li>主动错误标志：6 个位的显性位。</li><li>被动错误标志：6 个位的隐性位。</li><li>错误界定符由 8 个位的隐性位构成。</li></ul></li></ul></li><li><p><strong>过载帧</strong>：过载帧是用于接收单元通知其尚未完成接收准备的帧。过载帧由过载标志和过载界定符构成。</p><ul><li>过载标志：6 个位的显性位。过载标志的构成与主动错误标志的构成相同。过载界定符：8 个位的隐性位。过载界定符的构成与错误界定符的构成相同。</li></ul></li><li><p><strong>帧间隔</strong>：帧间隔是用于分隔数据帧和遥控帧的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。</p><ul><li>间隔：3 个位的隐性位。总线空闲：隐性电平，无长度限制（0 亦可）。本状态下，可视为总线空闲，要发送的单元可开始访问总线。延迟传送（发送暂时停止）：8 个位的隐性位。只在处于被动错误状态的单元刚发送一个消息后的帧间隔中包含的段。</li></ul></li></ul><h2 id="4-4CAN总线优先级及同步"><a href="#4-4CAN总线优先级及同步" class="headerlink" title="4.4CAN总线优先级及同步"></a>4.4CAN总线优先级及同步</h2><ul><li><p><strong>优先级决定</strong>：在总线空闲态，最先开始发送消息的单元获得发送权。多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的单元可继续发送。</p></li><li><p><strong>数据帧和遥控帧的优先级</strong>：具有相同 ID 的数据帧和遥控帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权，可继续发送。</p></li><li><p><strong>CAN通信错误种类</strong>：如下表</p><ul><li><img src="/./../photo/CAN%E9%80%9A%E4%BF%A1%E9%94%99%E8%AF%AF.png" alt="错误表"></li></ul></li><li><p><strong>位时序</strong>：由发送单元在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为 4 段。同步段（SS）传播时间段（PTS）</p><p>相位缓冲段 1（PBS1）相位缓冲段 2（PBS2）这些段又由可称为 Time Quantum（以下称为 Tq）的最小时间单位构成。</p></li><li><p><strong>CAN通信同步的方法</strong>：CAN 协议的通信方法为 NRZ（Non-Return to Zero）方式。各个位的开头或者结尾都没有附加同步信号。发送单元以与位时序同步的方式开始发送数据。另外，接收单元根据总线上电平的变化进行同步并进行接收工作。但是，发送单元和接收单元存在的时钟频率误差及传输路径上的（电缆、驱动器等）相位延迟会引起同步偏差。因此接收单元通过硬件同步或者再同步的方法调整时序进行接收。</p></li></ul><h2 id="4-5CAN实例操作"><a href="#4-5CAN实例操作" class="headerlink" title="4.5CAN实例操作"></a>4.5CAN实例操作</h2><ul><li><p>基于stm32的CAN通信</p><ul><li><p>CAN 发送流程为：程序选择 1 个空置的邮箱（TME&#x3D;1）→设置标识符（ID），数据长度和 发送数据→设置 CAN_TIxR 的 TXRQ 位为 1，请求发送→邮箱挂号（等待成为最高优先级）→ 预定发送（等待总线空闲）→发送→邮箱空置。</p></li><li><p>CAN 接收到的有效报文，被存储在 3 级邮箱深度的 FIFO 中。CAN 接收流程为：FIFO 空→收到有效报文→挂号1（存入 FIFO 的一个邮箱，这个由硬件 控制，我们不需要理会）→收到有效报文→挂号2→收到有效报文→挂号_3→收到有效报文溢 出。</p></li><li><p>重点是构造发送的数据消息，跟接收的数据消息配置。</p></li><li><p>并且配置的时候有多种模式可选择，比如回环模式和正常模式</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*HAL库配置CAN控制器,简略代码，列出关键,以CAN1为例子*/</span><br>CAN_HandleTypeDef   g_canx_handler;     <span class="hljs-comment">/* CANx句柄 */</span><br>CAN_TxHeaderTypeDef g_canx_txheader;    <span class="hljs-comment">/* 发送参数句柄 */</span><br>CAN_RxHeaderTypeDef g_canx_rxheader;    <span class="hljs-comment">/* 接收参数句柄 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">can_init</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> tsjw, <span class="hljs-type">uint32_t</span> tbs2, <span class="hljs-type">uint32_t</span> tbs1, <span class="hljs-type">uint16_t</span> brp, <span class="hljs-type">uint32_t</span> mode)</span><br>&#123;<br>    <span class="hljs-comment">/*CAN的各种配置*/</span><br>    ...代码省略<br>    HAL_CAN_Init(&amp;g_canx_handler);<span class="hljs-comment">//HAL_CAN_Init()-&gt;内部调用HAL_CAN_MspInit()</span><br>    <span class="hljs-comment">/*配置CAN的过滤操作*/</span><br>    CAN_FilterTypeDef sFilterConfig;<br>    ...配置过程省略<br>    HAL_CAN_ConfigFilter(&amp;g_canx_handler, &amp;sFilterConfig)<br>    <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_CAN_MspInit</span><span class="hljs-params">(CAN_HandleTypeDef *hcan)</span><span class="hljs-comment">//用来配置CAN相关的引脚的状态</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (CAN1 == hcan-&gt;Instance)<br>    &#123;<br>        __HAL_RCC_GPIOX_CLK_ENABLE();<br>        __HAL_RCC_CAN1_CLK_ENABLE();<br>        GPIO_InitTypeDef gpio_initure;<br>        ...具体配置省略<br>        HAL_GPIO_Init(GPIOX, &amp;gpio_initure);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">can_send_msg</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> id, <span class="hljs-type">uint8_t</span> *msg, <span class="hljs-type">uint8_t</span> len)</span><br>&#123;<br>      <span class="hljs-type">uint32_t</span> TxMailbox = CAN_TX_MAILBOX0;<br>    <br>      g_canx_txheader.StdId = id;         <span class="hljs-comment">/* 标准标识符 */</span><br>      g_canx_txheader.ExtId = id;         <span class="hljs-comment">/* 扩展标识符(29位) 标准标识符情况下，该成员无效*/</span><br>      g_canx_txheader.IDE = CAN_ID_STD;   <span class="hljs-comment">/* 使用标准标识符 */</span><br>      g_canx_txheader.RTR = CAN_RTR_DATA; <span class="hljs-comment">/* 数据帧 */</span><br>      g_canx_txheader.DLC = len;<br><br>  <span class="hljs-keyword">if</span> (HAL_CAN_AddTxMessage(&amp;g_canx_handler, &amp;g_canx_txheader, msg, &amp;TxMailbox) != HAL_OK) <span class="hljs-comment">/* 发送消息 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">while</span> (HAL_CAN_GetTxMailboxesFreeLevel(&amp;g_canx_handler) != <span class="hljs-number">3</span>); <span class="hljs-comment">/* 等待发送完成,所有邮箱(有三个邮箱)为空 */</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">can_receive_msg</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> id, <span class="hljs-type">uint8_t</span> *buf)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (HAL_CAN_GetRxFifoFillLevel(&amp;g_canx_handler, CAN_RX_FIFO0) == <span class="hljs-number">0</span>)     <span class="hljs-comment">/* 没有接收到数据 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (HAL_CAN_GetRxMessage(&amp;g_canx_handler, CAN_RX_FIFO0, &amp;g_canx_rxheader, buf) != HAL_OK)  <span class="hljs-comment">/* 读取数据 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (g_canx_rxheader.StdId!= id || g_canx_rxheader.IDE != CAN_ID_STD || g_canx_rxheader.RTR != CAN_RTR_DATA)       <span class="hljs-comment">/* 接收到的ID不对 / 不是标准帧 / 不是数据帧 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>  &#125;<br><br>  <span class="hljs-keyword">return</span> g_canx_rxheader.DLC;<br>&#125;<br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
