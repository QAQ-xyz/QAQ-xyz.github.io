<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>操作系统</title>
    <link href="/2024/06/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/06/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><h2 id="何为进程和线程"><a href="#何为进程和线程" class="headerlink" title="何为进程和线程"></a>何为进程和线程</h2><ul><li><p>进程</p><p>是<strong>资源分配</strong>的最小单位，它是程序执行时的一个实例，在程序运行时创建</p></li><li><p>线程</p><p>是<strong>程序执行</strong>的最小单位，也是<strong>处理器调度</strong>的基本单位，是进程的一个执行流，<strong>一个进程由多个线程组成的</strong></p></li></ul><h2 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h2><ul><li><p><strong>进程有自己的独立地址空间</strong>，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代 码段、堆栈段和数据段，这种操作非常昂贵；而<strong>线程是共享进程中的数据</strong>，<strong>使用相同的地址空间</strong>， 因此，CPU切换一个线程的花费远比进程小很多，同时创建一个线程的开销也比进程小很多</p></li><li><p><strong>线程之间的通信更方便</strong>，同一进程下的线程共享全局变量、静态变量等数据，而<strong>进程之间的通信需 要以通信的方式（IPC）进行</strong>。不过如何处理好同步与互斥是编写多线程程序的难点。但是<strong>多进程程序更健壮</strong>，<strong>多线程程序只要有一个线程死掉，整个进程也跟着死掉了，而一个进程死掉并不会对另 外一个进程造成影响，因为进程有自己独立的地址空间</strong>**</p></li><li><p><strong>进程切换时，消耗的资源大，效率低</strong>。所以涉及到频繁的切换时，使用线程要好于进程。同样如果 要求同时进行并且又要共享某些变量的并发操作，只能用线程不能用进程</p></li><li><p>执行过程：<strong>每个独立的进程有一个程序运行的入口、顺序执行序列和程序入口</strong>。但是<strong>线程不能独立执行</strong>，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p></li><li><p><strong>线程执行开销小，但是不利于资源的管理和保护</strong>。线程适合在SMP机器（双CPU系统）上运行。进<strong>程执行开销大，但是能够很好的进行资源管理和保护</strong>，可以跨机器迁移。</p></li></ul><h2 id="何时使用多进程，何时使用多线程？"><a href="#何时使用多进程，何时使用多线程？" class="headerlink" title="何时使用多进程，何时使用多线程？"></a>何时使用多进程，何时使用多线程？</h2><p>对资源的管理和保护要求高，不限制开销和效率时，使用<strong>多进程</strong>。 </p><p>要求效率高，频繁切换时，资源的保护管理要求不是很高时，使用<strong>多线程</strong>。</p><h2 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h2><p><img src="/./../photo/image-20231212142116596.png" alt="image-20231212142116596"></p><ul><li><p>创建态</p><p>一个应用程序从系统上启动，首先就是进入创建状态，需要获取系统资源创建进程管理块（PCB： Process Control Block）完成资源分配</p></li><li><p>就绪态</p><p>在创建状态完成之后，进程已经准备好，但是还未获得处理器资源，无法运行</p></li><li><p>运行态</p><p>获取处理器资源，被系统调度，开始进入运行状态。如果进程的时间片用完了就进入就绪状态</p></li><li><p>阻塞态</p><p>在运行状态期间，如果进行了阻塞的操作，如耗时的I&#x2F;O操作，此时进程暂时无法操作就进入到了阻塞状 态，在这些操作完成后就进入就绪状态</p></li><li><p>终止态</p><p>进程结束或者被系统终止，进入终止状态</p></li></ul><h2 id="linux创建进程的方式"><a href="#linux创建进程的方式" class="headerlink" title="linux创建进程的方式"></a>linux创建进程的方式</h2><ul><li><p><strong>fork创建</strong></p><p>⼀个进程时，⼦进程只是完全复制⽗进程的资源，复制出来的⼦进程 有⾃⼰的t ask_struct结构和pi d, 但却复制⽗进程其它所有的资源。 </p></li><li><p><strong>vfork创建：</strong></p><p>系统调⽤不同于fork，⽤vfork创建的⼦进程与⽗进程共享地址空间， 也就是说⼦进程完全运⾏在⽗进程的地址空间上，如果这时⼦进程修改了某个变量， 这将影响到⽗进程 </p></li><li><p><strong>clone（）是带有参数的</strong></p></li></ul><p><strong>fork( ) 是全部复制，vfor k( ) 是共享内存，⽽clone( ) 是则可以将⽗进程资源有选择地复制给⼦进程</strong></p><h2 id="进程间的通信方式以及特点"><a href="#进程间的通信方式以及特点" class="headerlink" title="进程间的通信方式以及特点"></a>进程间的通信方式以及特点</h2><ul><li><p>管道（pipe ）</p><ul><li><p>管道（无名管道）</p><p>这种通讯方式<strong>有两种限制</strong>，<strong>一是</strong>半双工的通信，数据只能单向流动，<strong>二是</strong>只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系</p></li><li><p>流管道（s_pipe）</p><p>去除了第一种限制,<strong>可以双向传输</strong>（全双工）</p></li><li><p>命名管道（FIFO）</p><p>克服了管道没有名字的限制，因此，除 具有管道所具有的功能外，它还<strong>允许无亲缘关系进程间的通信</strong></p></li></ul></li><li><p>信号量（semaphore）</p><p>信号量是一个<strong>计数器</strong>，可以用来<strong>控制多个进程对共享资源的访问</strong>。它常作为一种<strong>锁机制</strong>，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为<strong>进程间</strong>以及<strong>同一进程内不同线程之间</strong>的同步手段</p></li><li><p>消息队列（message queue）</p><p><strong>消息队列是由消息组成的链表</strong>，存放在内核中并由消息队列标识符标识。</p><p>消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加 消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承 载无格式字节流以及缓冲区大小受限等缺点。</p><p>息发送后可以⽴即返回，有消息系统来确保信息的可靠专递，消息发布者只管把消息发布到MQ中⽽不管谁来取， 消息使⽤者只管从MQ中取消息⽽不管谁发布的，这样发布者和使⽤者都不⽤知道对⽅的存在。</p></li><li><p>信号</p><p>信号是通讯⽅式，信号量是⼀个计数器，限制资源访问线程的数</p><p>信号是一种比较复杂的通信方式，用于<strong>通知接收进程某个事件已经发生</strong>。主要作为进程间以及同一进程 不同线程之间的同步手段。</p></li><li><p>共享内存</p><p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以 访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与 其他通信机制，如信号量，配合使用，来实现进程间的同步和通信</p></li><li><p>套字节</p><p>套解字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信</p><p>由I P地址可以唯⼀确定⼀台主机，但是准确来说，⽹络通讯中的双⽅并不是主机，⽽是运⾏在主机上的进程， 这样就需要进⼀步确定是主机中的哪个进程要进⾏⽹络通讯。因此，除了I P地址之外，还需要端⼝号来唯⼀确定主机中的通讯进程。 I P地址和端⼝号就构成了⼀个⽹络中的唯⼀标识符，即套接字</p></li></ul><p><strong>各通信方式的比较和优缺点：</strong></p><ul><li>管道 ：速度慢，容量有限，只有父子进程能通讯</li><li>FIFO ：任何进程间都能通讯，但速度慢。</li><li>消息队列 ：容量受到系统限制，且要注意第一次读的时候，要考虑上一次没有读完数据的问题，消息队列可以不再 局限于父子进程，而允许任意进程通过共享消息队列来实现进程间通信，并由系统调用函数来实现消息 发送和接收之间的同步，从而使得用户在使用消息缓冲进行通信时不再需要考虑同步问题，使用方便， 但是<strong>信息的复制需要额外消耗CPU的时间，不适宜于信息量大或操作频繁的场合</strong>。此种方法不太常用</li><li>信号量 ：不能用来传递复杂消息，只能用来同步</li><li>共享内存：利用内存缓冲区直接交换信息，无须复制，快捷、信息量大是其优点。共享内存块提供了在任意数量的 进程之间进行高效双向通信的机制。每个使用者都可以读取写入数据，但是所有程序之间必须达成并遵 守一定的协议，以防止诸如在读取信息之前覆写内存空间等竞争状态的出现</li></ul><p><strong>进程间通信方式的选择</strong>：</p><p>PIPE和FIFO(有名管道)用来实现进程间相互发送非常短小的、频率很高的消息，这两种方式通常适用于 <strong>两个进程间</strong>的通信。</p><p>共享内存用来实现进程间共享的、非常庞大的、读写操作频率很高的数据；这种方法适用于<strong>多进程间</strong>的 通信。</p><p>其他考虑用socket。主要应用在分布式开发中</p><h2 id="线程间的同步方式"><a href="#线程间的同步方式" class="headerlink" title="线程间的同步方式"></a>线程间的同步方式</h2><p>现在流行的进程线程同步互斥的控制机制，其实是由最原始、最基本的4种方法（临界区、互斥量、信号 量和事件）实现的</p><ul><li><p>临界区</p><p>通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意 时刻只允许一个线程访问共享资源，如果有多个线程试图访问共享资源，那么当有一个线程进入 后，其他试图访问共享资源的线程将会被挂起，并一直等到进入临界区的线程离开，临界在被释放 后，其他线程才可以抢占</p></li><li><p>互斥量</p><p>为协调对一个共享资源的单独访问而设计，只有拥有互斥量的线程，才有权限去访问系统 的公共资源，因为互斥量只有一个，所以能够保证资源不会同时被多个线程访问。互斥不仅能实现 同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享</p></li><li><p>信号量</p><p>为控制一个具有有限数量的用户资源而设计。它允许多个线程在同一个时刻去访问同一个 资源，但一般需要限制同一时刻访问此资源的最大线程数目</p></li><li><p>事件</p><p>用来通知线程有一些事件已发生，从而启动后继任务的开始</p></li></ul><h2 id="内核线程和用户线程"><a href="#内核线程和用户线程" class="headerlink" title="内核线程和用户线程"></a>内核线程和用户线程</h2><ul><li><p>内核线程</p><p>由操作系统内核创建和撤销。内核维护进程及线程的上下文信息以及线程切换。一个内核线 程由于I&#x2F;O操作而阻塞，不会影响其它线程的运行</p></li><li><p>用户线程、</p><p>不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。不需要用户态&#x2F;核心态切换，速度快，操作 系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所有线程）阻塞。由于这 里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少</p></li></ul><h2 id="内核线程和用户线程的优缺点"><a href="#内核线程和用户线程的优缺点" class="headerlink" title="内核线程和用户线程的优缺点"></a>内核线程和用户线程的优缺点</h2><ol><li>内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。 </li><li>用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核 支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同 的。 </li><li>用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时， 只导致该线程被中断。 </li><li>在只有<strong>用户级线程的系统</strong>内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由 用户程序控制线程的轮换运行；在有<strong>内核支持线程的系统</strong>内，CPU调度则以线程为单位，由OS的线 程调度程序负责线程的调度。 </li><li>用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何 状态下的程序。</li></ol><p><strong>内核线程的优点：</strong> 当有多个处理机时，一个进程的多个线程可以同时执行。</p><p><strong>内核线程的缺点：</strong> 由内核进行调度。</p><p><strong>用户线程的优点：</strong></p><ol><li>线程的调度不需要内核直接参与，控制简单。 </li><li>可以在不支持线程的操作系统中实现。 </li><li>创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。 </li><li>允许每个进程定制自己的调度算法，线程管理比较灵活。这就是必须自己写管理程序，与内核线程 的区别 </li><li>线程能够利用的表空间和堆栈空间比内核级线程多。 </li><li>同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都 会被挂起。另外，页面失效也会产生同样的问题。</li></ol><p><strong>用户线程的缺点：</strong>资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</p><h2 id="僵尸进程、孤儿进程、守护进程"><a href="#僵尸进程、孤儿进程、守护进程" class="headerlink" title="僵尸进程、孤儿进程、守护进程"></a>僵尸进程、孤儿进程、守护进程</h2><ul><li><p>僵尸进程</p><p>是 一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子 进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程</p><p>fork的本质，就是复制，把当前进程复制⼀份，然后两个进程并发地执⾏for k后⾯的语句，</p></li><li><p>孤儿进程</p><p>⽗进程结束了，⽽它的⼀个或多个⼦进程还在运⾏，那么这些⼦进程就成为孤⼉进程(fat her di ed) 。⼦进程的资源由init进程( 进程号PID &#x3D; 1) 回收</p></li><li><p>守护进程</p><p>建守护进程时有意把父进程结束，然后被1号进程init收养</p><p>是运⾏在后台的⼀种特殊进程。它独⽴于控制终端并且周期性地执⾏某种任务或等待处理某些发⽣的事件</p></li></ul><p><strong>区分：</strong> 一个正常运行的子进程，如果此刻子进程退出，父进程没有及时调用wait或waitpid收回子进程 的系统资源，该进程就是僵尸进程，如果系统收回了，就是正常退出，如果一个正常运行的子进程，父 进程退出了但是子进程还在，该进程此刻是孤儿进程，被init收养，如果父进程是故意被杀掉，子进程做 相应处理后就是守护进程</p><h2 id="僵尸进程的危害"><a href="#僵尸进程的危害" class="headerlink" title="僵尸进程的危害"></a>僵尸进程的危害</h2><p>在进程退出的时候，内核释放该进程所有的资源，包括打开的文件，占用的内存等。但是仍然为其保留 一定的信息(包括进程号 PID，退出状态 the termination status of the process，运行时间 the amount  of CPU time taken by the process 等)。直到父进程通过 wait &#x2F; waitpid 来取时才释放。 </p><p>如果进程不调用 wait &#x2F; waitpid 的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但 是系统所能使用的进程号是有限的，<strong>如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不 能产生新的进程</strong></p><h2 id="如何清理僵尸进程"><a href="#如何清理僵尸进程" class="headerlink" title="如何清理僵尸进程"></a>如何清理僵尸进程</h2><p>僵尸进程的产生是因为父进程没有 wait() 子进程。所以如果我们自己写程序的话一定要在父进程中通过  wait() 来避免僵尸进程的产生</p><p>当系统中出现了僵尸进程时，我们是无法通过 kill 命令把它清除掉的。但是我们可以杀死它的父进程， 让它变成孤儿进程，并进一步被系统中管理孤儿进程的进程收养并清理。</p><p>1.kill 杀死元凶⽗进程( ⼀般不⽤) 严格的说，僵⼫进程并不是问题的根源，罪魁祸⾸是产⽣⼤量僵死进程的⽗进程。 因此，我们可以直接除掉元凶，通过ki l l 发送SI GTERM或者SI GKI LL信号。元凶死后，僵⼫进程进程变成孤⼉进程，由i ni t充当⽗进程，并回收资源。 或者运⾏：ki l l -9 ⽗进程的pi d值</p><p>2.⽗进程⽤wai t或wai tpi d去回收资源( ⽅案不好) ⽗进程通过wai t或wai tpi d等函数去等待⼦进程结束，但是不好，会导致⽗进程⼀直等待被挂起，相当于⼀个进程在⼲活，没有起到多进程的作⽤。 </p><p>3.通过信号机制，在处理函数中调⽤wai t，回收资源 通过信号机制，⼦进程退出时向⽗进程发送SI GCHLD信号，⽗进程调⽤si gnal ( SI GCHLD, si g_chi l d) 去处理SI GCHLD信号， 在信号处理函数si g_chi l d( ) 中调⽤wai t进⾏处理僵⼫进程。什么时候得到⼦进程信号，什么时候进⾏信号处理，⽗进程可以继续⼲其他活，不⽤去阻塞等待。</p><h2 id="如何唤醒被阻塞的socket线程"><a href="#如何唤醒被阻塞的socket线程" class="headerlink" title="如何唤醒被阻塞的socket线程"></a>如何唤醒被阻塞的socket线程</h2><ul><li><p>同步阻塞</p><p>等待锁的释放</p></li><li><p>等待阻塞</p><ul><li>使用Thread.sleep造成的阻塞:时间结束后自动进入RUNNABLE状态 </li><li>使用Thread.wait造成的阻塞:使用Thread.notify或者Thread.notifyAll唤醒 </li><li>使用Thread.join造成的阻塞:等待上一个线程执行完后自动进入RUNNABLE状态 </li><li>使用Thread.suspend造成的阻塞:使用Thread.resum唤醒 </li><li>使用LockSupport.park造成的阻塞:使用LockSupport.unpark唤醒 </li><li>使用LockSupport.parkNanos造成的阻塞:指定时间结束后，自动唤醒 </li><li>使用LockSupport.parkUntil造成的阻塞:到达指定的时间，自动唤醒</li></ul></li></ul><h2 id="确定当前线程是繁忙还是阻塞"><a href="#确定当前线程是繁忙还是阻塞" class="headerlink" title="确定当前线程是繁忙还是阻塞"></a>确定当前线程是繁忙还是阻塞</h2><p>使用ps命令查看</p><h2 id="空闲和阻塞的进程会在唤醒的时候判误吗"><a href="#空闲和阻塞的进程会在唤醒的时候判误吗" class="headerlink" title="空闲和阻塞的进程会在唤醒的时候判误吗"></a>空闲和阻塞的进程会在唤醒的时候判误吗</h2><p>不会。每个进程有个进程控制块PCB，两种状态的进程分别处于两种队列。唤醒应该是找阻塞队列的进 程</p><h2 id="就绪态的进程在等待什么"><a href="#就绪态的进程在等待什么" class="headerlink" title="就绪态的进程在等待什么"></a>就绪态的进程在等待什么</h2><p>被调度使用cpu的运行权</p><h2 id="如何实现线程池"><a href="#如何实现线程池" class="headerlink" title="如何实现线程池"></a>如何实现线程池</h2><ol><li>设置一个生产者消费者队列，作为临界资源 </li><li>初始化n个线程，并让其运行起来，加锁去队列取任务运行 </li><li>当任务队列为空的时候，所有线程阻塞 </li><li>当生产者队列来了一个任务后，先对队列加锁，把任务挂在到队列上，然后使用条件变量去通知阻 塞中的一个线程</li></ol><h2 id="fork和vfork"><a href="#fork和vfork" class="headerlink" title="fork和vfork"></a>fork和vfork</h2><p><strong>fork的基础知识：</strong></p><p>创建一个和当前进程映像一样的进程可以通过fork( )系统调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">fork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p><strong>成功调用fork( )会创建一个新的进程，它几乎与调用fork( )的进程一模一样，这两个进程都会继续 运行。在子进程中，成功的fork( )调用会返回0。在父进程中fork( )返回子进程的pid。如果出现错 误，fork( )返回一个负值</strong>。 最常见的fork( )用法是创建一个新的进程，然后使用exec( )载入二 进制映像，替换当前进程的映像。这种情况下，派生（fork）了新的进程，而这个子进程会执行一 个新的二进制可执行文件的映像。这种“派生加执行”的方式是很常见的。 在早期的Unix系统 中，创建进程比较原始。当调用fork时，内核会把所有的内部数据结构复制一份，复制进程的页表 项，然后把父进程的地址空间中的内容逐页的复制到子进程的地址空间中。但从内核角度来说，逐 页的复制方式是十分耗时的。现代的Unix系统采取了更多的优化，例如Linux，采用了写时复制的 方法，而不是对父进程空间进程整体复制。</p><p><strong>vfork的基础知识：</strong></p><p>在实现写时复制之前，Unix的设计者们就一直很关注在fork后立刻执行exec所造成 的地址空间的浪费。BSD的开发者们在3.0的BSD系统中引入了vfork( )系统调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">pid_t</span> <span class="hljs-title">vfork</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>除了子进程必须要立刻执行一次对exec的系统调用，或者调用_exit( )退出，对vfork( )的成功调用 所产生的结果和fork( )是一样的。vfork( )会挂起父进程直到子进程终止或者运行了一个新的可执行 文件的映像。通过这样的方式，vfork( )避免了地址空间的按页复制。在这个过程中，父进程和子 进程共享相同的地址空间和页表项。实际上vfork( )只完成了一件事：复制内部的内核数据结构。 因此，子进程也就不能修改地址空间中的任何内存。 vfork( )是一个历史遗留产物，Linux本 不应该实现它。需要注意的是，即使<strong>增加了写时复制，</strong>vfork( )也要比fork( )快，因为它没有进行页 表项的复制。然而，写时复制的出现减少了对于替换fork( )争论。实际上，直到2.2.0内核，vfork(  )只是一个封装过的fork( )。因为对vfork( )的需求要小于fork( )，所以vfork( )的这种实现方式是可 行的。 </p><p><strong>fork和vfork的区别：</strong> </p><ol><li>fork( )的子进程拷贝父进程的数据段和代码段；vfork( )的子进程与父进程共享数据段 </li><li>fork( )的父子进程的执行次序不确定；vfork( )保证子进程先运行，在调用exec或exit之前与父进程 数据是共享的，在它调用exec或exit之后父进程才可能被调度运行。 </li><li>vfork( )保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行。如果在调用这两个 函数之前子进程依赖于父进程的进一步动作，则会导致死锁。  </li><li>当需要改变共享数据段中变量的值，则拷贝父进程。</li></ol><h2 id="server端监听端口，此时进程处于什么状态"><a href="#server端监听端口，此时进程处于什么状态" class="headerlink" title="server端监听端口，此时进程处于什么状态"></a>server端监听端口，此时进程处于什么状态</h2><p>最普通的Server模型，则处于阻塞状态；如果使用IO复用中epoll、select等，则处于运行状态</p><h2 id="阻塞态和挂起态"><a href="#阻塞态和挂起态" class="headerlink" title="阻塞态和挂起态"></a>阻塞态和挂起态</h2><p>线程在运⾏的过程中因为某些原因⽽发⽣阻塞，阻塞状态的线程的特点是：该线程放弃CPU的使⽤， 暂停运⾏，只有等到导致阻塞的原因消除之后才回复运⾏。或者是被其他的线程中断，该线程也会退出阻塞状态. 正在执⾏的进程由于发⽣某时间（如I &#x2F;O请求、申请缓冲区失败等）暂时⽆法继续执⾏。此时引起进程调度， OS把处理机分配给另⼀个就绪进程，⽽让受阻进程处于暂停状态，⼀般将这种状态称为阻塞状态。</p><p>挂起进程在操作系统中可以定义为暂时被淘汰出内存的进程，机器的资源是有限的，在资源不⾜的情况下， 操作系统对在内存中的程序进⾏合理的安排，其中有的进程被暂时调离出内存，当条件允许的时候，会被操作系统再次调回内存， 重新进⼊等待被执⾏的状态即就绪态</p><p>共同点： 1. 进程都暂停执⾏ 2. 进程都释放CPU，即两个过程都会涉及上下⽂切换</p><h1 id="堆和栈"><a href="#堆和栈" class="headerlink" title="堆和栈"></a>堆和栈</h1><h2 id="代码段、数据段、bss段、堆、栈"><a href="#代码段、数据段、bss段、堆、栈" class="headerlink" title="代码段、数据段、bss段、堆、栈"></a>代码段、数据段、bss段、堆、栈</h2><ul><li><p><strong>代码段</strong></p><p>代码段通常用来存放程序<strong>执行代码</strong>的一块区域。这部分区域的大小在程序运行前就已经确定了，通常这块内存区域属于只读，有些架构也允许可写，在代码段中也有可能包含以下只读的常数变量，例如字符串常量等。程序段为程序代码在内存中映射一个程序可以在内存中有多个副本</p></li><li><p><strong>数据段</strong></p><p>数据段通常用来存放程序中<strong>已初始化的全局变量和已初始化为非0的静态变量</strong>的一块内存区域，属于静态内存分配。直观理解就是C语言程序中的全局变量（注意：<strong>全局变量才算是程序的数据， 局部变量不算程序的数据，只能算是函数的数据</strong>）</p></li><li><p><strong>bss段</strong></p><p>bss段通常是指用来存放程序中<strong>未初始化的全局变量和未初始化的静态变量或者初始化为0的静 态变量</strong>一块区域。bss英文Block started by symbol，bss属于静态内存分配。bss段的特点就是被初始 化为0，<strong>bss段本质上也是属于数据段</strong>，bss段就是被初始化为0的数据段。 注意区分</p><p><strong>数据段（.data）和bss段的区别和联系：</strong>二者本来没有本质区别，都是用来存放C程序中的全局变量的。区别在于把显示初始化为非零的全局变量存在**.data段<strong>中，而把显式初始化为0或者并未显式 初始化（C语言规定未显式初始化的全局变量值默认为0）的全局变量存在</strong>bss段**</p></li><li><p><strong>堆</strong></p><p>堆是用来存放进程中被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。当进程调用 malloc等函数分配内存时，新分配的内存就被动态分配到堆上，当利用free等函数释放内存时，被释放 的内存从堆中被剔除</p></li><li><p><strong>栈</strong></p><p>栈又称堆栈，是用户存放程序临时创建的变量，也就是我们函数{}中定义的变量，但不包括static声 明的变量，static意味着在数据段中存放变量。除此之外，在函数被调用时，其参数也会被压入发起调用 的进程栈中，并且待到调用结束后，函数的返回值也会被存放回栈中，由于栈的先进后出特点，所以栈 特别方便用来保存、恢复调用现场。从这个意义上讲，我们可以把堆栈看成一个寄存，交换临时数据的 内存区</p></li></ul><h2 id="为什么堆的空间不连续"><a href="#为什么堆的空间不连续" class="headerlink" title="为什么堆的空间不连续"></a>为什么堆的空间不连续</h2><p>堆包含一个链表来维护已用和空闲的内存块。在堆上新分配（用 new 或者 malloc）内存是从空闲的内 存块中找到一些满足要求的合适块。所以可能让人觉得只要有很多不连续的零散的小区域，只要总数达 到申请的内存块，就可以分配。</p><p>但事实上是不行的，这又让人觉得是不是零散的内存块不能连接成一个大的空间，而必须要一整块连续 的内存空间才能申请成功呢</p><p>申请和释放许多小的块可能会产生如下状态：在已用块之间存在很多小的空闲块。进而申请大块内存失 败，虽然空闲块的总和足够，但是<strong>空闲的小块是零散的，不连续的</strong>，不能满足申请的大小，这叫做“堆碎 片”</p><p>当旁边有空闲块的已用块被释放时，新的空闲块会与相连的空闲块合并成一个大的空闲块，这样就可以 有效的减少”堆碎片”的产生</p><p><strong>堆分配的空间在逻辑地址（虚拟地址）上是连续的，但在物理地址上是不连续的</strong>（因为采用了页式内存 管理,windows下有段机制、分页机制），如果逻辑地址空间上已经没有一段连续且足够大的空间，则分 配内存失败</p><h2 id="用户栈和内核栈"><a href="#用户栈和内核栈" class="headerlink" title="用户栈和内核栈"></a>用户栈和内核栈</h2><ul><li><p>内核栈、</p><p>内存中属于操作系统空间的一块区域</p><p>作用：</p><pre><code class="hljs">1. 保存中断现场，对于嵌套中断，被中断程序的现场信息一次压入系统栈，中断返回时逆序弹出  2. 保存操作系统程序相互调用的参数，返回值，以及函数的局部变量</code></pre></li><li><p>用户栈</p><p>用户进程空间的一块区域，用于保存用户空间子程序间调用的参数，返回值以及局部变量。</p></li></ul><h2 id="为什么用户栈和内核栈不能共用一个栈"><a href="#为什么用户栈和内核栈不能共用一个栈" class="headerlink" title="为什么用户栈和内核栈不能共用一个栈"></a>为什么用户栈和内核栈不能共用一个栈</h2><ol><li>如果只用系统栈，系统栈一般大小有限，用户程序调用次数可能很多。如果中断有16个优先级，那 么系统栈一般大小为15（只需保存15个低优先级中断，另一个高优先级中断在运行）用户程序调用 次数很多，那样15次子程序调用以后的子程序的参数，返回值，局部变量就不能保存，用户程序也 就不能正常运行。</li><li>如果只用用户栈，系统程序需要在某种保护下运行，而用户栈在用户空间不能提供相应的保护措 施</li></ol><h2 id="线程是否有相同的堆栈"><a href="#线程是否有相同的堆栈" class="headerlink" title="线程是否有相同的堆栈"></a>线程是否有相同的堆栈</h2><p>真正的程序执行都是线程来完成的，程序启动的时候操作系统就帮你创建了一个主线程。 每个线程有自己的堆栈</p><h1 id="并发和互斥"><a href="#并发和互斥" class="headerlink" title="并发和互斥"></a>并发和互斥</h1><h2 id="并发和互斥如何实现"><a href="#并发和互斥如何实现" class="headerlink" title="并发和互斥如何实现"></a>并发和互斥如何实现</h2><p>并发，指的是多个执行单元同时、并行被执行，而并发的执行单元对共享资源（硬件资源和软件上的全 局变量、静态变量等）的访问则很容易导致竞态</p><p>解决竞态问题的途径是保证对共享资源的互斥访问，所谓互斥访问就是指一个执行单元在访问共享资源 的时候，其他的执行单元都被禁止访问</p><p>访问共享资源的代码区域被称为临界区，临界区需要以某种互斥机制加以保护。中断屏蔽，原子操作， 自旋锁，和信号量都是linux设备驱动中可采用的互斥途径</p><h2 id="自旋锁、信号量"><a href="#自旋锁、信号量" class="headerlink" title="自旋锁、信号量"></a>自旋锁、信号量</h2><ul><li><p><strong>自旋锁</strong></p><p>自旋锁，顾名思义，我们可以把他理解成厕所门上的一把锁。这个厕所门只有一把钥匙，当我们进去 时，把钥匙取下来，进去后反锁。那么当第二个人想进来，必须等我们出去后才可以。当第二个人在外 面等待时，可能会一直等待在门口转圈。 </p><p>我们的自旋锁也是这样，自旋锁只有锁定和解锁两个状态。当我们进入拿上钥匙进入厕所，这就相当于 自旋锁锁定的状态，期间谁也不可以进来。当第二个人想要进来，这相当于线程B想要访问这个共享资 源，但是目前不能访问，所以线程B就一直在原地等待，一直查询是否可以访问这个共享资源。当我们 从厕所出来后，这个时候就“解锁”了，只有再这个时候线程B才能访问。 </p><p>假如，在厕所的人待的时间太长怎么办？外面的人一直等待吗？如果换做是我们，肯定不会这样，简直 浪费时间，可能我们会寻找其他方法解决问题。自旋锁也是这样的，如果线程A<strong>持有自旋锁时间过长， 显然会浪费处理器的时间，降低了系统性能</strong>。我们知道CPU最伟大的发明就在于多线程操作，这个时候 让线程B在这里傻傻的不知道还要等待多久，显然是不合理的。因此，如果<strong>自旋锁只适合短期持有</strong>，如果遇到需要长时间持有的情况，我们就要换一种方式了（互斥体）</p></li><li><p><strong>信号量</strong></p><p>信号量和自旋锁有些相似，不同的是信号量会发出一个信号告诉你还需要等多久。因此，不会出现傻傻 等待的情况。比如，有100个停车位的停车场，门口电子显示屏上实时更新的停车数量就是一个信号 量。这个停车的数量就是一个信号量，他告诉我们是否可以停车进去。当有车开进去，信号量加一，当 有车开出来，信号量减一</p><p>比如，厕所一次只能让一个人进去，当A在里面的时候，B想进去，如果是自旋锁，那么B就会一直在门 口傻傻等待。如果是信号量，A就会给B一个信号，你先回去吧，我出来了叫你。这就是一个信号量的例 子，B听到A发出的信号后，可以先回去睡觉，等待A出来</p><p>因此，信号量显然可以提高系统的执行效率，避免了许多无用功。</p></li><li><p><strong>区别</strong></p><ol><li>由于争用信号量的进程在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情 况。 </li><li>相反，锁被短时间持有时，使用信号量就不太适宜了，因为睡眠引起的耗时可能比锁被占用的全部 时间还要长。 </li><li>由于执行线程在锁被争用时会睡眠，所以只能在进程上下文中才能获取信号量锁，因为在中断上下 文中（使用自旋锁）是不能进行调度的。 </li><li>你可以在持有信号量时去睡眠（当然你也可能并不需要睡眠），因为当其它进程试图获得同一信号 量时不会因此而死锁，（因为该进程也只是去睡眠而已，而你最终会继续执行的）。 </li><li>在你占用信号量的同时不能占用自旋锁，因为在你等待信号量时可能会睡眠，而在持有自旋锁时是 不允许睡眠的</li><li>信号量锁保护的临界区可包含可能引起阻塞的代码，而自旋锁则绝对要避免用来保护包含这样代码 的临界区，因为阻塞意味着要进行进程的切换，如果进程被切换出去后，另一进程企图获取本自旋 锁，死锁就会发生。 </li><li>信号量不同于自旋锁，它不会禁止内核抢占（自旋锁被持有时，内核不能被抢占），所以持有信号 量的代码可以被抢占，这意味着信号量不会对调度的等待时间带来负面影响</li></ol></li></ul><h2 id="自旋锁和信号量可以睡眠吗"><a href="#自旋锁和信号量可以睡眠吗" class="headerlink" title="自旋锁和信号量可以睡眠吗"></a>自旋锁和信号量可以睡眠吗</h2><p>自旋锁不能睡眠，信号量可以</p><p>自旋锁自旋锁禁止处理器抢占；而信号量不禁止处理器抢占</p><p>基于这个原因，如果自旋锁在锁住以后进入睡眠，由于不能进行处理器抢占，其他系统进程将都不能获 得CPU而运行，因此不能唤醒睡眠的自旋锁，因此系统将不响应任何操作（除了中断或多核的情况，下 面会讨论）。而信号量在临界区睡眠后，其他进程可以用抢占的方式继续运行，从而可以实现内存拷贝 等功能而使得睡眠的信号量程序由于获得了等待的资源而被唤醒，从而恢复了正常的代码运行</p><p>当然，自旋锁的睡眠的情况包含考虑多核CPU和中断的因素。自旋锁睡眠时，只是当前CPU的睡眠以及 当前CPU的禁止处理器抢占，所以，如果存在多个CPU，那么其他活动的CPU可以继续运行使操作系统 功能正常，并有可能完成相应工作而唤醒睡眠了的自旋锁，从而没有造成系统死机；自旋锁睡眠时，如 果允许中断处理，那么中断的代码是可以正常运行的，但是中断通常不会唤醒睡眠的自旋锁，因此系统 仍然运行不正常</p><h2 id="自旋锁和信号量可以用于中断中吗？"><a href="#自旋锁和信号量可以用于中断中吗？" class="headerlink" title="自旋锁和信号量可以用于中断中吗？"></a>自旋锁和信号量可以用于中断中吗？</h2><p>信号量不能用于中断中，因为信号量会引起休眠，<strong>中断不能休眠</strong></p><p>自旋锁可以用于中断。在获取锁之前<strong>一定要先禁止本地中断</strong>（也就是本CPU中断，对于多核SOC来说会 有多个CPU核），否则可能导致锁死现象的发生</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>临界区的一个文件可以被<strong>同时读取</strong>，但是并不能被同时读和写。如果一个线程在读，另一个线程在 写，那么很可能会读取到错误的不完整的数据。读写自旋锁是可以<strong>允许对临界区的共享资源进行并发读操作的。但是并不允许多个线程并发读写操作</strong></p><h2 id="产生死锁的原因"><a href="#产生死锁的原因" class="headerlink" title="产生死锁的原因"></a>产生死锁的原因</h2><p><strong>多个并发进程因争夺系统资源而产生相互等待的现象</strong>。即：一组进程中的每个进程都在等待某个事件发 生，而只有这组进程中的其他进程才能触发该事件，这就称这组进程发生了死锁。</p><p>死锁: 是指多个线程因竞争资源⽽造成的⼀种僵局（互相等待）</p><p><strong>产生死锁的本质原因为：</strong></p><ol><li>系统资源有限。 </li><li>进程推进顺序不合理。</li><li>信号量使⽤不当也会造成死锁。进程间彼此相互等待对⽅发来的消息，结果也会使得这 些进程间⽆法继续向前推进。例如， 进程A等待进程B发的消息，进程B⼜在等待进程A 发的消息，可以看出进程A和B不是因为竞争同⼀资源，⽽是在等待对⽅的资源导致死锁。</li></ol><h2 id="死锁的四个必要的条件"><a href="#死锁的四个必要的条件" class="headerlink" title="死锁的四个必要的条件"></a>死锁的四个必要的条件</h2><p>产⽣死锁必须同时满⾜以下四个条件，只要其中任⼀条件不成⽴，死锁就不会发⽣。</p><ol><li><strong>互斥</strong>：某种资源一次只允许一个进程访问，即该资源一旦分配给某个进程，其他进程就不能再访 问，直到该进程访问结束。</li><li><strong>占有且等待</strong>：一个进程本身占有资源（一种或多种），同时还有资源未得到满足，正在等待其他进 程释放该资源。</li><li><strong>不可抢占</strong>：别人已经占有了某项资源，你不能因为自己也需要该资源，就去把别人的资源抢过来。 </li><li><strong>循环等待</strong>：存在一个进程链，使得每个进程都占有下一个进程所需的至少一种资源</li></ol><p>当以上四个条件均满足，必然会造成死锁，发生死锁的进程无法进行下去，它们所持有的资源也无 法释放。这样会导致CPU的吞吐量下降。所以死锁情况是会浪费系统资源和影响计算机的使用性能的。 那么，解决死锁问题就是相当有必要的了</p><h2 id="死锁的处理方式"><a href="#死锁的处理方式" class="headerlink" title="死锁的处理方式"></a>死锁的处理方式</h2><p>死锁的处理方式主要从预防死锁、避免死锁、检测与解除死锁这四个方面来进行处理</p><ul><li><p>预防死锁</p></li><li><p>避免死锁</p></li><li><p>检测死锁</p><p>首先为每个进程和每个资源指定一个唯一的号码；然后建立资源分配表和进程等待表</p></li><li><p>解除死锁</p></li></ul><h2 id="如何避免死锁"><a href="#如何避免死锁" class="headerlink" title="如何避免死锁"></a>如何避免死锁</h2><ul><li>加锁顺序（线程按照一定的顺序加锁）</li><li>加锁时限（线程尝试获取锁的时候加上一定的时限，超过时限则放弃对该锁的请求，并释放自己占有的 锁）</li><li>死锁检测</li></ul><h2 id="单核机器上写多线程程序是否需要加锁"><a href="#单核机器上写多线程程序是否需要加锁" class="headerlink" title="单核机器上写多线程程序是否需要加锁"></a>单核机器上写多线程程序是否需要加锁</h2><p>在单核机器上写多线程程序，仍然需要线程锁。因为线程锁通常用来实现线程的同步和通信。在单核机 器上的多线程程序，仍然存在线程同步的问题。因为在抢占式操作系统中，通常为每个线程分配一个时 间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某 些数据，不使用线程锁的前提下，<strong>可能会导致共享数据修改引起冲突</strong></p><h1 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h1><h2 id="1G的计算机中可以malloc-1-2G-吗"><a href="#1G的计算机中可以malloc-1-2G-吗" class="headerlink" title="1G的计算机中可以malloc(1.2G)吗"></a>1G的计算机中可以malloc(1.2G)吗</h2><p><strong>malloc能够申请的空间大小与物理内存的大小没有直接关系，仅与程序的虚拟地址空间相关</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;     <br>      <span class="hljs-type">char</span>*p;<br>       constunsigned k= <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1.2</span>;    <br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x\n&quot;</span>,k);<br>       p= (<span class="hljs-type">char</span> *)<span class="hljs-built_in">malloc</span>( k );<br>       <span class="hljs-keyword">if</span>( p!=<span class="hljs-literal">NULL</span> )<br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;OK&quot;</span>);<br>       <span class="hljs-keyword">else</span><br>              <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>       return0;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="malloc能申请多大的空间"><a href="#malloc能申请多大的空间" class="headerlink" title="malloc能申请多大的空间"></a>malloc能申请多大的空间</h2><p>malloc能够申请的空间到底能达到多大，还真是一个比较复杂的问题。想知道在一台机器上malloc能够 申请的最大空间到底是多少，可以使用下面的程序进行测试。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-type">unsigned</span> maximum = <span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>       unsignedblocksize[] = &#123;<span class="hljs-number">1024</span>*<span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>, <span class="hljs-number">1</span>&#125;;<br>       inti, count;<br>       <span class="hljs-type">void</span>* block;<br>       <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-built_in">sizeof</span>(blocksize)/<span class="hljs-built_in">sizeof</span>(<span class="hljs-type">unsigned</span>); i++ )<br>       &#123;     <span class="hljs-keyword">for</span>( count = <span class="hljs-number">1</span>; ;count++ )<br>              &#123;     block = <span class="hljs-built_in">malloc</span>( maximum +blocksize[i]*count );<br>                     <span class="hljs-keyword">if</span>( block!=<span class="hljs-literal">NULL</span> ) &#123;<br>                            maximum= maximum + blocksize[i]*count;<br>                            <span class="hljs-built_in">free</span>(block );<br>                     &#125;<span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                     &#125;<br>              &#125;<br>       &#125;<br>       <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;maximummalloc size = %u bytes\n&quot;</span>, maximum);<br>       return0;<br>&#125;<br></code></pre></td></tr></table></figure><p>在当前正在使用的Windows环境中，可申请的最大空间超过1.9G。实际上，具体的数值会受到操作系统 版本、程序本身的大小、用到的动态&#x2F;共享库数量、大小、程序栈数量、大小等的影响，甚至每次运行的 结果都可能存在差异，因为有些操作系统使用了一种叫做随机地址分布的技术，使得进程的堆空间变 小。感兴趣的读者可以去研究操作系统中的相关内容</p><h2 id="内存管理的方式"><a href="#内存管理的方式" class="headerlink" title="内存管理的方式"></a>内存管理的方式</h2><p>常见的内存管理方式有<strong>块式管理、页式管理、段式管理和段页式管理</strong>。最常用的是段页式管理。</p><ul><li><p>块式管理</p><p>把主存分为一大块一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断载入主 存，就算所需的程序片段只有几个字节，也只能把这一块分配给它。这样会造成很大的浪费，平均浪费 了50%的内存空间，但是易于管理</p></li><li><p>页式管理</p><p>用户程序的地址空间被划分成若干个固定大小的区域，这个区域被称为页”，相应地，内存空间也被划分 为若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，从而实现了离散分 配。这种方式的优点是页的大小是固定的，因此便于管理；缺点是页长与程序的逻辑大小没有任何关 系。这就导致在某个时刻一个程序可能只有一部分在主存中，而另一部分则在辅存中。这不利于编程时 的独立性，并给换入换出处理、存储保护和存储共享等操作造成麻烦</p></li><li><p>段式管理</p><p>段是按照程序的自然分界划分的并且长度可以动态改变的区域。使用这种方式，程序员可以把子程序、 操作数和不同类型的数据和函数划分到不同的段中。这种方式将用户程序地址空间分成若干个大小不等 的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段为单位，段与段在内存中可以不相邻 接，也实现了离散分配。</p></li></ul><blockquote><p>分页对程序员而言是不可见的，而分段通常对程序员而言是可见的，因而分段为组织程序和数据提 供了方便，但是对程序员的要求也比较高。 </p><p>分段存储主要有如下优点： </p><ol><li>段的逻辑独立性不仅使其易于编译、管理、修改和保护，也便于多道程序共享。 </li><li>段长可以根据需要动态改变，允许自由调度，以便有效利用主存空间。 </li><li>方便分段共享、分段保护、动态链接、动态增长。</li></ol><p>分段存储的缺点如下： </p><ol><li>由于段的大小不固定，因此存储管理比较麻烦。 </li><li>会生成段内碎片，这会造成存储空间利用率降低。而且段式存储管理比页式存储管理方式需 要更多的硬件支持。</li></ol><p>正是由于页式管理和段式管理都有各种各样的缺点，因此，为了把这两种存储方式的优点结合起 来，新引入了段页式管理。</p></blockquote><ul><li><p>段页式管理</p><p>段页式存储组织是分段式和分页式结合的存储组织方法，这样可充分利用分段管理和分页管理的优点。</p><ol><li>用分段方法来分配和管理虚拟存储器。程序的地址空间按逻辑单位分成基本独立的段，而每一段有 自己的段名，再把每段分成固定大小的若干页 </li><li>用分页方法来分配和管理内存，即把整个主存分成与上述页大小相等的存储块，可装入作业的任何 一页。程序对内存的调入或调出是按页进行的，但它又可按段实现共享和保护</li></ol></li></ul><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存简称虚存，是计算机系统内存管理的一种技术。它是相对于物理内存而言的，可以理解为“假 的”内存。它使得<strong>应用程序认为它拥有连续可用的内存（一个连续完整的地址空间）</strong>，允许程序员编写并 运行比实际系统拥有的内存大得多的程序，这使得许多大型软件项目能够在具有有限内存资源的系统上 实现。而实际上，它通常被分割成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要 时进行数据交换。</p><p>相比实存，虚存有以下好处：</p><ol><li>扩大了地址空间。无论是段式虚存，还是页式虚存，或是段页式虚存，寻址空间都比实存大。 </li><li>内存保护。每个进程运行在各自的虚拟内存地址空间，互相不能干扰对方。另外，虚存还对特定的 内存地址提供写保护，可以防止代码或数据被恶意篡改。 </li><li>公平分配内存。采用了虚存之后，每个进程都相当于有同样大小的虚存空间。 </li><li>当进程需要通信时，可采用虚存共享的方式实现不过，使用虚存也是有代价的，主要表现在以下几 个方面。<ol><li>虚存的管理需要建立很多数据结构，这些数据结构要占用额外的内存</li><li>虚拟地址到物理地址的转换，增加了指令的执行时间</li><li>页面的换入换出需要磁盘IO，这是很耗时间的</li><li>如果一页中只有一部分数据，会浪费内存</li></ol></li></ol><h2 id="内存碎片、内碎片、外碎片"><a href="#内存碎片、内碎片、外碎片" class="headerlink" title="内存碎片、内碎片、外碎片"></a>内存碎片、内碎片、外碎片</h2><ul><li><p>内存碎片</p><p>是由于多次进行内存分配造成的，当进行内存分配时，内存格式一般为：（用户使用段）（空 白段）（用户使用段），当空白段很小的时候，可能不能提供给用户足够多的空间，如夹在中间的空白 段的大小为5，而用户需要的内存大小为6，这样会产生很多的间隙，造成使用效率下降，这些很小的空 隙叫碎片</p></li><li><p>内碎片</p><p>分配给程序的存储空间没有用完，有一部分是程序不使用，但其他程序也没法用的空间。内碎 片是处于区域内部或页面内部的存储块，占有这些区域或页面的进程并不使用这个存储块，而在进程占 有这块存储块时，系统无法利用它，直到进程释放它，或进程结束时，系统才有可能利用这个存储块</p></li><li><p>外碎片</p><p>空间太小，小到无法给任何程序分配（不属于任何进程）的存储空间。外部碎片是出于任何已 分配区域或页面外部的空闲存储块，这些存储块的总和可以满足当前申请的长度要求，但是它们的地址 不连续或其他原因，使得系统无法满足当前申请</p></li></ul><p>内碎片和外碎片是一对矛盾体，一种特定的内存分配算法，很难同时解决好内碎片和外碎片的问题，只 能根据应用特点进行取舍</p><h2 id="虚拟地址、逻辑地址、线性地址、物理地址"><a href="#虚拟地址、逻辑地址、线性地址、物理地址" class="headerlink" title="虚拟地址、逻辑地址、线性地址、物理地址"></a>虚拟地址、逻辑地址、线性地址、物理地址</h2><ul><li><p>虚拟地址</p><p>是指由程序产生的由段选择符和段内偏移地址组成的地址。这两部分组成的地址并没有直接访 问物理内存，而是通过分段地址的变换处理后才会对应到相应的物理内存地址</p></li><li><p>逻辑地址</p><p>由程序产生的段内偏移地址。有时直接把逻辑地址当成虚拟地址，两者并没有明确的界限</p></li><li><p>线性地址</p><p>是指<strong>虚拟地址到物理地址变换之间的中间层</strong>，是处理器可寻址的内存空间（称为线性地址空 间）中的地址。程序代码会产生逻辑地址，或者说是段中的偏移地址，加上相应段基址就生成了一个线 性地址。如果启用了分页机制，那么线性地址可以再经过变换产生物理地址。若没有采用分页机制，那 么线性地址就是物理地址</p></li><li><p>物理地址</p><p>指现在CPU外部地址总线上的寻址物理内存的地址信号，是地址变换的最终结果。虚拟地址 到物理地址的转化方法是与体系结构相关的，一般有分段与分页两种方式。以x86CPU为例，分段、分 页都是支持的。内存管理单元负责从虚拟地址到物理地址的转化。逻辑地址是段标识+段内偏移量的形 式，MMU通过査询段表，可以把逻辑地址转化为线性地址。如果CPU没有开启分页功能，那么线性地址 就是物理地址；如果CPU开启了分页功能MMU还需要查询页表来将线性地址转化为物理地址：逻辑地址 （段表）→线性地址（页表）→物理地址。</p></li></ul><p>映射是一种多对一的关系，即不同的逻辑地址可以映射到同一个线性地址上；不同的线性地址也可以映 射到同一个物理地址上。而且，同一个线性地址在发生换页以后，也可能被重新装载到另外一个物理地 址上，所以这种多对一的映射关系也会随时间发生变化</p><h2 id="虚拟内存的置换方式（？）"><a href="#虚拟内存的置换方式（？）" class="headerlink" title="虚拟内存的置换方式（？）"></a>虚拟内存的置换方式（？）</h2><h2 id="类里面有static、virtual，其内存分布"><a href="#类里面有static、virtual，其内存分布" class="headerlink" title="类里面有static、virtual，其内存分布"></a>类里面有static、virtual，其内存分布</h2><ul><li><p>static修饰符</p><ul><li><p>static修饰成员变量</p><p>对于非静态数据成员，每个类对象都有自己的拷贝。而静态数据成员被当做是类的成员，无论这个类被 定义了多少个，静态数据成员都只有一份拷贝，为该类型的所有对象所共享(包括其派生类)。所以，静态 数据成员的值对每个对象都是一样的，它的值可以更新</p><p>因为静态数据成员在全局数据区分配内存，属于本类的所有对象共享，所以它不属于特定的类对象，在 没有产生类对象前就可以使用</p></li><li><p>static修饰成员函数</p><p>与普通的成员函数相比，静态成员函数由于不是与任何的对象相联系，因此它不具有this指针。从这个 意义上来说，它无法访问属于类对象的非静态数据成员，也无法访问非静态成员函数，只能调用其他的 静态成员函数。static修饰的成员函数，在代码区分配内存</p></li></ul></li><li><p>C++继承和虚函数</p><p>C++多态分为静态多态和动态多态。静态多态是通过重载和模板技术实现，在编译的时候确定。动态多 态通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定</p><p>动态多态实现有几个条件：</p><ul><li>虚函数</li><li>一个基类的指针或引用指向派生类的对象</li></ul><p>基类指针在调用成员函数(虚函数)时，就会去查找该对象的虚函数表。虚函数表的地址在每个对象的首地 址。查找该虚函数表中该函数的指针进行调用。 </p><p>每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象的都 指向这同一个虚函数表。</p><p>虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，虚函数表直接从基类也继承 过来，如果覆盖了其中的某个虚函数，那么虚函数表的指针就会被替换，因此可以根据指针准确找到该 调用哪个函数</p></li><li><p>virtual修饰符</p><p>如果一个类是局部变量则该类数据存储在栈区，如果一个类是通过new&#x2F;malloc动态申请的，则该类数据 存储在堆区。 </p><p>如果该类是virutal继承而来的子类，则该类的虚函数表指针和该类其他成员一起存储。虚函数表指针指 向只读数据段中的类虚函数表，虚函数表中存放着一个个函数指针，函数指针指向代码段中的具体函数。 </p><p>如果类中成员是virtual属性，会隐藏父类对应的属性</p></li></ul><h2 id="假设临界区资源释放，如何保证只让一个线程获取临界区资源"><a href="#假设临界区资源释放，如何保证只让一个线程获取临界区资源" class="headerlink" title="假设临界区资源释放，如何保证只让一个线程获取临界区资源"></a>假设临界区资源释放，如何保证只让一个线程获取临界区资源</h2><p>给临界区资源加互斥锁，可以保证临界区资源释放时，只有一个线程获得临界区资源。</p><h2 id="缺页中断"><a href="#缺页中断" class="headerlink" title="缺页中断"></a>缺页中断</h2><p>malloc()和mmap()等内存分配函数，在分配时只是建立了进程虚拟地址空间，并没有分配虚拟内存对应 的物理内存。当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常</p><p>缺页中断：在请求分页系统中，可以通过查询页表中的状态位来确定所要访问的页面是否存在于内存 中。每当所要访问的页面不在内存是，会产生一次缺页中断，此时操作系统会根据页表中的外存地址在 外存中找到所缺的一页，将其调入内存</p><p>缺页本身是一种中断，与一般的中断一样，需要经过4个处理步骤：</p><ol><li>保护CPU现场 </li><li>分析中断原因 </li><li>转入缺页中断处理程序进行处理 </li><li>恢复CPU现场，继续执行</li></ol><p>但是缺页中断是由于所要访问的页面不存在于内存时，由硬件所产生的一种特殊的中断，因此，与一般 的中断存在区别： </p><ol><li>在指令执行期间产生和处理缺页中断信号 </li><li>一条指令在执行期间，可能产生多次缺页中断 </li><li>缺页中断返回是，执行产生中断的一条指令，而一般的中断返回是，执行下一条指令。</li></ol><h2 id="OS缺页置换算法"><a href="#OS缺页置换算法" class="headerlink" title="OS缺页置换算法"></a>OS缺页置换算法</h2><p>当访问一个内存中不存在的页，并且内存已满，则需要从内存中调出一个页或将数据送至磁盘对换区， 替换一个页，这种现象叫做缺页置换。当前操作系统最常采用的缺页置换算法如下：</p><p> <strong>先进先出(FIFO)算法</strong>：置换最先调入内存的页面，即置换在内存中驻留时间最久的页面。按照进入内存 的先后次序排列成队列，从队尾进入，从队首删除。 </p><p>最近最少使用<strong>（LRU）算法</strong>: 置换最近一段时间以来最长时间未访问过的页面。根据程序局部性原理，刚 被访问的页面，可能马上又要被访问；而较长时间内没有被访问的页面，可能最近不会被访问。当前最 常采用的就是LRU算法。</p><h2 id="系统调用和库函数"><a href="#系统调用和库函数" class="headerlink" title="系统调用和库函数"></a>系统调用和库函数</h2><ul><li><p>系统调用</p><p>系统调用是通向操作系统本身的接口，是面向底层硬件的。通过系统调用，可以使得用户态运行的进程 与硬件设备(如CPU、磁盘、打印机等)进行交互，是操作系统留给应用程序的一个接口。下面为适用于访 问设备驱动程序的系统调用</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">open:</span> 打开文件或设备 <br><span class="hljs-symbol">read:</span> 从打开的文件或设备中读取数据 <br><span class="hljs-symbol">write:</span> 向打开的文件或设备中写入数据 <br><span class="hljs-symbol">close:</span> 关闭文件或设备 <br><span class="hljs-symbol">ioctl:</span> 把控制信息传递给设备驱动文件<br></code></pre></td></tr></table></figure></li><li><p>库函数</p><p>库函数（Library function）是把函数放到库里，供别人使用的一种方式。.方法是把一些常用到的函数 编完放到一个文件里，供不同的人进行调用。一般放在.lib文件中。库函数调用则是面向应用开发的，库 函数可分为两类，一类是C语言标准规定的库函数，一类是编译器特定的库函数。</p></li></ul><p><strong>系统调用是为了方便使用操作系统的接口，而库函数则是为了人们编程的方便</strong></p><p>库函数调用与系统无关，不同的系统，调用库函数，库函数会调用不同的底层函数实现，因此可移植性 好。</p><p>由于库函数是基于c库的，因此不能用于内核对于底层驱动设备的操作</p><p><strong>区别：</strong></p><ol><li>库函数是语言或应用程序的一部分，而系统调用是内核提供给应用程序的接口，属于系统的一部分 </li><li>库函数在用户地址空间执行，系统调用是在内核地址空间执行，库函数运行时间属于用户时间，系 统调用属于系统时间，库函数开销较小，系统调用开销较大 </li><li>库函数是有缓冲的，系统调用是无缓冲的 </li><li>系统调用依赖于平台，库函数并不依赖</li></ol><p><img src="/./../photo/image-20231213192034154.png" alt="image-20231213192034154"></p><h2 id="page-cache"><a href="#page-cache" class="headerlink" title="page cache"></a>page cache</h2><p>加快从磁盘读取文件的速率。page cache中有一部分磁盘文件的缓存，因为从磁盘中读取文件比较慢， 所以读取文件先去page cache中去查找，如果命中，则不需要去磁盘中读取，大大加快读取速度。 </p><p>在Linux 内核中，文件的每个数据块最多只能对应一个 Page Cache 项，它通过两个数据结构来管理这 些 Cache项，一个是radix tree，另一个是双向链表。Radix tree 是一种搜索树，Linux内核利用这个数 据结构来通过文件内偏移快速定位Cache 项</p><h1 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h1><h2 id="上下文有哪些"><a href="#上下文有哪些" class="headerlink" title="上下文有哪些"></a>上下文有哪些</h2><p>上下文简单说来就是一个环境</p><p>用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递 很多变量、参数 的值给内核，内核态运行的时候也要保存用户进程的一些寄存 器值、变量等。所谓的“进程上下文”，可 以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境 等。</p><p>相对于进程而言，就是进程执行时的环境。具体来说就是各个变量和数据，包括所有的寄存器变量、进 程打开的文件、内存信息等</p><p>一个进程的上下文可以分为三个部分:<strong>用户级上下文、寄存器上下文以及系统级上下文</strong></p><ol><li>用户级上下文: 正文、数据、用户堆栈以及共享存储区； </li><li>寄存器上下文: 通用寄存器、程序寄存器(IP)、处理器状态寄存器(EFLAGS)、栈指针(ESP)； </li><li>系统级上下文: 进程控制块task_struct、内存管理信息(mm_struct、vm_area_struct、pgd、 pte)、内核栈</li></ol><p><strong>当发生进程调度时，进行进程切换就是上下文切换(context switch).操作系统必须对上面提到的全部信 息进行切换，新调度的进程才能运行。而系统调用进行的模式切换(mode switch)。模式切换与进程切 换比较起来，容易很多，而且节省时间，因为模式切换最主要的任务只是切换进程寄存器上下文的切 换</strong></p><p>硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的 一些变量和参数 也要传递给内核，内核通过这些参数进行中断处理。所谓的“ 中断上下文”，其实也可以看作就是硬件传 递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。中断时，内 核不代表任何进程运行，它一般只访问系统空间，而不会访问进程空间，内核在中断上下文中执行时一 般不会阻塞</p><h2 id="为什么会有上下文"><a href="#为什么会有上下文" class="headerlink" title="为什么会有上下文"></a>为什么会有上下文</h2><p>内核空间和用户空间是现代操作系统的两种工作模式，内核模块运行在内核空间，而用户态应用程序运 行在用户空间。它们代表不同的级别，而对系统资源具有不同的访问权限。内核模块运行在最高级别 （内核态），这个级下所有的操作都受系统信任，而应用程序运行在较低级别（用户态）。在这个级 别，处理器控制着对硬件的直接访问以及对内存的非授权访问。内核态和用户态有自己的内存映射，即 自己的地址空间。</p><p>其中，处理器总处于以下状态中的一种： </p><p>内核态，运行于进程上下文，内核代表进程运行于内核空间； </p><p>用户态，运行于用户空间。</p><p>系统的两种不同运行状态，才有了上下文的概念。用户空间的应用程序，如果想请求系统服务，比如操 作某个物理设备，映射设备的地址到用户空间，必须通过系统调用来实现。（系统调用是操作系统提供 给用户空间的接口函数）。</p><p>通过系统调用，用户空间的应用程序就会进入内核空间，由内核代表该进程运行于内核空间，这就涉及 到上下文的切换，用户空间和内核空间具有不同的 地址映射，通用或专用的寄存器组，而<strong>用户空间的进 程要传递很多变量、参数给内核，内核也要保存用户进程的一些寄存器、变量等，以便系统调用结束后 回到用户空间继续执行</strong></p><h2 id="用户态到内核态什么情况下会切换"><a href="#用户态到内核态什么情况下会切换" class="headerlink" title="用户态到内核态什么情况下会切换"></a>用户态到内核态什么情况下会切换</h2><ol><li>进程上下文主要是异常处理程序和内核线程。内核之所以进入进程上下文是因为进程自身的一些工 作需要在内核中做。例如，系统调用是为当前进程服务的，异常通常是处理进程导致的错误状态 等。 </li><li>中断上下文是由于硬件发生中断时会触发中断信号请求，请求系统处理中断，执行中断服务子程 序。</li></ol><h2 id="中断上下文代码中有哪些注意事项"><a href="#中断上下文代码中有哪些注意事项" class="headerlink" title="中断上下文代码中有哪些注意事项"></a>中断上下文代码中有哪些注意事项</h2><p>运行于进程上下文的内核代码是可抢占的，但中断上下文则会一直运行至结束，不会被抢占。所以中断 处理程序代码要受到一些限制，在中断代码中不能出现实现下面功能的代码：</p><ol><li><strong>睡眠或者放弃CPU</strong> ，因为内核在进入中断之前会关闭进程调度，一旦睡眠或者放弃CPU，这时内核无法调度别的进程来 执行，系统就会死掉。牢记：中断服务子程序一定不能睡眠（或者阻塞）。 </li><li><strong>尝试获得信号量</strong> ，如果获得不到信号量，代码就会睡眠，导致（1）中的结果。 </li><li><strong>执行耗时的任务</strong> ，中断处理应该尽可能快，因为如果一个处理程序是IRQF_DISABLED类型，他执行的时候会禁止所有 本地中断线，而内核要响应大量服务和请求，中断上下文占用CPU时间太长会严重影响系统功能。 中断处理程序的任务尽可能放在中断下半部执行</li><li><strong>访问用户空间的虚拟地址</strong> ，因为中断运行在内核空间。</li></ol><h2 id="线程需要保存哪些上下文，SP、PC、EAX寄存器的作用"><a href="#线程需要保存哪些上下文，SP、PC、EAX寄存器的作用" class="headerlink" title="线程需要保存哪些上下文，SP、PC、EAX寄存器的作用"></a>线程需要保存哪些上下文，SP、PC、EAX寄存器的作用</h2><p>线程在切换的过程中需要保存当前线程id、线程状态、堆栈、寄存器状态等信息。其中寄存器主要包括 SP、PC、EAX等寄存器，其主要功能如下：</p><p>SP:堆栈指针，指向当前栈的栈顶地址 </p><p>PC:程序计数器，存储下一条将要执行的指令 </p><p>EAX:累加寄存器，用于加法乘法的缺省寄存器</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux知识点总结</title>
    <link href="/2024/06/28/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <url>/2024/06/28/Linux%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="常用的-Linux-指令"><a href="#常用的-Linux-指令" class="headerlink" title="常用的 Linux 指令"></a>常用的 Linux 指令</h2><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>查看当前进程</p><h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>执行退出</p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>查看当前路径</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>列出指定目录中的目录，以及文件</p><p>参数：</p><ul><li>-a显示所有文件及目录 (. 开头的隐藏文件也会列出)</li><li>-l     除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出</li><li>-R    若目录下有文件，则以下之文件亦皆依序列出</li></ul><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>创建目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> test1<span class="hljs-comment">#在当前目录下，建立一个名为 test1 的子目录</span><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-built_in">test</span>/test2<span class="hljs-comment">#在当前目录下的 test 目录中，建立一个名为 test2 的子目录。若 test 目录原本不存在，则建立一个。</span><br></code></pre></td></tr></table></figure><h3 id="vi-vim"><a href="#vi-vim" class="headerlink" title="vi&#x2F;vim"></a>vi&#x2F;vim</h3><p>打开&#x2F;创建文件</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">vi</span> file1.txt  <span class="hljs-comment">#直接创建并打开一个文件file1.txt</span><br></code></pre></td></tr></table></figure><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>创建文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">touch</span> file2.txt  <span class="hljs-comment">#创建新的空文件file2.txt</span><br></code></pre></td></tr></table></figure><h3 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h3><p>创建&#x2F;写入文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;this is a new file&quot;</span> &gt; file3.txt<br><span class="hljs-comment">#创建文件file3.txt并将this is a new file写入（说明：使用&gt;指令覆盖文件原内容并重新输入内容，若文件不存在则创建文件。）</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;add contents&quot;</span> &gt;&gt;file3.txt    <br><span class="hljs-comment">#在已存在的文件补充写入新内容add contents（说明：使用&gt;&gt;指令向文件追加内容，原内容将保存。）</span><br><br><span class="hljs-built_in">echo</span> hello world<span class="hljs-comment">#向屏幕输出带空格的字符串，比如”hello world”</span><br></code></pre></td></tr></table></figure><h3 id="cat、less、more"><a href="#cat、less、more" class="headerlink" title="cat、less、more"></a>cat、less、more</h3><p>三者都是将文件内容输出到标准输出，其中less和more可以分页显示，cat是显示全部。</p><p>三者可以根据已经存在的文件创建新的文件。假设已经存在文件1.txt。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">cat</span>  <span class="hljs-number">1</span>.txt &gt; <span class="hljs-number">2</span>.txt<br><span class="hljs-attribute">less</span> <span class="hljs-number">1</span>.txt &gt; <span class="hljs-number">3</span>.txt<br><span class="hljs-attribute">more</span> <span class="hljs-number">1</span>.txt &gt; <span class="hljs-number">4</span>.txt<br></code></pre></td></tr></table></figure><p>此时创建的文件内容都和1.txt中文件内容相同</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> -n textfile1    <span class="hljs-comment">#把 textfile1 的文档内容加上行号后输入到屏幕</span><br><span class="hljs-built_in">cat</span> -n textfile1 &gt; textfile2  <span class="hljs-comment">#把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里</span><br><br><span class="hljs-built_in">cat</span> -b textfile1 textfile2 &gt;&gt; textfile3  <br><span class="hljs-comment">#把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里</span><br><span class="hljs-built_in">cat</span> /dev/null &gt; /etc/test.txt <span class="hljs-comment">#清空 /etc/test.txt 文档内容</span><br></code></pre></td></tr></table></figure><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>cd最主要的作用是切换目录，在cd后面跟&gt;或&gt;&gt;再加上文件名就可以创建一个内容为空的文件。</p><p>它和 echo的区别之处在于echo可写文件内容，而cd并不能。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> &gt; file3.txt   <span class="hljs-comment">#创建新的空文件file3.txt</span><br><span class="hljs-built_in">cd</span> &gt;&gt; file4.txt  <span class="hljs-comment">#创建新的空文件file4.txt</span><br></code></pre></td></tr></table></figure><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>复制文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span>  –r  <span class="hljs-built_in">test</span>/  newtest      <span class="hljs-comment">#将当前目录 test/ 下的所有文件复制到新目录 newtest下</span><br></code></pre></td></tr></table></figure><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>移动文件&#x2F;改文件名</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">mv <span class="hljs-built_in">source_file</span>(文件) <span class="hljs-built_in">dest_file</span>(文件) #将源文件名 source_file 改为目标文件名 dest_file<br>mv <span class="hljs-built_in">source_file</span>(文件) <span class="hljs-built_in">dest_directory</span>(目录)   #将文件 source_file 移动到目标目录 dest_directory 中<br></code></pre></td></tr></table></figure><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>删除文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">rm</span>  file   <span class="hljs-comment">#删除当前目录下file文件</span><br><span class="hljs-built_in">rm</span>  -rf   directory/       <span class="hljs-comment">#删除目录 directory，不管该目录下是否有子目录或文件</span><br></code></pre></td></tr></table></figure><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>查找文件内容</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">grep</span> hello <span class="hljs-keyword">file</span>.txt#在文件 <span class="hljs-keyword">file</span>.txt 中查找字符串 <span class="hljs-string">&quot;hello&quot;</span>，并打印匹配的行<br><span class="hljs-keyword">grep</span> test *<span class="hljs-keyword">file</span>     #在当前目录中，查找后缀有 <span class="hljs-keyword">file</span> 字样的文件中包含 test 字符串的文件，并打印匹配的行<br><span class="hljs-keyword">grep</span> -r update <span class="hljs-regexp">/etc/</span>acpi #查找指定目录<span class="hljs-regexp">/etc/</span>acpi 及其子目录（如果存在子目录的话）下所有文件中包含字符串<span class="hljs-string">&quot;update&quot;</span>的文件<br><span class="hljs-keyword">grep</span> -v test *test*      #查找文件名中包含 test 的文件中不包含test 的行<br><br><span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;gpio-key&quot;</span> * -nr | <span class="hljs-keyword">grep</span> <span class="hljs-string">&quot;\.c&quot;</span><span class="hljs-comment">//递归查找，在上一次搜索的结果中再次查找其中后缀是“.c”的文件</span><br></code></pre></td></tr></table></figure><p>参数：</p><ul><li><code>-i</code>：忽略大小写进行匹配</li><li><code>-v</code>：反向查找，只打印不匹配的行</li><li><code>-n</code>：显示匹配行的行号</li><li><code>-r</code>：递归查找子目录中的文件</li><li>**-**w 或 –word-regexp : 只显示全字符合的列</li></ul><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>查找文件</p><figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs golo"><span class="hljs-keyword">find</span> . -name <span class="hljs-string">&quot;*.c&quot;</span>  <span class="hljs-comment">#将当前目录及其子目录下所有文件后缀为 .c 的文件列出来</span><br><span class="hljs-keyword">find</span> . -ctime <span class="hljs-number">-20</span>   <span class="hljs-comment">#将当前目录及其子目录下所有最近 20 天内更新过的文件列出</span><br><br><span class="hljs-keyword">find</span> -name <span class="hljs-string">&quot;*gpio-key*&quot;</span>//查找文件名中带有<span class="hljs-string">&quot;*gpio-key*&quot;</span>的文件<br><span class="hljs-keyword">find</span> -name <span class="hljs-string">&quot;*gpio-key*&quot;</span> | grep <span class="hljs-string">&quot;imx&quot;</span>//递归查找<br></code></pre></td></tr></table></figure><h3 id="tar、zip"><a href="#tar、zip" class="headerlink" title="tar、zip"></a>tar、zip</h3><p>压缩文件夹</p><ul><li>bz2格式</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tar -vcjf  test1<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.bz2</span>  test1 <span class="hljs-comment">//压缩 test1 文件夹为bz2格式</span><br>tar -vxjf test1<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.bz2</span> <span class="hljs-comment">//解压</span><br></code></pre></td></tr></table></figure><ul><li>gz格式</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">tar -vczf test1<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span> test1 <span class="hljs-comment">//压缩 test1 文件夹为gz格式</span><br>tar -vxzf test2<span class="hljs-selector-class">.tar</span><span class="hljs-selector-class">.gz</span><span class="hljs-comment">//解压</span><br></code></pre></td></tr></table></figure><ul><li>zip</li></ul><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">zip</span> -rv test2.<span class="hljs-keyword">zip</span> test2 <span class="hljs-comment">// 压缩 test2 文件夹</span><br>unzip test2.<span class="hljs-keyword">zip</span> <span class="hljs-comment">// 解压 test2.zip</span><br></code></pre></td></tr></table></figure><h2 id="常用的-GCC-指令"><a href="#常用的-GCC-指令" class="headerlink" title="常用的 GCC 指令"></a>常用的 GCC 指令</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">gcc -E <span class="hljs-keyword">test</span>.c -o <span class="hljs-keyword">test</span>.i  <span class="hljs-comment">#把预处理的结果导出到test.i文件</span><br></code></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">gcc -S <span class="hljs-keyword">test</span>.i -o <span class="hljs-keyword">test</span>.s #编译器将<span class="hljs-keyword">test</span>.i翻译成汇编语言，并将结果存储在<span class="hljs-keyword">test</span>.s文件中。<br></code></pre></td></tr></table></figure><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">gcc -c <span class="hljs-keyword">test</span>.s -o <span class="hljs-keyword">test</span>.o <span class="hljs-comment">#将汇编代码编译为目标文件（.o）但不链接</span><br></code></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">gcc <span class="hljs-keyword">test</span>.o -o <span class="hljs-keyword">test</span> #将生成的目标文件<span class="hljs-keyword">test</span>.o生成最终的可执行文件<span class="hljs-keyword">test</span><br></code></pre></td></tr></table></figure><h3 id="一步到位编译"><a href="#一步到位编译" class="headerlink" title="一步到位编译"></a>一步到位编译</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">gcc <span class="hljs-keyword">test</span>.c -o <span class="hljs-keyword">test</span> #将源文件<span class="hljs-keyword">test</span>.c编译链接为可执行文件<span class="hljs-keyword">test</span><br></code></pre></td></tr></table></figure><h3 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h3><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc test<span class="hljs-number">1</span>.<span class="hljs-keyword">c</span> test<span class="hljs-number">2</span>.<span class="hljs-keyword">c</span> -o test<br></code></pre></td></tr></table></figure><h3 id="警告处理"><a href="#警告处理" class="headerlink" title="警告处理"></a>警告处理</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cmake">gcc -w <span class="hljs-keyword">test</span>.c -o <span class="hljs-keyword">test</span>     <span class="hljs-comment"># 忽略编译时的警告</span><br>gcc -Wall <span class="hljs-keyword">test</span>.c -o <span class="hljs-keyword">test</span> <span class="hljs-comment">#编译后显示所有警告</span><br>gcc -Werror <span class="hljs-keyword">test</span>.c -o <span class="hljs-keyword">test</span>  <span class="hljs-comment">#在产生警告的地方停止编译</span><br></code></pre></td></tr></table></figure><h2 id="常用的-GDB-指令"><a href="#常用的-GDB-指令" class="headerlink" title="常用的 GDB 指令"></a>常用的 GDB 指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -g test.c -o <span class="hljs-built_in">test</span>  <span class="hljs-comment">#编译时生成debug有关的程序信</span><br>gdb <span class="hljs-built_in">test</span>        <span class="hljs-comment">#启动调试</span><br><span class="hljs-built_in">help</span> <span class="hljs-comment">#查看命令帮助，具体命令查询在gdb中输入help + 命令,简写h</span><br>run <span class="hljs-comment">#重新开始运行文件（run-text：加载文本文件，run-bin：加载二进制文件）,简写r</span><br>start <span class="hljs-comment">#单步执行，运行程序，停在第一执行语句</span><br>list <span class="hljs-comment">#查看原代码（list-n,从第n行开始查看代码。list+ 函数名：查看具体函数）,简写l</span><br><span class="hljs-built_in">set</span> <span class="hljs-comment">#设置变量的值</span><br>next <span class="hljs-comment">#单步调试（逐过程，函数直接执行）,简写n</span><br>step <span class="hljs-comment">#单步调试（逐语句：跳入自定义函数内部执行）,简写s</span><br>backtrace <span class="hljs-comment">#查看函数的调用的栈帧和层级关系,简写bt</span><br>frame <span class="hljs-comment">#切换函数的栈帧,简写f</span><br>info <span class="hljs-comment">#查看函数内部局部变量的数值,简写i</span><br>finish <span class="hljs-comment">#结束当前函数，返回到函数调用点</span><br><span class="hljs-built_in">continue</span> <span class="hljs-comment">#继续运行,简写c</span><br><span class="hljs-built_in">print</span> <span class="hljs-comment">#打印值及地址,简写p</span><br>quit <span class="hljs-comment">#退出gdb,简写q</span><br><span class="hljs-built_in">break</span>+num <span class="hljs-comment">#在第num行设置断点,简写b</span><br>info breakpoints <span class="hljs-comment">#查看当前设置的所有断点</span><br>delete breakpoints num <span class="hljs-comment">#删除第num个断点,简写d</span><br>display <span class="hljs-comment">#追踪查看具体变量值</span><br>undisplay <span class="hljs-comment">#取消追踪观察变量</span><br>watch <span class="hljs-comment">#被设置观察点的变量发生修改时，打印显示</span><br>i watch <span class="hljs-comment">#显示观察点</span><br><span class="hljs-built_in">enable</span> breakpoints <span class="hljs-comment">#启用断点</span><br><span class="hljs-built_in">disable</span> breakpoints <span class="hljs-comment">#禁用断点</span><br>x <span class="hljs-comment">#查看内存x/20xw 显示20个单元，16进制，4字节每单元</span><br>run argv[1] argv[2] <span class="hljs-comment">#调试时命令行传参</span><br><span class="hljs-built_in">set</span> follow-fork-mode child <span class="hljs-comment">#Makefile项目管理：选择跟踪父子进程(fork())</span><br></code></pre></td></tr></table></figure><h2 id="常用的驱动开发指令"><a href="#常用的驱动开发指令" class="headerlink" title="常用的驱动开发指令"></a>常用的驱动开发指令</h2><h3 id="查看内核中已有的字符设备的信息"><a href="#查看内核中已有的字符设备的信息" class="headerlink" title="查看内核中已有的字符设备的信息"></a>查看内核中已有的字符设备的信息</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">lsmod</span><br></code></pre></td></tr></table></figure><h3 id="加载-卸载驱动"><a href="#加载-卸载驱动" class="headerlink" title="加载&#x2F;卸载驱动"></a>加载&#x2F;卸载驱动</h3><ul><li>insmod</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">insmod </span>led.ko<br>rmmod  led.ko<br></code></pre></td></tr></table></figure><ul><li>modprobe</li></ul><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">depmod</span><br>modprobe led.ko<br>rmmod led.ko<br></code></pre></td></tr></table></figure><h3 id="查看驱动中的打印信息"><a href="#查看驱动中的打印信息" class="headerlink" title="查看驱动中的打印信息"></a>查看驱动中的打印信息</h3><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">dmesg</span><br></code></pre></td></tr></table></figure><h3 id="查看中断号"><a href="#查看中断号" class="headerlink" title="查看中断号"></a>查看中断号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/interrupt<br></code></pre></td></tr></table></figure><h1 id="u-boot"><a href="#u-boot" class="headerlink" title="u-boot"></a>u-boot</h1><p>详细版参考  <code>uboot完全分析与移植</code></p><h2 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h2><p>Linux系统要启动就必须需要一个 bootloader程序，也就说芯片上电以后先运行一段bootloader程序。 这段 bootloader程序会先初始化时钟，看门狗，中断，SDRAM，等外设，然后将 Linux内核从  flash（NAND, NOR FLASH,SD,MMC等）拷贝到SDRAM中，最后启动Linux内核。当然了，  bootloader的实际工作要复杂的多，但是它<strong>最主要的工作就是启动 Linux内核</strong>。</p><p>bootloader和 Linux内核的关系就跟PC上的BIOS和 Windows的关系一样， bootloader就相当于 BIOS。总得来说，Bootloader就是一小段程序，它在系统上电时开始执行，初始化硬件设各、准备好 软件环境，最后调用操作系统内核。</p><h2 id="u-boot启动过程"><a href="#u-boot启动过程" class="headerlink" title="u-boot启动过程"></a>u-boot启动过程</h2><ul><li><p>第一阶段</p><p>初始化时钟，关闭看门狗，关中断，启动ICACHE，关闭DCACHE和TLB，关闭MMU，初始化SDRAM， 初始化NAND FLASH，重定位。</p></li><li><p>第二阶段</p><p>初始化一个串口，检测系统内存映射，将内核映象和根文件系统映象从 Flash上读到SDRAM空间中，为 内核设置启动参数，调用内核</p></li></ul><h2 id="u-boot和内核完成参数传递"><a href="#u-boot和内核完成参数传递" class="headerlink" title="u-boot和内核完成参数传递"></a>u-boot和内核完成参数传递</h2><p>uboot启动后已经完成了基本的硬件初始化（如：内存、串口等），接下来，它的主要任务就是加载 Linux内核到开发板的内存，然后跳转到Linux内核所在的地址运行。</p><p>具体是如何跳转呢？做法很简单，<strong>直接修改PC寄存器的值为Linux内核所在的地址</strong>，这样CPU就会从 Linux内核所在的地址去取指令，从而执行内核代码。</p><p>在前面我们已经知道，在跳转到内核以前，uboot需要做好以下三件事情：</p><ul><li><p><strong>CPU寄存器的设置</strong></p><p>R0&#x3D;0 </p><p>R1&#x3D;机器类型ID；对于ARM结构的CPU，其机器类型ID可以参见 linux&#x2F;arch&#x2F;arm tools&#x2F; mach-types </p><p>R2&#x3D;启动参数标记列表在RAM中起始基地址</p></li><li><p><strong>CPU工作模式</strong> </p><p>必须禁止中断（IRQs和FIQs） </p><p>CPU必须为SVC模式</p></li><li><p><strong>Cache和MMU的设置</strong> </p><p>MMU必须关闭 指令 </p><p>Cache可以打开也可以关闭 数据 </p><p>Cache必须关闭 </p><p>其中上面第一步CPU寄存器的设置中，就是通过R0,R1,R2三个参数给内核传递参数的</p></li></ul><h2 id="为何需要传递参数给内核？"><a href="#为何需要传递参数给内核？" class="headerlink" title="为何需要传递参数给内核？"></a>为何需要传递参数给内核？</h2><p>在此之前，uboot已经完成了硬件的初始化，可以说已经”适应了“这块开发板。然而，内核并不是对于所 有的开发板都能完美适配的（如果适配了，可想而知这个内核有多庞大，又或者有新技术发明了，可以 完美的适配各种开发板），此时，对于开发板的环境一无所知。所以，要想启动Linux内核，uboot必须 要给内核传递一些必要的信息来告诉内核<strong>当前所处的环境</strong>。</p><h2 id="如何给内核传递参数"><a href="#如何给内核传递参数" class="headerlink" title="如何给内核传递参数"></a>如何给内核传递参数</h2><p>uboot把<strong>机器ID通过R1传递给内核</strong>，Linux内核运行的时候，首先就从R1中读取机器ID来判断是否支持 当前机器。这个机器ID实际上就是开发板CPU的ID，每个厂家生产出一款CPU的时候都会给它指定一个 唯一的ID，大家可以到uboot源码的arch\arm\include\asm\mach-type.h文件中去查看。</p><p><img src="/./../photo/image-20231211123657070.png" alt="image-20231211123657070"></p><p><strong>R2存放的是块内存的基地址</strong>，这块内存中存放的是uboot给Linux内核的其他参数。这些参数有<strong>内存的起 始地址、内存大小、Linux内核启动后挂载文件系统的方式等信息</strong>。很明显，参数有多个，不同的参数 有不同的内容，为了让Linux内核能精确的解析出这些参数，双方在传递参数的时候要求参数在存放的时候需要按照双方规定的格式存放。</p><p><strong>除了约定好参数存放的地址外，还要规定参数的结构</strong>。Linux2.4.x以后的内核都期望以标记列表 （tagged_list）的形式来传递启动参数。标记，就是一种数据结构；标记列表，就是挨着存放的多个标 记。标记列表以标记 ATAG_CORE 开始，以标记 ATAG_NONE 结束。</p><p>标记的数据结构为tag，它由一个tag_header结构和一个联合（union）组成。tag_header结构表示标记 的类型及长度，比如是表示内存还是表示命令行参数等。对于不同类型的标记使用不同的联合 （union），比如表示内存时使用tag_ mem32，表示命令行时使用 tag_cmdline。具体代码见 arch\arm\include\asm\setup.h。</p><p><img src="/./../photo/image-20231211123647175.png" alt="image-20231211123647175"></p><p>从上面可以看出，struct_tag结构体由structtag_header+联合体union构成，结构体struct tag_header 用来描述每个tag的头部信息，如tag的类型，tag大小。联合体union用来描述每个传递给Linux内核的参 数信息。</p><h2 id="为什么需要关闭caches？"><a href="#为什么需要关闭caches？" class="headerlink" title="为什么需要关闭caches？"></a>为什么需要关闭caches？</h2><p>caches是cpu内部的一个2级缓存，它的作用是将常用的数据和指令放在cpu内部。caches是通过CP15 管理的，刚上电的时候，cpu还不能管理caches。上电的时候指令cache可关闭，也可不关闭，但数据 cache一定要关闭，否则可能导致刚开始的代码里面，去取数据的时候，从cache里面取，而这时候RAM 中数据还没有caches过来，导致数据预取异常。</p><h1 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h1><h2 id="根文件系统"><a href="#根文件系统" class="headerlink" title="根文件系统"></a>根文件系统</h2><p>根文件系统首先是一种文件系统，该文件系统不仅具有普通文件系统的存储数据文件的功能，但是相对于普通的文件系统，它的特殊之处在于，它是<strong>内核启动时所挂载（mount）的第一个文件系统</strong>，内核代码的映像文件保存在根文件系统中，系统引导启动程序会在根文件系统挂载之后从中把一些<strong>初始化脚本</strong> （如rcS,inittab）和<strong>服务</strong>加载到内存中去运行，里面包含了 Linux系统能够运行<strong>所必需的应用程序</strong>、<strong>库</strong> 等，比如可以给用户提供操作 Linux的控制界面的shell程序、动态连接的程序运行时需要的glibc库等。 我们要明白文件系统和内核是完全独立的两个部分。在嵌入式中移植的内核下载到开发板上，是没有办 法真正的启动Linux操作系统的，会出现无法加载文件系统的错误。</p><h2 id="跟文件系统的重要性"><a href="#跟文件系统的重要性" class="headerlink" title="跟文件系统的重要性"></a>跟文件系统的重要性</h2><p>根文件系统之所以在前面加一个”根“，说明它是加载其它文件系统的”根“，那么如果没有这个根，其它的 文件系统也就没有办法进行加载的。根文件系统包含系统启动时所必须的目录和关键性的文件，以及使 其他文件系统得以挂载（mount）所必要的文件。例如： </p><ul><li>init进程的应用程序必须运行在根文件系统上。 </li><li>根文件系统提供了根目录“&#x2F;”。 </li><li>linux挂载分区时所依赖的信息存放于根文件系统&#x2F;etc&#x2F;fstab这个文件中。 </li><li>shell命令程序必须运行在根文件系统上，譬如ls、cd等命令。</li></ul><p>总之：一套linux体系，只有内核本身是不能工作的，必须要rootfs（上的etc目录下的配置文件、&#x2F;bin  &#x2F;sbin等目录下的shell命令，还有&#x2F;lib目录下的库文件等）相配合才能工作</p><h2 id="可执行的映像文件"><a href="#可执行的映像文件" class="headerlink" title="可执行的映像文件"></a>可执行的映像文件</h2><p>可执行映像文件通常由以下几部分构成。 </p><ul><li>一个或多个代码段，代码段的属性为只读。 </li><li>零个或多个包含初始化数据的数据段，数据段的属性为可读写。</li><li>零个或多个不包含初始化数据的数据段，数据段的属性为可读写。</li></ul><h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><h2 id="硬中断和软中断"><a href="#硬中断和软中断" class="headerlink" title="硬中断和软中断"></a>硬中断和软中断</h2><ul><li><strong>硬中断</strong><ul><li>硬中断是由硬件产生的，比如，像磁盘，网卡，键盘，时钟等。每个设备或设备集都有它自己的 IRQ（中断请求）。基于IRQ，CPU可以将相应的请求分发到对应的硬件驱动上（注：硬件驱动通 常是内核中的一个子程序，而不是一个独立的进程）。</li><li>处理中断的驱动是需要运行在CPU上的，因此，当中断产生的时候，CPU会中断当前正在运行的任 务，来处理中断。在有多核心的系统上，一个中断通常只能中断一颗CPU（也有一种特殊的情况， 就是在大型主机上是有硬件通道的，它可以在没有主CPU的支持下，可以同时处理多个中断。）</li><li>硬中断可以直接中断CPU。它会引起内核中相关的代码被触发。对于那些需要花费一些时间去处理 的进程，中断代码本身也可以被其他的硬中断中断</li><li>对于时钟中断，内核调度代码会将当前正在运行的进程挂起，从而让其他的进程来运行。它的存在 是为了让调度代码（或称为调度器）可以调度多任务</li></ul></li><li><strong>软中断</strong><ul><li>软中断的处理非常像硬中断。然而，它们仅仅是由当前正在运行的进程所产生的</li><li>通常，软中断是一些对I&#x2F;O的请求。这些请求会调用内核中可以调度I&#x2F;O发生的程序。对于某些设 备，I&#x2F;O请求需要被立即处理，而磁盘I&#x2F;O请求通常可以排队并且可以稍后处理。根据I&#x2F;O模型的不 同，进程或许会被挂起直到I&#x2F;O完成，此时内核调度器就会选择另一个进程去运行。I&#x2F;O可以在进程 之间产生。并且调度过程通常和磁盘I&#x2F;O的方式是相同。</li><li>软中断仅与内核相联系。而内核主要负责对需要运行的任何其他的进程进行调度。一些内核允许设 备驱动的一些部分存在于用户空间，并且当需要的时候内核也会调度这个进程去运行</li><li>软中断并不会直接中断CPU。也只有当前正在运行的代码（或进程）才会产生软中断。这种中断是 一种需要内核为正在运行的进程去做一些事情（通常为I&#x2F;O）的请求。有一个特殊的软中断是Yield 调用，它的作用是请求内核调度器去查看是否有一些其他的进程可以运行</li></ul></li><li><strong>区别</strong><ul><li>1.软中断是执行中断指令产生的，而硬中断是由外设引发的。 </li><li>2.硬中断的中断号是由中断控制器提供的，软中断的中断号由指令直接指出，无需使用中断控制器。 </li><li>3.硬中断是可屏蔽的，软中断不可屏蔽。 </li><li>4.硬中断处理程序要确保它能快速地完成任务，这样程序执行时才不会等待较长时间，称为上半部。 </li><li>5.软中断处理硬中断未完成的工作，是一种推后执行的机制，属于下半部</li></ul></li></ul><h2 id="中断为什么要区分上半部和下半部"><a href="#中断为什么要区分上半部和下半部" class="headerlink" title="中断为什么要区分上半部和下半部"></a>中断为什么要区分上半部和下半部</h2><p>Linux中断分为硬件中断和内部中断（异常），调用过程：外部中断产生-&gt;发送中断信号到中断控制器-&gt; 通知处理器产生中断的中断号，让其进一步处理。 </p><p>对于中断上半部和下半部的产生，为了中断处理过程中被新的中断打断，将中断处理一分为二，上半部 登记新的中断，快速处理简单的任务，剩余复杂耗时的处理留给下半部处理，下半部处理过程中可以被 中断，上半部处理时不可被中断。</p><h2 id="中断的下半部如何实现"><a href="#中断的下半部如何实现" class="headerlink" title="中断的下半部如何实现"></a>中断的下半部如何实现</h2><p>软中断、tasklet、工作队列</p><h2 id="linux中断的响应执行流程"><a href="#linux中断的响应执行流程" class="headerlink" title="linux中断的响应执行流程"></a>linux中断的响应执行流程</h2><p>中断的响应流程：cpu接受中断-&gt;保存中断上下文跳转到中断处理历程-&gt;执行中断上半部-&gt;执行中断下半 部-&gt;恢复中断上下文。 中断的申请request_irq的正确位置：应该是在第一次打开 、硬件被告知终端之前</p><h1 id="Linux驱动模型"><a href="#Linux驱动模型" class="headerlink" title="Linux驱动模型"></a>Linux驱动模型</h1><h2 id="字符设备驱动模型"><a href="#字符设备驱动模型" class="headerlink" title="字符设备驱动模型"></a>字符设备驱动模型</h2><h3 id="驱动初始化"><a href="#驱动初始化" class="headerlink" title="驱动初始化"></a>驱动初始化</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-keyword">struct</span> <span class="hljs-type">cdev</span> <br>&#123;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">kobject</span> kobj;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">module</span> *owner;<br>    const <span class="hljs-keyword">struct</span> <span class="hljs-type">file_operations</span> *ops; <span class="hljs-comment">//设备操作集</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-type">list_head</span> list;<br>    dev_t dev; <span class="hljs-comment">//设备号</span><br>    unsigned int count; <span class="hljs-comment">//设备数</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>dev是设备号，包含有主设备号和次设备号的信息。主设备号用于区分设备的类型，次设备号用于标记 相同类型的设备的不同个体。</p><p>Linux内核中使用 dev_t 类型来定义设备号， dev_t 这种类型其实质为32位的 unsigned int ，其 中高12位为主设备号，低20位为次设备号。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">dev_t</span> dev = <span class="hljs-built_in">MKDEV</span> (主设备号，次设备号)    <span class="hljs-comment">//设备号</span><br>主设备号 = <span class="hljs-built_in">MAJOR</span>(<span class="hljs-type">dev_t</span> dev)<br>次设备号=<span class="hljs-built_in">MINOR</span>(<span class="hljs-type">dev_t</span> dev)<br></code></pre></td></tr></table></figure><p>主设备号是一个重要的资源，可以通过静态申请和动态分配为设备分配一个主设备号：</p><ul><li>静态申请：自己选择一个未被使用的主设备号，然后通过函数register_chrdev_region向内核 申请使用。</li><li>动态分配：使用 alloc_chrdev_region 由内核分配一个可用的主设备号。</li></ul><p>既然设备号是一种资源，则设备驱动在退出后都应该释放该资源。使用unregister_chrdev_region函数释放设备号。</p><p>ops是操作函数集。 file_operations 是一个很重要的结构，该结构的成员基本都是函数指针，并且是 一些文件操作的函数的指针。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> &#123;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">module</span> *owner;<br>  <span class="hljs-built_in">loff_t</span>(*llseek) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span>, <span class="hljs-type">int</span>);<br>  <span class="hljs-built_in">ssize_t</span>(*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br>  <span class="hljs-built_in">ssize_t</span>(*aio_read) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span>);<br>  <span class="hljs-built_in">ssize_t</span>(*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *);<br>  <span class="hljs-built_in">ssize_t</span>(*aio_write) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span>);<br>  <span class="hljs-built_in">int</span> (*readdir) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">void</span> *, <span class="hljs-type">filldir_t</span>);<br>  <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">int</span> <span class="hljs-params">(*poll)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> poll_table_struct *)</span></span>;<br>  <span class="hljs-built_in">int</span> (*ioctl) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>);<br>  <span class="hljs-built_in">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);<br>  <span class="hljs-built_in">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br>  <span class="hljs-built_in">int</span> (*flush) (<span class="hljs-keyword">struct</span> file *);<br>  <span class="hljs-built_in">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);<br>  <span class="hljs-built_in">int</span> (*fsync) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> dentry *, <span class="hljs-type">int</span> datasync);<br>  <span class="hljs-built_in">int</span> (*aio_fsync) (<span class="hljs-keyword">struct</span> kiocb *, <span class="hljs-type">int</span> datasync);<br>  <span class="hljs-built_in">int</span> (*fasync) (<span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>);<br>  <span class="hljs-built_in">int</span> (*lock) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">int</span>, <span class="hljs-keyword">struct</span> file_lock *);<br>  <span class="hljs-built_in">ssize_t</span>(*readv) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">loff_t</span> *);<br>  <span class="hljs-built_in">ssize_t</span>(*writev) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> iovec *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, <span class="hljs-type">loff_t</span> *);<br>  <span class="hljs-built_in">ssize_t</span>(*sendfile) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">size_t</span>, <span class="hljs-type">read_actor_t</span>, <span class="hljs-type">void</span> __user *);<br>  <span class="hljs-built_in">ssize_t</span>(*sendpage) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> page *, <span class="hljs-type">int</span>, <span class="hljs-type">size_t</span>, <span class="hljs-type">loff_t</span> *, <span class="hljs-type">int</span>);<br>  <span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-title">long</span> <span class="hljs-params">(*get_unmapped_area)</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>, </span></span><br><span class="hljs-params"><span class="hljs-function">                  <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>,<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)</span></span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>驱动初始化四大步骤：</p><ul><li><p>1.分配</p><p>cdev变量的定义可以采用静态和动态两种办法：  </p><p>静态分配： struct cdev mdev；  </p><p>动态分配： struct cdev *pdev &#x3D; cdev_alloc()；</p></li><li><p>2.初始化</p><p>struct cdev的初始化使用cdev_init函数来完成。  </p><p>原型： cdev_init(struct cdev *cdev, const struct file_operations *fops)  </p><p>参数：  </p><p>​cdev：待初始化的cdev结构 </p><p>​ fops：设备对应的操作函数集</p></li><li><p>3.注册</p><p>字符设备的注册使用cdev_add函数来完成。</p><p>原型： cdev_add(struct cdev *p, dev_t dev, unsigned count)</p><p>参数：  </p><p>​p：待添加到内核的字符设备结构  </p><p>​dev：设备号  count：该类设备的设备个数  </p></li><li><p>4.硬件初始化</p><p>根据相应硬件的数据手册完成初始化。</p></li></ul><h3 id="实现设备操作"><a href="#实现设备操作" class="headerlink" title="实现设备操作"></a>实现设备操作</h3><p>由 struct file_operations 可以看出，要实现的操作并不少，这里只介绍一些重要的操作。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs delphi">int <span class="hljs-comment">(*open)(struct inode *, struct file *)</span> <span class="hljs-comment">//打开设备，响应open系统调用</span><br>int <span class="hljs-comment">(*release)(struct inode *, struct file *)</span>;<span class="hljs-comment">//关闭设备，响应close系统调用</span><br>loff_t <span class="hljs-comment">(*llseek)(struct file *, loff_t, int) //重定位读写指针，响应lseek系统调用</span><br><span class="hljs-comment">ssize_t (*read)(struct file *, char __user *, size_t, loff_t *)</span> <span class="hljs-comment">//从设备读取数据，响应read系统调用</span><br>ssize_t <span class="hljs-comment">(*write)(struct file *, const char __user *, size_t, loff_t *)</span> <span class="hljs-comment">//向设备写入数据，响应write系统调用</span><br></code></pre></td></tr></table></figure><p>内核空间与用户空间传递数据的函数：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> copy_to_user(<span class="hljs-built_in">void</span> __user *to, <span class="hljs-keyword">const</span> <span class="hljs-built_in">void</span> *<span class="hljs-keyword">from</span>, <span class="hljs-built_in">int</span> n)<br><span class="hljs-built_in">int</span> copy_from_user(<span class="hljs-built_in">void</span> *to, <span class="hljs-keyword">const</span> <span class="hljs-built_in">void</span> __user *<span class="hljs-keyword">from</span>, <span class="hljs-built_in">int</span> n)<br></code></pre></td></tr></table></figure><h3 id="驱动注销"><a href="#驱动注销" class="headerlink" title="驱动注销"></a>驱动注销</h3><p>驱动注销：当我们从内核中卸载驱动程序的时候，需要使用 cdev_del 函数来完成字符设备的注销。</p><h3 id="驱动程序示例"><a href="#驱动程序示例" class="headerlink" title="驱动程序示例"></a>驱动程序示例</h3><ul><li><strong>老版驱动程序</strong></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHRDEVBASE_MAJOR200<span class="hljs-comment">/* 主设备号 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> CHRDEVBASE_NAME<span class="hljs-string">&quot;chrdevbase&quot;</span> <span class="hljs-comment">/* 设备名   */</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> readbuf[<span class="hljs-number">100</span>];<span class="hljs-comment">/* 读缓冲区 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> writebuf[<span class="hljs-number">100</span>];<span class="hljs-comment">/* 写缓冲区 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> kerneldata[] = &#123;<span class="hljs-string">&quot;kernel data!&quot;</span>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 打开设备</span><br><span class="hljs-comment"> * @param - inode : 传递给驱动的inode</span><br><span class="hljs-comment"> * @param - filp : 设备文件，file结构体有个叫做private_data的成员变量</span><br><span class="hljs-comment"> *   一般在open的时候将private_data指向设备结构体。</span><br><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">chrdevbase_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//printk(&quot;chrdevbase open!\r\n&quot;);</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 从设备读取数据 </span><br><span class="hljs-comment"> * @param - filp : 要打开的设备文件(文件描述符)</span><br><span class="hljs-comment"> * @param - buf : 返回给用户空间的数据缓冲区</span><br><span class="hljs-comment"> * @param - cnt : 要读取的数据长度</span><br><span class="hljs-comment"> * @param - offt : 相对于文件首地址的偏移</span><br><span class="hljs-comment"> * @return : 读取的字节数，如果为负值，表示读取失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">chrdevbase_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 向用户空间发送数据 */</span><br><span class="hljs-built_in">memcpy</span>(readbuf, kerneldata, <span class="hljs-built_in">sizeof</span>(kerneldata));<br>retvalue = <span class="hljs-built_in">copy_to_user</span>(buf, readbuf, cnt);<br><span class="hljs-keyword">if</span>(retvalue == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;kernel senddata ok!\r\n&quot;</span>);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;kernel senddata failed!\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//printk(&quot;chrdevbase read!\r\n&quot;);</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 向设备写数据 </span><br><span class="hljs-comment"> * @param - filp : 设备文件，表示打开的文件描述符</span><br><span class="hljs-comment"> * @param - buf : 要写给设备写入的数据</span><br><span class="hljs-comment"> * @param - cnt : 要写入的数据长度</span><br><span class="hljs-comment"> * @param - offt : 相对于文件首地址的偏移</span><br><span class="hljs-comment"> * @return : 写入的字节数，如果为负值，表示写入失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">chrdevbase_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* 接收用户空间传递给内核的数据并且打印出来 */</span><br>retvalue = <span class="hljs-built_in">copy_from_user</span>(writebuf, buf, cnt);<br><span class="hljs-keyword">if</span>(retvalue == <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;kernel recevdata:%s\r\n&quot;</span>, writebuf);<br>&#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;kernel recevdata failed!\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">//printk(&quot;chrdevbase write!\r\n&quot;);</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 关闭/释放设备</span><br><span class="hljs-comment"> * @param - filp : 要关闭的设备文件(文件描述符)</span><br><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">chrdevbase_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//printk(&quot;chrdevbase release！\r\n&quot;);</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 设备操作函数结构体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> chrdevbase_fops = &#123;<br>.owner = THIS_MODULE,<br>.open = chrdevbase_open,<br>.read = chrdevbase_read,<br>.write = chrdevbase_write,<br>.release = chrdevbase_release,<br>&#125;;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 驱动入口函数 </span><br><span class="hljs-comment"> * @param : 无</span><br><span class="hljs-comment"> * @return : 0 成功;其他 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">chrdevbase_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> retvalue = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 注册字符设备驱动 */</span><br>retvalue = <span class="hljs-built_in">register_chrdev</span>(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME, &amp;chrdevbase_fops);<br><span class="hljs-keyword">if</span>(retvalue &lt; <span class="hljs-number">0</span>)&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;chrdevbase driver register failed\r\n&quot;</span>);<br>&#125;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;chrdevbase init!\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 驱动出口函数</span><br><span class="hljs-comment"> * @param : 无</span><br><span class="hljs-comment"> * @return : 无</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">chrdevbase_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* 注销字符设备驱动 */</span><br><span class="hljs-built_in">unregister_chrdev</span>(CHRDEVBASE_MAJOR, CHRDEVBASE_NAME);<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;chrdevbase exit!\r\n&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * 将上面两个函数指定为驱动的入口和出口函数 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">module_init</span>(chrdevbase_init);<br><span class="hljs-built_in">module_exit</span>(chrdevbase_exit);<br><br><span class="hljs-comment">/* </span><br><span class="hljs-comment"> * LICENSE和作者信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-built_in">MODULE_AUTHOR</span>(<span class="hljs-string">&quot;lk&quot;</span>);<br></code></pre></td></tr></table></figure><ul><li><strong>新版驱动程序</strong></li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ide.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/cdev.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/mach/map.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEWCHRLED_CNT1  <span class="hljs-comment">/* 设备号个数 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NEWCHRLED_NAME<span class="hljs-string">&quot;newchrled&quot;</span><span class="hljs-comment">/* 名字 */</span></span><br><br><span class="hljs-comment">/* newchrled设备结构体 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">newchrled_dev</span>&#123;<br><span class="hljs-type">dev_t</span> devid;<span class="hljs-comment">/* 设备号  */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">cdev</span> cdev;<span class="hljs-comment">/* cdev */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">class</span> *<span class="hljs-keyword">class</span>;<span class="hljs-comment">/* 类 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">device</span> *device;<span class="hljs-comment">/* 设备  */</span><br><span class="hljs-type">int</span> major;<span class="hljs-comment">/* 主设备号  */</span><br><span class="hljs-type">int</span> minor;<span class="hljs-comment">/* 次设备号   */</span><br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">newchrled_dev</span> newchrled;<span class="hljs-comment">/* led设备 */</span><br><br><span class="hljs-comment">/* 打开设备 */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span></span><br><span class="hljs-function"></span>&#123;<br>filp-&gt;private_data = &amp;newchrled; <span class="hljs-comment">/* 设置私有数据 */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 从设备读取数据  */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">led_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 向设备写数据  */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 关闭/释放设备  */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">led_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 设备操作函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> newchrled_fops = &#123;<br>.owner = THIS_MODULE,<br>.open = led_open,<br>.read = led_read,<br>.write = led_write,<br>.release = led_release,<br>&#125;;<br><br><span class="hljs-comment">/* 驱动入口函数 */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* 注册字符设备驱动 */</span><br><span class="hljs-comment">/* 1、创建设备号 */</span><br><span class="hljs-keyword">if</span> (newchrled.major) &#123;<span class="hljs-comment">/*  定义了设备号 */</span><br>newchrled.devid = <span class="hljs-built_in">MKDEV</span>(newchrled.major, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">register_chrdev_region</span>(newchrled.devid, NEWCHRLED_CNT, NEWCHRLED_NAME);<br>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">/* 没有定义设备号 */</span><br><span class="hljs-built_in">alloc_chrdev_region</span>(&amp;newchrled.devid, <span class="hljs-number">0</span>, NEWCHRLED_CNT, NEWCHRLED_NAME);<span class="hljs-comment">/* 申请设备号 */</span><br>newchrled.major = <span class="hljs-built_in">MAJOR</span>(newchrled.devid);<span class="hljs-comment">/* 获取分配号的主设备号 */</span><br>newchrled.minor = <span class="hljs-built_in">MINOR</span>(newchrled.devid);<span class="hljs-comment">/* 获取分配号的次设备号 */</span><br>&#125;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;newcheled major=%d,minor=%d\r\n&quot;</span>,newchrled.major, newchrled.minor);<br><br><span class="hljs-comment">/* 2、初始化cdev */</span><br>newchrled.cdev.owner = THIS_MODULE;<br><span class="hljs-built_in">cdev_init</span>(&amp;newchrled.cdev, &amp;newchrled_fops);<br><br><span class="hljs-comment">/* 3、添加一个cdev */</span><br><span class="hljs-built_in">cdev_add</span>(&amp;newchrled.cdev, newchrled.devid, NEWCHRLED_CNT);<br><br><span class="hljs-comment">/* 4、创建类 */</span><br>newchrled.<span class="hljs-keyword">class</span> = <span class="hljs-built_in">class_create</span>(THIS_MODULE, NEWCHRLED_NAME);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_ERR</span>(newchrled.<span class="hljs-keyword">class</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">PTR_ERR</span>(newchrled.<span class="hljs-keyword">class</span>);<br>&#125;<br><br><span class="hljs-comment">/* 5、创建设备 */</span><br>newchrled.device = <span class="hljs-built_in">device_create</span>(newchrled.<span class="hljs-keyword">class</span>, <span class="hljs-literal">NULL</span>, newchrled.devid, <span class="hljs-literal">NULL</span>, NEWCHRLED_NAME);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_ERR</span>(newchrled.device)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">PTR_ERR</span>(newchrled.device);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 驱动出口函数 */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">led_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* 注销字符设备驱动 */</span><br><span class="hljs-built_in">cdev_del</span>(&amp;newchrled.cdev);  <span class="hljs-comment">/* 删除cdev */</span><br><span class="hljs-built_in">unregister_chrdev_region</span>(newchrled.devid, NEWCHRLED_CNT); <span class="hljs-comment">/* 注销设备号 */</span><br><br><span class="hljs-built_in">device_destroy</span>(newchrled.<span class="hljs-keyword">class</span>, newchrled.devid);<br><span class="hljs-built_in">class_destroy</span>(newchrled.<span class="hljs-keyword">class</span>);<br>&#125;<br><br><span class="hljs-built_in">module_init</span>(led_init);<br><span class="hljs-built_in">module_exit</span>(led_exit);<br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-built_in">MODULE_AUTHOR</span>(<span class="hljs-string">&quot;lk&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="LCD驱动模型"><a href="#LCD驱动模型" class="headerlink" title="LCD驱动模型"></a>LCD驱动模型</h2><h2 id="总线设备驱动模型"><a href="#总线设备驱动模型" class="headerlink" title="总线设备驱动模型"></a>总线设备驱动模型</h2><p>自内核2.6版本开始，需要关注的是总线、设备和驱动这3个实体，总线将设备和驱动绑定。在Linux内核 系统中注册一个设备的时候，会寻找与之对应驱动进行匹配；相反地，系统中注册一个驱动的时候，会 去寻找一个对应的设备进行匹配。匹配的的工作由总线来完成。</p><p><strong>在Linux设备中有的是没有对应的物理总线的，但为了适配Linux的总线模型，内核针对这种没有物理总 线的设备开发了一种虚拟总线——platform总线。</strong></p><p>将设备和驱动独立开，驱动尽可能写的通用，当来了一个类似的设备1后也可以使用这个驱动，让驱动程 序可以重用。这体现了Linux驱动的软件架构设计的思想。 </p><p>按照这个思路，Linux中的设备和驱动都需要挂接在一种总线上，比如i2c总线上的eeprom，eeprom作 为设备，eeprom的驱动都挂接在i2c驱动上。但是在嵌入式系统中，<strong>soc系统一般都会集成独立的i2c控制器，控制器也是需要驱动的，但是再按照设备-总线-驱动模型进行设计，就会发现无法找到一个合适 总线去挂接控制器设备和控制器驱动了（i2c控制器是挂接在CPU内部的总线上，而不是i2c总线）</strong>，所 以Linux发明了一种<strong>虚拟总线，称为platform总线，相应的设备称为platform_device（控制器设 备），对应的驱动platform_driver（控制器驱动）</strong>，用platform总线来承载这些相对特殊的系统。 </p><p>注意：所谓的platform_device并不是与字符设备、块设备和网络设备并列的概念，而是Linux系统提 供的一种附加手段，例如，在 S3C6410处理器中，把内部集成的I2C、RTC、SPI、LCD、看门狗等控制器都归纳为platform_device，而它们本身就是字符设备。我们要记住，platform 驱动只是在字符设备 驱动外套一层platform_driver 的外壳。引入platform模型符合Linux 设备模型 —— 总线、设备、驱动，设备模型中配套的sysfs节点都可以用，方便我们的开发；当然你也可以选择不用，不过就失去了一 些platform带来的便利。</p><p>设备驱动中引入platform 概念，隔离BSP和驱动。在BSP中定义platform设备和设备使用的资源、设备 的具体匹配信息，而在驱动中，只需要通过API去获取资源和数据，做到了板相关代码和驱动代码的分 离，使得驱动具有更好的可扩展性和跨平台性。</p><p><img src="/./../photo/image-20231211160624274.png" alt="image-20231211160624274"></p><p>下面分析下总线设备驱动模型的匹配过程</p><p>一边的“device”结构体和另一边的“较稳定的 drivice 代码”的联系：“device_add()”除了将“devcie”结构放 到 bus 的“dev 链表”之外，还会从另一边的“drv”链表中取表元即某个“driver”结构，<strong>用总线里的一个 （.match）函数来作比较</strong>，看另一边的“driver”是否支持一边的“device”。若是能够支持，则接着<strong>调用软件驱动部分的“.probe”函数</strong>。</p><p>“driver_register()”会将“bus_drv_dev”模型中的较稳定代码“driver”结构体放到虚拟总线的某个链表 （drv 链表）中。从另一边的“dev”链表中<strong>取出每一个“device”结构用 bus 中的“.match”函数来作比较， 若支持则调用“.probe”函数</strong>。左右两个注册就建立起来的一种机制。在“.probe”函数中做的事件由自已决 定，打印一句话，或注册一个字符设备，再或注册一个“input_dev”结构体等等都是由自已决定。强制的 把一个驱动程序分为左右两边这种机制而已，可以把这套东西放在任何地方，这里的“driver”只是个结构 体不要被这个名字迷惑，“device”也只是个结构体，里面放什么内容都是由自已决定的。</p><h2 id="输入子系统模型"><a href="#输入子系统模型" class="headerlink" title="输入子系统模型"></a>输入子系统模型</h2><p>每个硬件都有一个input_dev结构体，每个软件都有一个input_handler结构体。input_dev和 input_handler分别通过input_register_device(),input_register_handler()向核心层注册硬件和软件。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-built_in">input_register_device</span>(struct input_dev *dev)   <span class="hljs-comment">//*dev:要注册的驱动设备</span><br>&#123;<br> ... ...<br>       <span class="hljs-built_in">list_add_tail</span>(&amp;dev-&gt;node, &amp;input_dev_list);   <span class="hljs-comment">//(1)放入链表中</span><br> ... ...<br>       <span class="hljs-built_in">list_for_each_entry</span>(handler, &amp;input_handler_list, node)  <span class="hljs-comment">//(2)</span><br>       <span class="hljs-built_in">input_attach_handler</span>(dev, handler);<br> ... ...<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/./../photo/image-20231211160843845.png" alt="image-20231211160843845"></p><p><strong>从input_dev方向分析：</strong> input设备在增加到input_dev_list链表上之后，会查找 input_handler_list事件 处理链表上的handler进行匹配，这里的匹配 方式与总线设备驱动模型的device和driver匹配过程很相 似，<strong>所有的input_device都挂在input_dev_list上，所有类型的事件都挂在input_handler_list 上，进行 “匹配相亲”</strong>。如果匹配上了，就<strong>调用input_handler的connect函数进行连接</strong>。设备就是在此时注册的</p><p><strong>从input_handler方向分析：</strong>将handler挂到链表input_handler_list下，然后遍历input_dev_list链表,查 找并匹配输入设备对应的事件处理层，如果匹配上了，就调用connect函数进行连接，并创建 input_handle结构。</p><p>所以，不管新添加input_dev还是input_handler,都会进入input_attach_handler()判断两者id是否有支 持, 若两者支持便进行连接。</p><h2 id="platform平台匹配规则"><a href="#platform平台匹配规则" class="headerlink" title="platform平台匹配规则"></a>platform平台匹配规则</h2><p>总线，设备，驱动。匹配规则就是当有一个新的设备挂起时，总线被唤醒，match函数被调用，用 device名字去跟本总线下的所有驱动名字去比较。相反就是用驱动的名字去device链表中和所有device 的名字比较。如果匹配上，才会调用驱动中的probe函数，否则不调用。至于先后顺序，鉴于个人理 解，不会有影响，不管谁先谁后，bus都会完成匹配工作。谈谈对Linux设备驱动模型的认识：设备驱动 模型的出现主要有三个好处，设备与驱动分离，驱动可移植性增强；设备驱动抽象结构以总线结构表示 看起来更加清晰明了，谁是属于哪一条bus的；最后，就是大家最熟悉的热插拔了，设备与驱动分离， 很好的奠定了热插拔机制</p><h1 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h1><h2 id="镜像格式"><a href="#镜像格式" class="headerlink" title="镜像格式"></a>镜像格式</h2><ol><li><strong>uboo</strong>t经过编译直接生成的<strong>elf格式的可执行程序是u-boot</strong>，这个程序类似于windows下的exe格式，在操作系统下是<strong>可以直接执行</strong>的。但是这种格式不能用来烧录下载。我们用来烧录下载的是uboot.bin，这个东西是由u-boot使用arm-linux-objcopy工具进行加工（主要目的是去掉一些无用 的）得到的。这个<strong>u-boot.bin就叫镜像（image）</strong>，镜像就是用来烧录到iNand中执行的。 </li><li><strong>linux内核</strong>经过编译后也会生成一个<strong>elf格式的可执行程序，叫vmlinux或vmlinuz</strong>，这个就是原始的未经任何处理加工的原版内核elf文件；嵌入式系统部署时烧录的一般不是这个 vmlinuz&#x2F;vmlinux，而是要用objcopy工具去制作成烧录镜像格式（就是u-boot.bin这种，但是内核没有.bin后缀），<strong>经过制作加工成烧录镜像的文件就叫Image</strong>（制作把78M大的精简成了7.5M，因 此这个制作烧录镜像主要目的就是缩减大小，节省磁盘）。 </li><li>原则上Image就可以直接被烧录到Flash上进行启动执行（类似于u-boot.bin），但是实际上并不是 这么简单。实际上linux的作者们觉得Image还是太大了所以对Image进行了压缩，并且<strong>在image压缩后的文件的前端附加了一部分解压缩代码。构成了一个压缩格式的镜像就叫zImage</strong>。（因为当 年Image大小刚好比一张软盘（软盘有2种，1.2M的和1.44MB两种）大，为了节省1张软盘的钱于是乎设计了这种压缩Image成zImage的技术）。 </li><li>uboot为了启动linux内核，还发明了一种内核格式叫uImage。<strong>uImage是由zImage加工得到的， uboot中有一个工具，可以将zImage加工生成uImage</strong>。注意：<strong>uImage不关linux内核的事</strong>，linux 内核只管生成zImage即可，然后uboot中的mkimage工具再去由zImage加工生成uImage来给 uboot启动。这个加工过程其实就是在zImage前面加上64字节的uImage的头信息即可。 </li><li>原则上uboot启动时应该给他uImage格式的内核镜像，但是实际上uboot中也可以支持zImage， 是否支持就看x210_sd.h中是否定义了LINUX_ZIMAGE_MAGIC这个宏。所以大家可以看出：<strong>有些 uboot是支持zImage启动的，有些则不支持。但是所有的uboot肯定都支持uImage启动</strong>。 </li><li>如果直接在kernel底下去make uImage会提供mkimage command not found。解决方案是去 uboot&#x2F;tools下cp mkimage &#x2F;usr&#x2F;local&#x2F;bin&#x2F;，复制mkimage工具到系统目录下。再去make  uImage即可</li></ol><p>通过上面的介绍我们了解了内核镜像的各种格式，<strong>如果通过uboot启动内核，Linux必须为uImage 格式</strong>。</p><h2 id="内核中申请内存函数"><a href="#内核中申请内存函数" class="headerlink" title="内核中申请内存函数"></a>内核中申请内存函数</h2><h3 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc"></a>kmalloc</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">kmalloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size, <span class="hljs-type">gfp_t</span> flags)</span></span><br></code></pre></td></tr></table></figure><p>kmalloc是内核中最常用的一种内存分配方式，它通过调用kmem_cache_alloc函数来实现。kmalloc一 次最多能申请的内存大小由include&#x2F;linux&#x2F;Kmalloc_size.h的内容来决定，在默认的2.6.18内核版本中， kmalloc一次<strong>最多能申请大小为131702B也就是128KB字节</strong>的<strong>连续物理内存</strong>。测试结果表明，如果试图 用kmalloc函数分配大于128KB的内存，编译不能通过</p><h3 id="vmalloc"><a href="#vmalloc" class="headerlink" title="vmalloc"></a>vmalloc</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">vmalloc</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span></span><br></code></pre></td></tr></table></figure><p>前面内存分配方式是<strong>物理连续的</strong>，<strong>能保证较低的平均访问时间</strong>。但是在某些场合中，对内存区的请求不是很频繁，较高的内存访问时间也可以接受，这是<strong>就可以分配一段线性连续，物理不连续的地 址，带来的好处是一次可以分配较大块的内存</strong>。vmallocvmalloc对一次能分配的内存大小没有明确限制。出于性能考虑，应谨慎使用vmalloc函数。在测试过程中，<strong>最大能一次分配1GB的空间</strong>。</p><h3 id="dma-alloc-coherent"><a href="#dma-alloc-coherent" class="headerlink" title="dma_alloc_coherent"></a>dma_alloc_coherent</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">dma_alloc_coherent</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> device *dev, <span class="hljs-type">size_t</span> size,<span class="hljs-type">ma_addr_t</span> *dma_handle, <span class="hljs-type">gfp_t</span> gfp)</span></span><br></code></pre></td></tr></table></figure><p><strong>DMA是一种硬件机制，允许外围设备和主存之间直接传输IO数据，而不需要CPU的参与</strong>，<strong>使用DMA机制 能大幅提高与设备通信的吞吐量</strong>。DMA操作中，涉及到CPU高速缓存和对应的内存数据一致性的问题， 必须保证两者的数据一致，在x86_64体系结构中，硬件已经很好的解决了这个问题，  dma_alloc_coherent和get_free_pages函数实现差别不大，前者实际是调用alloc_pages函数来分配内存，因此一次分配内存的大小限制和后者一样。__get_free_pages分配的内存同样可以用于DMA操作。 测试结果证明，<strong>dma_alloc_coherent函数一次能分配的最大内存也为4M</strong></p><h3 id="oiremap"><a href="#oiremap" class="headerlink" title="oiremap"></a>oiremap</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">void</span> * <span class="hljs-title">ioremap</span> <span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> offset, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span></span><br></code></pre></td></tr></table></figure><p>ioremap是一种更直接的内存“分配”方式，使用时直接指定物理起始地址和需要分配内存的大小，然后将该段物理地址映射到内核地址空间。<strong>ioremap用到的物理地址空间都是事先确定的****，和上面的几种内存分配方式并不太一样，并不是分配一段新的物理内存。</strong>ioremap多用于设备驱动**，可以让CPU直接访问外部设备的IO空间。ioremap能映射的内存由原有的物理内存空间决定，所以没有进行测试</p><h2 id="内核空间与用户空间"><a href="#内核空间与用户空间" class="headerlink" title="内核空间与用户空间"></a>内核空间与用户空间</h2><p>对 32 位操作系统而言，它的寻址空间（虚拟地址空间，或叫线性地址空间）为 4G（2的32次方）。也就是说一个进程的最大地址空间为 4G。 </p><p>操作系统的核心是内核(kernel)，它独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层 硬件设备的所有权限。为了保证内核的安全，<strong>现在的操作系统一般都强制用户进程不能直接操作内核。 具体的实现方式基本都是由操作系统将虚拟地址空间划分为两部分，一部分为内核空间，另一部分为用 户空间。</strong>针对 Linux 操作系统而言，<strong>最高的 1G 字节</strong>(从虚拟地址 0xC0000000 到 0xFFFFFFFF)由内核使 用，称为内核空间。而<strong>较低的 3G 字节</strong>(从虚拟地址 0x00000000 到 0xBFFFFFFF)由各个进程使用，称为用户空间。 </p><p>对上面这段内容我们也可以这样理解： 每个进程的 4G 地址空间中，最高 1G 都是一样的，即内核空间。只有剩余的 3G 才归进程自己使 用。换句话说就是， <strong>最高 1G 的内核空间是被所有进程共享的</strong>！ 下图描述了每个进程 4G 地址空间的分配情况。</p><p><img src="/./../photo/image-20231211165915274.png" alt="image-20231211165915274"></p><h2 id="为什么需要区分内核空间与用户空间？"><a href="#为什么需要区分内核空间与用户空间？" class="headerlink" title="为什么需要区分内核空间与用户空间？"></a>为什么需要区分内核空间与用户空间？</h2><p>在 CPU 的所有指令中，有些指令是非常危险的，如果错用，将导致系统崩溃，比如<strong>清内存、设置时钟</strong> 等。如果允许所有的程序都可以使用这些指令，那么系统崩溃的概率将大大增加。 </p><p>所以，CPU 将指令分为特权指令和非特权指令，对于那些危险的指令，只允许操作系统及其相关模块使 用，普通应用程序只能使用那些不会造成灾难的指令。比如 Intel 的 CPU 将特权等级分为 4 个级别： Ring0~Ring3。 </p><p>其实 Linux 系统只使用了 Ring0 和 Ring3 两个运行级别(Windows 系统也是一样的)。当进程运行在  Ring3 级别时被称为运行在用户态，而运行在 Ring0 级别时被称为运行在内核态</p><h2 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h2><p>当进程运行在内核空间时就处于内核态，而进程运行在用户空间时则处于用户态。 </p><p>在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限 制，可以自由地访问任何有效地址，也可以直接进行端口的访问。 </p><p>在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其 地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I&#x2F;O 许可位 图(I&#x2F;O Permission Bitmap)中规定的可访问端口进行直接访问。 </p><p>对于以前的 DOS 操作系统来说，是没有内核空间、用户空间以及内核态、用户态这些概念的。可以认为 所有的代码都是运行在内核态的，因而，用户编写的应用程序代码可以很容易的让操作系统崩溃掉。 </p><p>对于 Linux 来说，通过区分内核空间和用户空间的设计，<strong>隔离了操作系统代码(操作系统的代码要比应用 程序的代码健壮很多)与应用程序代码</strong>。即便是单个应用程序出现错误，也不会影响到操作系统的稳定 性，这样其它的程序还可以正常的运行(Linux 可是个多任务系统啊！)。所以，<strong>区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性</strong>。</p><h2 id="内核空间与用户空间的通信方式"><a href="#内核空间与用户空间的通信方式" class="headerlink" title="内核空间与用户空间的通信方式"></a>内核空间与用户空间的通信方式</h2><h3 id="使用API"><a href="#使用API" class="headerlink" title="使用API"></a>使用API</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">get_user</span><span class="hljs-params">(x，ptr)</span></span> <span class="hljs-comment">//在内核中被调用，获取用户空间指定地址的数值并保存到内核变量x中。</span><br><span class="hljs-function"><span class="hljs-title">put_user</span><span class="hljs-params">(x，ptr)</span></span> <span class="hljs-comment">//在内核中被调用，将内核空间的变量x的数值保存到到用户空间指定地址处。</span><br><span class="hljs-function"><span class="hljs-title">Copy_from_user</span><span class="hljs-params">()</span></span>/<span class="hljs-built_in">copy_to_user</span>() <span class="hljs-comment">//主要应用于设备驱动读写函数中，通过系统调用触发。</span><br></code></pre></td></tr></table></figure><h3 id="使用proc文件系统"><a href="#使用proc文件系统" class="headerlink" title="使用proc文件系统"></a>使用proc文件系统</h3><p>和sysfs文件系统类似，也可以作为内核空间和用户空间交互的手段。&#x2F;proc 文件系统是一种虚拟文 件系统，通过他可以作为一种linux内核空间和用户空间的。与普通文件不同，这里的虚拟文件的内 容都是动态创建的。使用&#x2F;proc文件系统的方式很简单。调用create_proc_entry，返回一个 proc_dir_entry指针，然后去填充这个指针指向的结构就好了</p><h3 id="使用sysfs文件系统-kobject"><a href="#使用sysfs文件系统-kobject" class="headerlink" title="使用sysfs文件系统+kobject"></a>使用sysfs文件系统+kobject</h3><p>每个在内核中注册的kobject都对应着sysfs系统中的一个目录。可以通过读取根目录下的sys目录中 的文件来获得相应的信息。除了sysfs文件系统和proc文件系统之外，一些其他的虚拟文件系统也 能同样达到这个效果。</p><h3 id="netlink"><a href="#netlink" class="headerlink" title="netlink"></a>netlink</h3><p>netlink socket提供了一组类似于BSD风格的API，用于用户态和内核态的IPC。相比于其他的用户 态和内核态IPC机制，netlink有几个好处：1.使用自定义一种协议完成数据交换，不需要添加一个 文件等。2.可以支持多点传送。3.支持内核先发起会话。4.异步通信，支持缓存机制。</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>应该说这是一种比较笨拙的做法，不过确实可以这样用。当处于内核空间的时候，直接操作文件， 将想要传递的信息写入文件，然后用户空间可以读取这个文件便可以得到想要的数据了。下面是一 个简单的测试程序，在内核态中，程序会向“&#x2F;home&#x2F;melody&#x2F;str_from_kernel”文件中写入一条字 符串，然后我们在用户态读取这个文件，就可以得到内核态传输过来的数据了</p><h3 id="使用mmap"><a href="#使用mmap" class="headerlink" title="使用mmap"></a>使用mmap</h3><p>以将内核空间的地址映射到用户空间。在以前做嵌入式的时候用到几次。一方面可以在driver中 修改Struct file_operations结构中的mmap函数指针来重新实现一个文件对应的映射操作。另一方 面，也可以直接打开&#x2F;dev&#x2F;mem文件，把物理内存中的某一页映射到进程空间中的地址上。 其实，除了重写Struct file_operations中mmap函数，我们还可以重写其他的方法如ioctl等，来达 到驱动内核空间和用户空间通信的方式。</p><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>从内核空间向进程发送信号。这个倒是经常遇到，用户程序出现重大错误，内核发送信号杀死相应 进程。</p><h2 id="内核链表的通用性"><a href="#内核链表的通用性" class="headerlink" title="内核链表的通用性"></a>内核链表的通用性</h2><p>内核中由于要管理大量的设备，但是各种设备各不相同，必须将他们统一起来管理，于是内核设计者就 想到了使用通用链表来处理，通用链表看似神秘，实际上就是<strong>双向循环链表</strong>，<strong>这个链表的每个节点都是 只有指针域，没有任何数据域</strong></p><p><img src="/./../photo/image-20231211170829736.png" alt="image-20231211170829736"></p><p>使用通用链表的好处是：</p><ol><li>通用链表中每个节点中没有数据域，也就是说无论数据结构有多复杂在链表中只有前后级指针。 </li><li>如果一个数据结构（即是描述设备的设备结构体）想要用通用链表管理，只需要在结构体中包含节 点的字段即可</li><li>双向链表可以从任意一个节点的前后遍历整个链表，遍历非常方便。 </li><li>使用循环链表使得可以不断地循环遍历管理节点，像进程的调度：操作系统会把就绪的进程放在一 个管理进程的就绪队列的通用链表中管理起来，循环不断地，为他们分配时间片，获得cpu进行周 而复始的进程调度</li></ol><h2 id="用户空间到内核空间的执行过程"><a href="#用户空间到内核空间的执行过程" class="headerlink" title="用户空间到内核空间的执行过程"></a>用户空间到内核空间的执行过程</h2><p>1.应用层调用open函数，在VFS层中找到struct inode结构体，判断是字符设备还是块设备，根据设 备号，可以找到对应的驱动程序。</p><p>2.在驱动层中，每个字符设备都有一个struct cdev结构体，这个结构体通过struct inode结构体中的 i_cdev把连接起VFS层和驱动层，struct cdev结构体描述了字符设备所有信息，其中最重要的一项 就是字符设备的操作函数接口 </p><p>3.struct cdev结构体中的struct file结构体记录了操作字符设备的一些函数，比如open read write 函数等。 struct file结构体其实是在VFS层的，通过struct file结构体指针指向驱动层的struct file结构体将驱 动层函数和VFS层链接起来 </p><p>4.任务完成，VFS层会给应用返回一个文件描述符（fd）。这个fd是和struct file结构体对应的</p><h1 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h1><h2 id="主设备号和次设备号的用途"><a href="#主设备号和次设备号的用途" class="headerlink" title="主设备号和次设备号的用途"></a>主设备号和次设备号的用途</h2><p><strong>主设备号：</strong></p><p><strong>主设备号标识设备对应的特定的驱动程序。</strong>虽然现代的linux内核允许多个驱动程序共享主设 备号，但我们看待的大多数设备仍然按照“一个主设备对应一个驱动程序”的原则组织。 </p><p><strong>次设备号：</strong></p><p><strong>次设备号由内核使用，用于确定由主设备号对应驱动程序中的各个设备</strong>。依赖于驱动程序的 编写方式，我们可以通过次设备号获得一个指向内核设备的直接指针，也可将此设备号当作设备本地数 组的索引。</p><h2 id="字符设备驱动如何创建设备文件？"><a href="#字符设备驱动如何创建设备文件？" class="headerlink" title="字符设备驱动如何创建设备文件？"></a>字符设备驱动如何创建设备文件？</h2><ol><li><p>手动创建 </p><p>mknod &#x2F;dev&#x2F;led c 250 0 ，其中dev&#x2F;led 为设备节点 ,c 代表字符设备, 250代表主设备号, 0代表 次设备号。</p></li><li><p>自动创建  </p><p>UDEV&#x2F;MDEV是运行在用户态的程序，可以动态管理设备文件，包括创建和删除设备文件，运行在 用户态意味着系统要运行之后，在 &#x2F;etc&#x2F;init.d&#x2F;rcS 脚本文件中会执行 mdev -s 自动创建设备节点</p></li></ol><h2 id="如何注册一个字符设备？"><a href="#如何注册一个字符设备？" class="headerlink" title="如何注册一个字符设备？"></a>如何注册一个字符设备？</h2><ol><li><p>void cdev_init(struct cdev *cdev, struct file_operations *fops) </p><p>该注册函数可以将cdev结构嵌入到自己的设备特定的结构中。cdev是一个指向结构体cdev的指 针，而fops是指向一个类似于f file_operations结构（可以是file_operations结构，但不限于该结 构）的指针。 </p></li><li><p>int register_chrdev(unsigned int major, const char *namem , struct file  operations *fopen); </p><p>该注册函数是早期的注册函数，major是设备的主设备号，name是驱动程序的名称，而fops是默 认的file_operations结构（这是只限于file_operations结构）。对于register_chrdev的调用将为给 定的主设备号注册0－255作为次设备号，并为每个 设备建 立一个对应的默认cdev结构</p></li></ol><h2 id="dev目录下的文件如何产生？"><a href="#dev目录下的文件如何产生？" class="headerlink" title="&#x2F;dev目录下的文件如何产生？"></a>&#x2F;dev目录下的文件如何产生？</h2><p>普遍说法有三种方式，devfs机制，udev机制，再有一个就是手动创建设备节点。谈谈个人见解： </p><ol><li>devfs机制从来没用过，应该是2.6以前的内核使用的； </li><li>udev，其实就是现在<strong>常用的device_create()、class_create()这一套接口</strong>，所谓udev是上层用户空 间程序，是基于驱动中创建使用了这两个接口而起作用的，但是udev在日常开发中几乎接触不到， 我们只需在驱动中调用创建节点的这两个API就ok了，剩下的工作就交给udev去做了，有想深究它 具体实现原理的那就自己去研究吧，我觉得会用就行了；</li><li><strong>mknod</strong> ，新手最常用的一种创建设备节点方法，但并非入门后就再没有用途，在某些情境下，或 许有人不想使用udev机制，于是把节点创建工作写在脚本里，这样也是无可厚非的</li></ol><h2 id="字符设备和块设备的区别？"><a href="#字符设备和块设备的区别？" class="headerlink" title="字符设备和块设备的区别？"></a>字符设备和块设备的区别？</h2><p>Linux中I&#x2F;O设备分为两类：块设备和字符设备。两种设备本身没有严格限制，但是，基于不同的功能进 行了分类。 </p><p><strong>字符设备：</strong>提供连续的数据流，应用程序可以顺序读取，通常不支持随机存取。相反，此类设备支持按 字节&#x2F;字符来读写数据。字符终端、串口、鼠标、键盘、摄像头、声卡和显卡等就是典型的字符设备。 </p><p><strong>块设备：</strong>应用程序可以随机访问设备数据，程序可自行确定读取数据的位置。硬盘是典型的块设备，应 用程序可以寻址磁盘上的任何位置，并由此读取数据。此外，数据的读写只能以块(通常是512B)的倍数 进行。与字符设备不同，块设备并不支持基于字符的寻址。如：u盘，SD卡，磁盘等</p><h2 id="为什么需要ioremap？"><a href="#为什么需要ioremap？" class="headerlink" title="为什么需要ioremap？"></a>为什么需要ioremap？</h2><p>ioremp是内核中用来将外设寄存器物理地址映射到主存上去的接口，即将io地址空间映射到虚拟地址空 间上去，便于操作。为什么非要映射呢，因为保护模式下的cpu只认虚拟地址，不认物理地址，给它物 理地址它并不帮你做事，所以你要操作外设上的寄存器必须先映射到虚拟内存空间，拿着虚拟地址去跟 cpu对接，从而操作寄存器。</p><h2 id="insmod-rmmod对应驱动中的函数？"><a href="#insmod-rmmod对应驱动中的函数？" class="headerlink" title="insmod&#x2F;rmmod对应驱动中的函数？"></a>insmod&#x2F;rmmod对应驱动中的函数？</h2><p>分别会执行 module_init() 和 module_exit() 指定的init函数和exit函数。要注意的就是，尽量使在 init函数中出现的资源申请及使用，都要有对应的释放操作在exit中，即init申请，eixt释放。 </p><h2 id="nand驱动的-probe流程"><a href="#nand驱动的-probe流程" class="headerlink" title="nand驱动的 probe流程"></a>nand驱动的 probe流程</h2><p>probe 函数就会与NAND 芯片进行，主要做的事情主要包括这几个方面：读取NAND 芯片的ID ，然后查 表得到这片NAND 芯片的如厂商，page size ，erase size 以及chip size 等信息，接着，根据struct  nand_chip 中options 的值的不同，或者在NAND 芯片中的特定位置查找bad block table ，或者scan  整个NAND 芯片，并在内存中建立bad block table 。说起来复杂，但其实所有的这些动作，都可以在 MTD 提供的一个叫做nand_scan 的函数中完成。</p><h2 id="常用的调式技巧"><a href="#常用的调式技巧" class="headerlink" title="常用的调式技巧"></a>常用的调式技巧</h2><p>利用printk，查看OOP消息，利用strace，利用内核内置的hacking选项，利用ioctl方法，利用&#x2F;proc 文 件系统，使用kgdb。</p><h1 id="驱动中常用的操作函数"><a href="#驱动中常用的操作函数" class="headerlink" title="驱动中常用的操作函数"></a>驱动中常用的操作函数</h1><h2 id="ioremap"><a href="#ioremap" class="headerlink" title="ioremap"></a>ioremap</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">void</span> * __ioremap(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> phys_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags)<br><span class="hljs-function"><span class="hljs-type">void</span> *<span class="hljs-title">ioremap</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> phys_addr, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size)</span></span><br></code></pre></td></tr></table></figure><p>将一个IO地址空间映射到内核的虚拟地址空间上去，便于访问。</p><p>ioremap是内核提供的用来映射外设寄存器到主存的函数，我们要映射的地址已经从pci_dev中读了出来 （上一步），这样就水到渠成的成功映射了而不会和其他地址有冲突。映射完了有什么效果呢？我举个 例子，比如某个网卡有100 个寄存器，他们都是连在一块的，位置是固定的，假如每个寄存器占4个字节 那么一共400个字节的空间被映射到内存成功后，ioaddr就是这段地址的开头（注意ioaddr是虚拟地 址，而mmio_start是物理地址，它是BIOS得到的，肯定是物理地址，而保护模式下CPU不认物理地址，只认虚拟地址），ioaddr+0就是第一个寄存器的地址，ioaddr+4就是第二个寄存器地址（每个寄存器占 4个字节），以此类推，我们就能够在内存中访问到所有的寄存器进而操控他们了。</p><h2 id="open"><a href="#open" class="headerlink" title="open"></a>open</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> * pathname, <span class="hljs-type">int</span> flags)</span></span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">open</span><span class="hljs-params">( <span class="hljs-type">const</span> <span class="hljs-type">char</span> * pathname,<span class="hljs-type">int</span> flags, <span class="hljs-type">mode_t</span> mode)</span></span>;<br></code></pre></td></tr></table></figure><p>pathname ：文件的名称，可以包含（绝对和相对）路径 </p><p>flags：文件打开模式 </p><p>mode: 用来规定对该文件的所有者，文件的用户组及系统中其他用户的访问权限，则文件权限为： mode&amp;(~umask)</p><h2 id="read"><a href="#read" class="headerlink" title="read"></a>read</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> * buf, <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>read()会把参数fd所指的文件传送count 个字节到buf 指针所指的内存中</p><p><strong>返回值</strong>为实际读取到的字节数, 如果返回0, 表示已到达文件尾或是无可读取的数据。若参数count 为0, 则 read()不会有作用并返回0。</p><h2 id="write"><a href="#write" class="headerlink" title="write"></a>write</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">ssize_t</span> <span class="hljs-title">write</span> <span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">const</span> <span class="hljs-type">void</span> * buf, <span class="hljs-type">size_t</span> count)</span></span>;<br></code></pre></td></tr></table></figure><p>write()会把参数buf所指的内存写入count个字节到参数放到所指的文件内</p><p><strong>返回值</strong>，如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中</p><h2 id="copy-to-user"><a href="#copy-to-user" class="headerlink" title="copy_to_user"></a>copy_to_user</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">copy_to_user</span><span class="hljs-params">(<span class="hljs-type">void</span> *to, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *from, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> n)</span></span><br></code></pre></td></tr></table></figure><p>从内核空间中读取数据到用户空间</p><h2 id="copy-from-user"><a href="#copy-from-user" class="headerlink" title="copy_from_user"></a>copy_from_user</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">copy_from_user</span><span class="hljs-params">(<span class="hljs-type">void</span> *to, <span class="hljs-type">const</span> <span class="hljs-type">void</span> *from, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> n)</span></span>;<br></code></pre></td></tr></table></figure><p>从用户空间中读取数据到内核空间</p>]]></content>
    
    
    <categories>
      
      <category>linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>驱动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux系统移植——基于imx6ull</title>
    <link href="/2024/06/28/Linux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Eimx6ull/"/>
    <url>/2024/06/28/Linux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Eimx6ull/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言：U-Boot、Linux kernel 和 rootfs 这三者一起构成了一个完整的 Linux 系 统，一个可以正常使用、功能完善的 Linux 系统。</p></blockquote><h1 id="1-U-Boot"><a href="#1-U-Boot" class="headerlink" title="1 U-Boot"></a>1 U-Boot</h1><h2 id="1-1-U-Boot-简介"><a href="#1-1-U-Boot-简介" class="headerlink" title="1.1 U-Boot 简介"></a>1.1 U-Boot 简介</h2><ul><li><p><strong>U-Boot</strong>就是一种bootloader 软件，类似的还有vivi、RedBoot 等，实际上就是一个<strong>裸机代码</strong>。</p></li><li><p><strong>bootloader</strong> 和 Linux 内核的关系 就跟 PC 上的 <strong>BIOS</strong> 和 Windows 的关系一样，bootloader 就相当于 BIOS</p></li><li><p><strong>主要作用是启动 Linux 内核</strong>，这段bootloader程序会先初始化DDR等外设，然后将Linux内核从flash (NAND，NOR FLASH，SD，MMC 等) 拷贝到 DDR 中，最后启动 Linux 内核。</p></li><li><p>当我们拿到开发板以后，是有三种 uboot ，这三种U-Boot的区别：</p><p><img src="/./../../../Users/Desktopfile/%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/blog/Linux%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Eimx6ull/image-20231110150409690.png" alt="image-20231110150427174"></p></li></ul><h2 id="1-2-U-Boot-初次编译"><a href="#1-2-U-Boot-初次编译" class="headerlink" title="1.2 U-Boot 初次编译"></a>1.2 U-Boot 初次编译</h2><ul><li><p>①下载U-Boot源码</p><p>下载地址：</p><p>uboot官方：<a href="http://www.denx.de/wiki/U-Boot/">http://www.denx.de/wiki/U-Boot/</a></p><p>NXP官网：<a href="https://www.nxp.com.cn/">https://www.nxp.com.cn/</a></p><p>imx6ull-aloha开发板对应的uboot源码：uboot-imx-2016.03-2.1.0-g8b546e4.tar.bz2</p></li><li><p>② 安装 ncurses 库，否则编译会报错，安装命令如下：</p></li></ul><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">sudo apt-<span class="hljs-built_in">get</span> install libncurses5-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><ul><li><p>②解压</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -vxjf uboot-imx-<span class="hljs-number">2016</span>.<span class="hljs-number">03</span>-<span class="hljs-number">2</span>.<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-g8b546e4.tar.bz2<br></code></pre></td></tr></table></figure></li><li><p>③编译，可以创建一个shell脚本，来执行多条编译指令，mx6ull_alientek_emmc.sh：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment">#!/bin/bash </span><br>make <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-gnueabihf- distclean <br>make <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-gnueabihf- (加空格) mx6ull_14x14_ddr512_emmc_defconfig <br>make <span class="hljs-attribute">V</span>=1 <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-gnueabihf- -j12 <br></code></pre></td></tr></table></figure><p>ARCH&#x3D;arm，指定架构</p><p>CROSS_COMPILE&#x3D;arm-linux-gnueabihf- ，指定编译器，只需要指明编译器前缀就行了</p><p>第 1 行：是 shell 脚本要求的，必须是“#!&#x2F;bin&#x2F;bash”或者“#!&#x2F;bin&#x2F;sh”。</p><p>第 2 行：make clean，用于清理工程，也就是每次在编译 uboot 之前都清理一下工程</p><p>第 3 行：make mx6ull_14x14_ddr512_emmc_defconfig，用于配置 uboot</p><p>第 4 行：make V&#x3D;1 -j12，编译uboot，其中V&#x3D;1用于设置编译过程的信息输出级别，-j 用于设置主机使用多少线程编译</p></li><li><p>④给予 mx6ull_alientek_emmc.sh 文件可执行权限</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">chmod</span> <span class="hljs-number">777</span> mx6ull_alientek_emmc.sh<br></code></pre></td></tr></table></figure></li><li><p>⑤U-Boot 烧写与启动</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">chmod 777 imxdownload <span class="hljs-string">//</span>给予 imxdownload 可执行权限，一次即可 <br><span class="hljs-string">./imxdownload</span> u-boot.bin <span class="hljs-string">/dev/sdd</span> <span class="hljs-string">//</span>烧写到 SD 卡，不能烧写到<span class="hljs-string">/dev/sda</span> 或 sda1 设备里面！<br></code></pre></td></tr></table></figure></li></ul><h2 id="1-3-U-Boot常用命令"><a href="#1-3-U-Boot常用命令" class="headerlink" title="1.3 U-Boot常用命令"></a>1.3 U-Boot常用命令</h2><h4 id="1-帮助命令"><a href="#1-帮助命令" class="headerlink" title="1 帮助命令"></a>1 帮助命令</h4><p>? bootz  或 help bootz</p><h4 id="2-信息查询命令"><a href="#2-信息查询命令" class="headerlink" title="2 信息查询命令"></a>2 信息查询命令</h4><ul><li><p>bdinfo      查看板子信息  如DRAM 的起始地址和大小、启动参数保存起始地址、sp(堆栈指针)起始地址等信息  </p></li><li><p>printenv  查看环境变量  如board_name，<strong>bootargs，bootcmd</strong>，<strong>fdt_file，bootdelay</strong>，都是可以设置的  </p></li><li><p>version    查看版本号  如版本，编译时间，编译工具链</p></li></ul><h4 id="3-环境变量操作命令"><a href="#3-环境变量操作命令" class="headerlink" title="3 环境变量操作命令"></a>3 环境变量操作命令</h4><ul><li>setenv    修改环境变量，设置的变量中间有空格的需要用单引号‘ ’<ul><li>setenv bootdelay 5</li><li>setenv bootargs ‘console&#x3D;ttymxc0,115200  root&#x3D;&#x2F;dev&#x2F;mmcblk1p2  rootwait  rw’</li></ul></li><li>saveenv     保存修改的环境变量</li></ul><h4 id="4-内存操作命令"><a href="#4-内存操作命令" class="headerlink" title="4 内存操作命令"></a>4 内存操作命令</h4><ul><li>md用于显示内存值<ul><li>md.b  80000000  14      读取0x80000000起始的0x14个字节，<strong>数字都是16进制的</strong></li></ul></li><li>cp      数据拷贝<ul><li>cp.b 80000000 80000100 10    将 0x80000000 处的地址拷贝到 0X80000100 处，长度为 0x10 字节</li></ul></li></ul><h4 id="5-网络操作命令"><a href="#5-网络操作命令" class="headerlink" title="5 网络操作命令"></a>5 网络操作命令</h4><ul><li><p>ipaddr   开发板 ip 地址，可以不设置，使用 dhcp 命令来从路由器获取 IP 地址。  </p></li><li><p>ethaddr    开发板的 MAC 地址，一定要设置。  </p></li><li><p>gatewayip  网关地址。  </p></li><li><p>netmask  子网掩码。  </p></li><li><p>serverip  服务器 IP 地址，也就是 Ubuntu 主机 IP 地址，用于调试代码。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">setenv ipaddr <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.106</span><br>setenv ethaddr b8:ae:<span class="hljs-number">1</span>d:<span class="hljs-number">01</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span><br>setenv gatewayip <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span> <br>setenv netmask <span class="hljs-number">255.255</span><span class="hljs-number">.255</span><span class="hljs-number">.0</span> <br>setenv serverip <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.104</span>  <br></code></pre></td></tr></table></figure></li><li><p>ping      </p></li><li><p>dhcp      </p></li><li><p>nfs  网络文件系统，用于开发板与计算机之间传输  </p><ul><li>nfs 80800000 192.168.0.104:&#x2F;home&#x2F;lk&#x2F;linux&#x2F;nfs&#x2F;zImage</li></ul></li><li><p>tftp  同nfs一样  </p><ul><li>tftp 80800000 zImage</li></ul></li></ul><h4 id="6-EMMC与SD卡操作命令"><a href="#6-EMMC与SD卡操作命令" class="headerlink" title="6 EMMC与SD卡操作命令"></a>6 EMMC与SD卡操作命令</h4><ul><li><p>mmc rescan  ①扫描 MMC 设备</p></li><li><p>mmc list         ②列出当前有效的所有 MMC 设备</p></li><li><p>mmc info       ③输出 MMC 设备信息</p></li><li><p>mmc part       ④列出 MMC 设备的分区</p><ul><li>mmc dev 1 0      EMMC 的分区 0,<strong>存放 uboot</strong></li><li>mmc dev 1 1      EMMC 的分区 1,<strong>存放 zImage</strong></li><li>mmc dev 1 2      EMMC 的分区 2,<strong>存放 设备树</strong></li></ul></li><li><p>mmc dev        ⑤切换 MMC 设备</p><ul><li>mmc dev 0         SD卡设备</li><li>mmc dev 1         MMC设备</li></ul></li><li><p>mmc read  读取 MMC 中的数据  </p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mmc</span> dev <span class="hljs-number">1</span> <span class="hljs-number">0</span>                //切换到 MMC 分区 <span class="hljs-number">0</span>  <br><span class="hljs-attribute">mmc</span> read  <span class="hljs-number">80800000</span> <span class="hljs-number">600</span> <span class="hljs-number">10</span>  //从EMMC的第<span class="hljs-number">0</span>x600个块开始，读取<span class="hljs-number">0</span>x10个块的数据到DRAM的<span class="hljs-number">0</span>X80800000地址处（一块<span class="hljs-number">512</span>字节）<br><span class="hljs-attribute">md</span>.b <span class="hljs-number">80800000</span> <span class="hljs-number">2000</span>   //读出来<br></code></pre></td></tr></table></figure></li><li><p>mmc wirte  向 MMC 设备写入数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">mmc</span> dev <span class="hljs-number">1</span> <span class="hljs-number">0</span>  //切换到 EMMC 分区 <span class="hljs-number">0</span> <br><span class="hljs-attribute">tftp</span> <span class="hljs-number">80800000</span> u-boot.imx //下载 u-boot.imx 到 DRAM <br><span class="hljs-attribute">mmc</span> write <span class="hljs-number">80800000</span> <span class="hljs-number">2</span> <span class="hljs-number">32</span>E //烧写 u-boot.imx 到 EMMC 中 向EMMC分区<span class="hljs-number">0</span>第<span class="hljs-number">2</span>个块(扇区)开始烧写，一共烧写<span class="hljs-number">0</span>x32E个块<br><span class="hljs-attribute">mmc</span> partconf <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span>  //分区配置，EMMC 需要这一步！<br></code></pre></td></tr></table></figure></li></ul><h4 id="7-FAT-格式文件系统操作命令"><a href="#7-FAT-格式文件系统操作命令" class="headerlink" title="7 FAT 格式文件系统操作命令"></a>7 FAT <strong>格式文件系统操作命令</strong></h4><ul><li>fatinfo查询指定 MMC 设备分区的文件系统信息<ul><li>fatinfo mmc 1:1</li></ul></li><li>fatls        查询 FAT 格式设备的目录和文件信息<ul><li>fatls mmc 1:1</li></ul></li><li>fstype    查看 MMC 设备某个分区的文件系统格式<ul><li>fstype mmc 1:1</li></ul></li><li>fatload    用于将指定的文件读取到 DRAM 中<ul><li>fatload mmc 1:1 80800000 zImage    将 EMMC 分区 1 中的 zImage 文件读取到 DRAM 中的0X80800000 地址处</li></ul></li><li>fatwirte  用于将 DRAM 中的数据写入到 MMC 设备中，需要<strong>配置开发板对应的配置头文件</strong>，才能使用过<ul><li>fatwrite mmc 1:1 80800000 zImage 6788f8 将0x80800000处的文件zImage写入到 EMMC 的 分区 1 中，写入(0X6788f8)个字节</li></ul></li></ul><h4 id="8-EXT-格式文件系统操作命令"><a href="#8-EXT-格式文件系统操作命令" class="headerlink" title="8 EXT 格式文件系统操作命令"></a>8 EXT 格式文件系统操作命令</h4><p>uboot 有 ext2 和 ext4 这两种格式的文件系统的操作命令，常用的就四个命令，分别为：ext2load、ext2ls、ext4load、ext4ls 和 ext4write。</p><ul><li>ext4ls mmc 1:2   EMMC 的分区 2 中的文件和目录</li></ul><h4 id="9-BOOT-操作命令"><a href="#9-BOOT-操作命令" class="headerlink" title="9 BOOT 操作命令"></a>9 BOOT 操作命令</h4><p>uboot 的本质工作是引导 Linux，所以 uboot 肯定有相关的 boot(引导)命令来启动 Linux。常 用的跟 boot 有关的命令有：bootz、bootm 和 boot。</p><ul><li><p>bootz    用于启动 zImage 镜像文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">tftp 80800000 zImage <br>tftp 83000000 imx6ull-14x14-emmc-7-1024x600-c.dtb <br>bootz 80800000 - 83000000<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">fatload</span> mmc <span class="hljs-number">1</span>:<span class="hljs-number">1</span> <span class="hljs-number">80800000</span> zImage <br><span class="hljs-attribute">fatload</span> mmc <span class="hljs-number">1</span>:<span class="hljs-number">1</span> <span class="hljs-number">83000000</span> imx6ull-<span class="hljs-number">14</span>x14-emmc-<span class="hljs-number">7</span>-<span class="hljs-number">1024</span>x600-c.dtb <br><span class="hljs-attribute">bootz</span> <span class="hljs-number">80800000</span> - <span class="hljs-number">83000000</span> <br></code></pre></td></tr></table></figure></li><li><p>bootm   用于启动 uImage 镜像文件</p></li><li><p>boot      用来启动 Linux 系统的，只是 boot 会读取环境变量 bootcmd 来启动 Linux 系统</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setenv</span> bootcmd &#x27;tftp <span class="hljs-number">80800000</span> zImage; tftp <span class="hljs-number">83000000</span> imx6ull-<span class="hljs-number">14</span>x14-emmc-<span class="hljs-number">7</span>-<span class="hljs-number">1024</span>x600-c.dtb; bootz <span class="hljs-number">80800000</span> - <span class="hljs-number">83000000</span>&#x27; <br><span class="hljs-attribute">saveenv</span> <br><span class="hljs-attribute">boot</span> <br></code></pre></td></tr></table></figure></li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setenv</span> bootcmd &#x27;fatload mmc <span class="hljs-number">1</span>:<span class="hljs-number">1</span> <span class="hljs-number">80800000</span> zImage; fatload mmc <span class="hljs-number">1</span>:<span class="hljs-number">1</span> <span class="hljs-number">83000000</span> imx6ull-<span class="hljs-number">14</span>x14-emmc-<span class="hljs-number">7</span>-<span class="hljs-number">1024</span>x600-c.dtb; bootz <span class="hljs-number">80800000</span> - <span class="hljs-number">83000000</span>&#x27; <br><span class="hljs-attribute">savenev</span> <br><span class="hljs-attribute">boot</span> <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux驱动入门笔记</title>
    <link href="/2024/06/28/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/06/28/Linux%E9%A9%B1%E5%8A%A8%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-单片机和Linux程序从上层到底层的比较"><a href="#1-单片机和Linux程序从上层到底层的比较" class="headerlink" title="1 单片机和Linux程序从上层到底层的比较"></a>1 单片机和Linux程序从上层到底层的比较</h1><h2 id="1-程序比较"><a href="#1-程序比较" class="headerlink" title="1 程序比较"></a>1 程序比较</h2><ul><li><p>单片机程序</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-built_in">int</span> <span class="hljs-title">main</span>()</span><br>&#123;<br>HAL库 / 寄存器操作<span class="hljs-comment">//直接操作硬件</span><br>R/W寄存器  <span class="hljs-comment">//可以直接读写寄存器</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>Linux程序</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino">应用程序：<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>无法直接R/W寄存器  <span class="hljs-comment">//不可以直接读写寄存器，因为有MMU，禁止直接访问内存</span><br>调用驱动程序 open/read/write...<br>&#125;<br><br>驱动程序：<br>open/read/write...<br>硬件操作<br>R/W寄存器  <span class="hljs-comment">//可以直接读写寄存器</span><br></code></pre></td></tr></table></figure></li></ul><p><img src="/./../photo/image-20231121150452014.png" alt="image-20231121150452014"></p><h2 id="2-调用过程"><a href="#2-调用过程" class="headerlink" title="2 调用过程"></a>2 调用过程</h2><ul><li>①应用程序<strong>调用open函数</strong></li><li>②open的实质是<strong>设置寄存器</strong>，<strong>执行一条汇编指令</strong>：swi #0，<strong>触发异常</strong>，还会在寄存器中保存一个值，如R0&#x3D;open</li><li>③cpu就会去执行swi异常处理函数，于是就从<strong>用户态陷入内核态</strong></li><li>④根据寄存器R0分辨调用的是什么函数，然后<strong>调用sys_open函数</strong>，判断文件名，通过主设备号找到驱动</li><li>⑤最后找到<strong>drv_open函数</strong></li></ul><p><img src="/./../photo/image-20231121160513624.png" alt="image-20231121160513624"></p><h2 id="3-打开设备节点"><a href="#3-打开设备节点" class="headerlink" title="3 打开设备节点"></a>3 打开设备节点</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> dev<br><span class="hljs-built_in">ls</span> -l<br></code></pre></td></tr></table></figure><p><img src="/./../photo/image-20231121154233396.png" alt="image-20231121154233396"></p><h2 id="4-查看支持的设备"><a href="#4-查看支持的设备" class="headerlink" title="4 查看支持的设备"></a>4 查看支持的设备</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cat</span> /proc/devices<br></code></pre></td></tr></table></figure><h2 id="5-如何写驱动"><a href="#5-如何写驱动" class="headerlink" title="5 如何写驱动"></a>5 如何写驱动</h2><ul><li>确定主设备号</li><li>构造结构体file_operations，实现其中的函数</li><li>注册结构体，放入到chrdev[]数组中</li><li>入口</li></ul><p><img src="/./../photo/image-20231121160006224.png" alt="image-20231121160006224"></p><h1 id="2-彻底分析第一个驱动程序"><a href="#2-彻底分析第一个驱动程序" class="headerlink" title="2 彻底分析第一个驱动程序"></a>2 彻底分析第一个驱动程序</h1><h2 id="1-在Ubuntu中速体验驱动开发"><a href="#1-在Ubuntu中速体验驱动开发" class="headerlink" title="1 在Ubuntu中速体验驱动开发"></a>1 在Ubuntu中速体验驱动开发</h2><ul><li><p>下载内核头文件</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs swift">uname <span class="hljs-operator">-</span>r <span class="hljs-comment">// 查看内核版本</span><br>apt<span class="hljs-operator">-</span>cache search linux<span class="hljs-operator">-</span>headers<span class="hljs-operator">-</span>$(uname <span class="hljs-operator">-</span>r)       <span class="hljs-comment">// 确认有没有</span><br>sudo apt<span class="hljs-operator">-</span><span class="hljs-keyword">get</span> install linux<span class="hljs-operator">-</span>headers<span class="hljs-operator">-</span>$(uname <span class="hljs-operator">-</span>r) <span class="hljs-comment">// 下载安装</span><br><span class="hljs-regexp">/lib/</span>modules<span class="hljs-regexp">/5.19.0-41-generic/</span>build <span class="hljs-comment">// ubuntu内核头文件所在目录</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-驱动程序"><a href="#2-驱动程序" class="headerlink" title="2 驱动程序"></a>2 驱动程序</h2><h4 id="V1-最简单的驱动程序"><a href="#V1-最简单的驱动程序" class="headerlink" title="V1 最简单的驱动程序"></a>V1 最简单的驱动程序</h4><p>hello_drv.c：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">init_module</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>  <span class="hljs-comment">//直接使用init_module</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">cleanup_module</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>&#125;<br><br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><br><span class="hljs-comment">//module_init(hello_init);</span><br><span class="hljs-comment">//int init_module(void) __attribute__((alias(hello_init)));</span><br></code></pre></td></tr></table></figure><p>Makefile:</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs makefile">ARCH = x86<br>CROSS_COMPILE =<br><br>KVERSION = <span class="hljs-variable">$(<span class="hljs-built_in">shell</span> uname -r)</span><br>KERN_DIR =  /lib/modules/<span class="hljs-variable">$(KVERSION)</span>/build <br><br><span class="hljs-section">all:</span><br>make -C <span class="hljs-variable">$(KERN_DIR)</span> M=`pwd` modules <br><br><span class="hljs-section">clean:</span><br>make -C <span class="hljs-variable">$(KERN_DIR)</span> M=`pwd` modules clean<br>rm -rf modules.order<br><br>obj-m+= hello_drv.o<br></code></pre></td></tr></table></figure><h4 id="V2-驱动入口、出口详解"><a href="#V2-驱动入口、出口详解" class="headerlink" title="V2 驱动入口、出口详解"></a>V2 驱动入口、出口详解</h4><ul><li>__init 段属性，只用一次，可释放</li><li>__exit 段属性，驱动编进内核里才有意义，无需出口，出口函数无意义，在一般的ko文件中无意义，段属性，但是不会链接进内核</li></ul><p>hello_drv.c：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><br><span class="hljs-comment">//__init 段属性，只用一次，可释放</span><br><span class="hljs-function"><span class="hljs-type">int</span> __init <span class="hljs-title">hello_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;hello drv init\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">//__exit 段属性，但是不会链接进内核</span><br><span class="hljs-comment">//驱动编进内核里才有意义，无需出口，出口函数无意义，在一般的ko文件中无意义</span><br><span class="hljs-function"><span class="hljs-type">void</span> __exit <span class="hljs-title">hello_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;hello drv exit\n&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><br><span class="hljs-built_in">module_init</span>(hello_init);<br><span class="hljs-built_in">module_exit</span>(hello_exit);<br><br><span class="hljs-comment">//int init_module(void) __attribute__((alias(hello_init)));</span><br></code></pre></td></tr></table></figure><p>Makefile:同上</p><h4 id="V3-字符设备调用关系"><a href="#V3-字符设备调用关系" class="headerlink" title="V3 字符设备调用关系"></a>V3 字符设备调用关系</h4><ul><li>驱动不提供open，应用程序调用open也能打开驱动文件</li><li>但是不提供read、write，应用程序调用read、write就会报错</li></ul><p>hello_drv.c：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> major = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> hello_fops = &#123;<br>.owner= THIS_MODULE,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> __init <span class="hljs-title">hello_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;hello drv init\n&quot;</span>);<br>major = <span class="hljs-built_in">register_chrdev</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hello_drv&quot;</span>, &amp;hello_fops);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> __exit <span class="hljs-title">hello_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;hello drv exit\n&quot;</span>);<br><span class="hljs-built_in">unregister_chrdev</span>(major, <span class="hljs-string">&quot;hello_drv&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><span class="hljs-built_in">module_init</span>(hello_init);<br><span class="hljs-built_in">module_exit</span>(hello_exit);<br></code></pre></td></tr></table></figure><p>hello_test.c:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * ./hello_drv_test -w abc</span><br><span class="hljs-comment"> * ./hello_drv_test -r</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> fd;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">1024</span>];<br><span class="hljs-type">int</span> len;<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-comment">/* 1. 判断参数 */</span><br><span class="hljs-keyword">if</span> (argc &lt; <span class="hljs-number">2</span>) <br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: %s -w &lt;string&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;       %s -r\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">/* 2. 打开文件 */</span><br>fd = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;/dev/xyz&quot;</span>, O_RDWR);<br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can not open file /dev/xyz\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open file /dev/xyz ok\n&quot;</span>);<br><br><span class="hljs-comment">/* 3. 写文件或读文件 */</span><br><span class="hljs-keyword">if</span> ((<span class="hljs-number">0</span> == <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;-w&quot;</span>)) &amp;&amp; (argc == <span class="hljs-number">3</span>))<br>&#123;<br>len = <span class="hljs-built_in">strlen</span>(argv[<span class="hljs-number">2</span>]) + <span class="hljs-number">1</span>;<br>len = len &lt; <span class="hljs-number">1024</span> ? len : <span class="hljs-number">1024</span>;<br>ret = <span class="hljs-built_in">write</span>(fd, argv[<span class="hljs-number">2</span>], len);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write driver: %d\n&quot;</span>, ret);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>len = <span class="hljs-built_in">read</span>(fd, buf, <span class="hljs-number">1024</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read driver: %d\n&quot;</span>, len);<br>buf[<span class="hljs-number">1023</span>] = <span class="hljs-string">&#x27;\0&#x27;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;APP read : %s\n&quot;</span>, buf);<br>&#125;<br><br><span class="hljs-built_in">close</span>(fd);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="V4-数据交互"><a href="#V4-数据交互" class="headerlink" title="V4 数据交互"></a>V4 数据交互</h4><ul><li>copy_to_user</li><li>copy_from_user</li></ul><p>hello_drv.c</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-comment">//#include &lt;asm/uaccess.h&gt;</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> major = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> ker_val = <span class="hljs-number">123</span>;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">hello_read</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">loff_t</span> *offset)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> err;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><span class="hljs-built_in">copy_to_user</span>(buf, &amp;ker_val, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">hello_write</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">loff_t</span> *offset)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> err;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><span class="hljs-built_in">copy_from_user</span>(&amp;ker_val, buf, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;<br><br><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> hello_fops = &#123;<br>.owner= THIS_MODULE,<br>.read       = hello_read,<br>.write      = hello_write,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> __init <span class="hljs-title">hello_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;hello drv init\n&quot;</span>);<br>major = <span class="hljs-built_in">register_chrdev</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hello_drv&quot;</span>, &amp;hello_fops);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> __exit <span class="hljs-title">hello_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;hello drv exit\n&quot;</span>);<br><span class="hljs-built_in">unregister_chrdev</span>(major, <span class="hljs-string">&quot;hello_drv&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><br><br><span class="hljs-built_in">module_init</span>(hello_init);<br><span class="hljs-built_in">module_exit</span>(hello_exit);<br></code></pre></td></tr></table></figure><h1 id="3-驱动程序辅助信息及地址空间概念"><a href="#3-驱动程序辅助信息及地址空间概念" class="headerlink" title="3 驱动程序辅助信息及地址空间概念"></a>3 驱动程序辅助信息及地址空间概念</h1><h2 id="1-思考"><a href="#1-思考" class="headerlink" title="1 思考"></a>1 思考</h2><p>GIT仓库中有如下程序：</p><p>adress.c源码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><br><span class="hljs-type">int</span> a;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span><br>&#123;<br><span class="hljs-keyword">if</span> (argc != <span class="hljs-number">2</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Usage: %s &lt;val&gt;\n&quot;</span>, argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br>a = strtol(argv[<span class="hljs-number">1</span>], <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a = %d\n&quot;</span>, a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;a&#x27;s address = 0x%lx\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)&amp;a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;main&#x27;s address = 0x%lx\n&quot;</span>, (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span>)main);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>sleep(<span class="hljs-number">100</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>把它放到Ubuntu后，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">make<br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./address 124&amp;</span><br>a = 124<br>a&#x27;s address = 0x6bc3a0<br>main&#x27;s address = 0x400b5d<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">./address 123&amp;</span><br>a = 123<br>a&#x27;s address = 0x6bc3a0<br>main&#x27;s address = 0x400b5d<br></code></pre></td></tr></table></figure><p>观察到：现在内存里有2个address程序，它们的变量a地址相同、值不同</p><p>问：为什么同一个地址的内存里，同一时间点，竟然值不一样？</p><h2 id="2-地址空间"><a href="#2-地址空间" class="headerlink" title="2. 地址空间"></a>2. 地址空间</h2><h3 id="1-CPU怎么访问多个外设"><a href="#1-CPU怎么访问多个外设" class="headerlink" title="1 CPU怎么访问多个外设"></a>1 CPU怎么访问多个外设</h3><h4 id="MCU"><a href="#MCU" class="headerlink" title="MCU"></a>MCU</h4><p><img src="/./../photo/image-20231121185750327.png" alt="image-20231121185750327"></p><h4 id="MPU"><a href="#MPU" class="headerlink" title="MPU"></a>MPU</h4><p><img src="/./../photo/image-20231121190133851.png" alt="image-20231121190133851"></p><h3 id="2-为什么要引入虚拟地址"><a href="#2-为什么要引入虚拟地址" class="headerlink" title="2 为什么要引入虚拟地址"></a>2 为什么要引入虚拟地址</h3><ul><li>如果main函数调用 f 函数，就需要用到 f1 的地址（虚拟地址）</li><li>链接时，要确定 f1 的地址（虚拟地址）</li><li>运行时，f1 所在内存的地址可能不一样（物理地址）</li></ul><p>当引入虚拟地址后：</p><ul><li>加载程序（物理地址）</li><li>映射，链接地址（虚拟地址）</li><li>运行，跳到虚拟地址去运行</li></ul><h3 id="3-虚拟地址怎么对应到物理地址"><a href="#3-虚拟地址怎么对应到物理地址" class="headerlink" title="3 虚拟地址怎么对应到物理地址"></a>3 虚拟地址怎么对应到物理地址</h3><p>virAdress &#x3D; ioremap（phyAdress，4）</p><h3 id="4-Linux驱动中怎么访问硬件寄存器"><a href="#4-Linux驱动中怎么访问硬件寄存器" class="headerlink" title="4 Linux驱动中怎么访问硬件寄存器"></a>4 Linux驱动中怎么访问硬件寄存器</h3><h2 id="3-驱动程序辅助信息"><a href="#3-驱动程序辅助信息" class="headerlink" title="3 驱动程序辅助信息"></a>3 驱动程序辅助信息</h2><p>自动创建设备节点的流程：</p><ul><li>内核提供信息<ul><li>class_create</li><li>device_create</li></ul></li><li>APP根据信息创建设备节点</li></ul><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-comment">//#include &lt;asm/uaccess.h&gt;</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> major = <span class="hljs-number">0</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> ker_val = <span class="hljs-number">123</span>;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">class</span> *class_for_hello;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">hello_read</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">loff_t</span> *offset)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> err;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><span class="hljs-built_in">copy_to_user</span>(buf, &amp;ker_val, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">hello_write</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">loff_t</span> *offset)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> err;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><span class="hljs-built_in">copy_from_user</span>(&amp;ker_val, buf, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;<br><br><br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> hello_fops = &#123;<br>.owner= THIS_MODULE,<br>.read       = hello_read,<br>.write      = hello_write,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> __init <span class="hljs-title">hello_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;hello drv init\n&quot;</span>);<br>major = <span class="hljs-built_in">register_chrdev</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hello_drv&quot;</span>, &amp;hello_fops);<br>class_for_hello = <span class="hljs-built_in">class_create</span>(THIS_MODULE, <span class="hljs-string">&quot;hello_class&quot;</span>); <span class="hljs-comment">/* /sys/class/hello_class/ */</span><br><span class="hljs-built_in">device_create</span>(class_for_hello, <span class="hljs-literal">NULL</span>, <span class="hljs-built_in">MKDEV</span>(major, <span class="hljs-number">0</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;myhello&quot;</span>); <span class="hljs-comment">/* /dev/myhello */</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> __exit <span class="hljs-title">hello_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;hello drv exit\n&quot;</span>);<br><span class="hljs-built_in">device_destroy</span>(class_for_hello, <span class="hljs-built_in">MKDEV</span>(major, <span class="hljs-number">0</span>)); <span class="hljs-comment">/* /dev/myhello */</span><br><br><span class="hljs-built_in">class_destroy</span>(class_for_hello);<br><br><span class="hljs-built_in">unregister_chrdev</span>(major, <span class="hljs-string">&quot;hello_drv&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><br><br><span class="hljs-built_in">module_init</span>(hello_init);<br><span class="hljs-built_in">module_exit</span>(hello_exit);<br><br><span class="hljs-comment">//int init_module(void) __attribute__((alias(hello_init)));</span><br></code></pre></td></tr></table></figure><h1 id="4-板子上驱动程序实际操作及编译过程"><a href="#4-板子上驱动程序实际操作及编译过程" class="headerlink" title="4 板子上驱动程序实际操作及编译过程"></a>4 板子上驱动程序实际操作及编译过程</h1><h3 id="1-在内核目录外编译模块"><a href="#1-在内核目录外编译模块" class="headerlink" title="1 在内核目录外编译模块"></a>1 在内核目录外编译模块</h3><p>led_drv.c源码：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mutex.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/wait.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/io.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> major;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">class</span> *led_class;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">led_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf,</span></span><br><span class="hljs-params"><span class="hljs-function"> <span class="hljs-type">size_t</span> count, <span class="hljs-type">loff_t</span> *ppos)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> val;<br><span class="hljs-comment">/* copy_from_user : get data from app */</span><br><span class="hljs-built_in">copy_from_user</span>(&amp;val, buf, <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">/* to set gpio register: out 1/0 */</span><br><span class="hljs-keyword">if</span> (val)<br>&#123;<br><span class="hljs-comment">/* set gpio to let led on */</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><br><span class="hljs-comment">/* set gpio to let led off */</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">led_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* enable gpio</span><br><span class="hljs-comment"> * configure pin as gpio</span><br><span class="hljs-comment"> * configure gpio as output </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> led_fops = &#123;<br>.owner= THIS_MODULE,<br>.write= led_write,<br>.open= led_open,<br>&#125;;<br><br><span class="hljs-comment">/* 入口函数 */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">led_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><br>major = <span class="hljs-built_in">register_chrdev</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;100ask_led&quot;</span>, &amp;led_fops);<br><br><span class="hljs-comment">/* ioremap */</span><br><br>led_class = <span class="hljs-built_in">class_create</span>(THIS_MODULE, <span class="hljs-string">&quot;myled&quot;</span>);<br><span class="hljs-built_in">device_create</span>(led_class, <span class="hljs-literal">NULL</span>, <span class="hljs-built_in">MKDEV</span>(major, <span class="hljs-number">0</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;myled&quot;</span>); <span class="hljs-comment">/* /dev/myled */</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">led_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">device_destroy</span>(led_class, <span class="hljs-built_in">MKDEV</span>(major, <span class="hljs-number">0</span>));<br><span class="hljs-built_in">class_destroy</span>(led_class);<br><br><span class="hljs-built_in">unregister_chrdev</span>(major, <span class="hljs-string">&quot;100ask_led&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">module_init</span>(led_init);<br><span class="hljs-built_in">module_exit</span>(led_exit);<br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br></code></pre></td></tr></table></figure><p>Makefile源码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. 使用不同的开发板内核时, 一定要修改KERN_DIR</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. KERN_DIR中的内核要事先配置、编译, 为了能编译内核, 要先设置下列环境变量:</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.1 ARCH,          比如: <span class="hljs-built_in">export</span> ARCH=arm64</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.2 CROSS_COMPILE, 比如: <span class="hljs-built_in">export</span> CROSS_COMPILE=aarch64-linux-gnu-</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.3 PATH,          比如: <span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$PATH</span>:/home/book/100ask_roc-rk3399-pc/ToolChain-6.3.1/gcc-linaro-6.3.1-2017.05-x86_64_aarch64-linux-gnu/bin</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">注意: 不同的开发板不同的编译器上述3个环境变量不一定相同,</span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">请参考各开发板的高级用户使用手册</span><br><br>KERN_DIR = <br><br>all:<br>make -C $(KERN_DIR) M=`pwd` modules       <br><span class="hljs-meta prompt_">$</span><span class="language-bash">(CROSS_COMPILE)gcc -o ledtest ledtest.c</span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-C 表示changedir，进入到$(KERN_DIR)目录，编译 M 路径中的模块</span><br><br>clean:<br>make -C $(KERN_DIR) M=`pwd` modules clean<br>rm -rf modules.order<br>rm -f ledtest<br><br>obj-m+= led_drv.o<br><span class="hljs-meta prompt_">#</span><span class="language-bash">需要编译的模块</span><br></code></pre></td></tr></table></figure><p>imx6ull开发板环境变量如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">ARCH</span>=arm<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-gnueabihf-<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$PATH</span>:/usr/local/arm/gcc-linaro-4.9.4-2017.01-x86_64_arm-linux-gnueabihf/bin <br></code></pre></td></tr></table></figure><h3 id="2-在内核目录里面编译驱动"><a href="#2-在内核目录里面编译驱动" class="headerlink" title="2 在内核目录里面编译驱动"></a>2 在内核目录里面编译驱动</h3><ul><li><p>将需要编译进内核的驱动源码放入到内核目录</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">cp led_drv.c <span class="hljs-regexp">/home/</span>lk<span class="hljs-regexp">/linux/im</span>x6ull<span class="hljs-regexp">/3.linux_kernel/</span>kernel<span class="hljs-regexp">/alpha_kernel/</span>linux-imx-rel_imx_4.<span class="hljs-number">1.15</span>_2.<span class="hljs-number">1.0</span>_ga<span class="hljs-regexp">/drivers/</span><span class="hljs-keyword">char</span><br></code></pre></td></tr></table></figure></li><li><p>修改内核目录下&#x2F;drivers&#x2F;char&#x2F;Kconfig，添加相应的配置信息</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">config ALPHA_LED<br><span class="hljs-type">bool</span> <span class="hljs-string">&quot;led driver for alpha&quot;</span><br><span class="hljs-keyword">default</span> y<br>help<br>  Just <span class="hljs-keyword">for</span> test led.<br></code></pre></td></tr></table></figure><p>也可以打开menuconfig来配置</p><p>make menuconfig</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">Device Drivers<br>Character devices<br>led driver for alpha<br>m 编译为模块<br>y 编译进内核<br><span class="hljs-built_in">n</span> 不参与编译<br></code></pre></td></tr></table></figure><p>在内核根目录下的.config文件中可以看到 CONFIG_ALPHA_LED &#x3D; y</p></li><li><p>修改内核目录下&#x2F;drivers&#x2F;char&#x2F;Makefile，添加相应的配置信息</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">obj-$(CONFIG_ALPHA_LED)     += gpioled.o<br></code></pre></td></tr></table></figure></li><li><p>编译zImage，烧写到开发板，即可</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">make zImage -j4<br>cp <span class="hljs-regexp">/arch/</span>arm<span class="hljs-regexp">/boot/</span>zImage   <span class="hljs-regexp">/home/</span>lk<span class="hljs-regexp">/linux/</span>tftpboot -rf     <span class="hljs-regexp">//</span>拷贝zImage<br>cp <span class="hljs-regexp">/arch/</span>arm<span class="hljs-regexp">/boot/</span>dts<span class="hljs-regexp">/.dtb /</span>home<span class="hljs-regexp">/lk/</span>linux<span class="hljs-regexp">/tftpboot -rf    /</span>/拷贝dtb<br></code></pre></td></tr></table></figure></li></ul><h1 id="5-分离的设计思想与总线设备驱动模型"><a href="#5-分离的设计思想与总线设备驱动模型" class="headerlink" title="5 分离的设计思想与总线设备驱动模型"></a>5 分离的设计思想与总线设备驱动模型</h1><h2 id="1-分离的设计思想"><a href="#1-分离的设计思想" class="headerlink" title="1 分离的设计思想"></a>1 分离的设计思想</h2><p>一个驱动可以适应很多个设备，就可以把驱动与设备分离开</p><p>驱动程序分成两部分：</p><ul><li>驱动：通用的驱动信息</li><li>设备：硬件信息</li></ul><h2 id="2-总线设备驱动模型"><a href="#2-总线设备驱动模型" class="headerlink" title="2 总线设备驱动模型"></a>2 总线设备驱动模型</h2><ul><li>platform_bus_type  总线platform下面有两个链表<ul><li>driver_list   驱动链表</li><li>device_list  设备链表</li></ul></li></ul><h2 id="3-编写驱动方法"><a href="#3-编写驱动方法" class="headerlink" title="3 编写驱动方法"></a>3 编写驱动方法</h2><p>①构造，注册</p><ul><li>构造platform_driver，注册进驱动链表</li><li>构造platform_device，注册进设备链表</li></ul><p>②匹配，跟对方链表的每个成员一一比较，调用platform总线里面的 .match 函数比较</p><p>③匹配成功，就会执行platform_driver里面的 .probe 函数</p><h1 id="6-总线设备驱动模型彻底分析"><a href="#6-总线设备驱动模型彻底分析" class="headerlink" title="6 总线设备驱动模型彻底分析"></a>6 总线设备驱动模型彻底分析</h1><h2 id="1-匹配方法"><a href="#1-匹配方法" class="headerlink" title="1 匹配方法"></a>1 匹配方法</h2><p><img src="/./../photo/image-20231121211955147.png" alt="image-20231121211955147"></p><h2 id="2-注册过程"><a href="#2-注册过程" class="headerlink" title="2 注册过程"></a>2 注册过程</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">platform_driver_register 注册设备<br>platform_device_add<br>pdev-&gt;dev.<span class="hljs-keyword">bus </span>= &amp;platform_bus_type;<br>ret = device_add(&amp;pdev-&gt;dev);<br>error = <span class="hljs-keyword">bus_add_device(dev);</span><br><span class="hljs-keyword"></span>klist_add_tail 将设备放入总线设备链表<br><span class="hljs-keyword">bus_probe_device </span>枚举设备<br>device_initial_prove<br>__device_attach<br><span class="hljs-keyword">bus_for_each_drv </span>对于总线下面的每一个驱动<br>__device_attch_driver 调用该函数查看是否匹配驱动<br></code></pre></td></tr></table></figure><h2 id="3-私有数据"><a href="#3-私有数据" class="headerlink" title="3 私有数据"></a>3 私有数据</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">platform_set_drvdata</span><span class="hljs-params">()</span></span>   <span class="hljs-comment">//设置与驱动有关的私有数据</span><br></code></pre></td></tr></table></figure><h1 id="7-设备树入门"><a href="#7-设备树入门" class="headerlink" title="7 设备树入门"></a>7 设备树入门</h1><p>设备文件过多，而且也不是内核中的核心文件，会导致内核臃肿，而且修改麻烦</p><p>所以引入一个配置文件，内核可以读取这个配置文件，就相当于读取设备文件，也就设备树</p><h2 id="1-反汇编dtb文件"><a href="#1-反汇编dtb文件" class="headerlink" title="1 反汇编dtb文件"></a>1 反汇编dtb文件</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-variable">dtc</span> <span class="hljs-operator">-</span><span class="hljs-built_in">I</span> <span class="hljs-variable">dtb</span> <span class="hljs-operator">-</span><span class="hljs-built_in">O</span> <span class="hljs-variable">dts</span> <span class="hljs-variable">imx6ull</span><span class="hljs-operator">-</span><span class="hljs-variable">alpha</span><span class="hljs-operator">.</span><span class="hljs-variable">dtb</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">1.</span><span class="hljs-variable">dts</span><br></code></pre></td></tr></table></figure><h2 id="2-设备树节点语法"><a href="#2-设备树节点语法" class="headerlink" title="2 设备树节点语法"></a>2 设备树节点语法</h2><p><img src="/./../photo/image-20231121220113106.png" alt="image-20231121220113106"></p><h2 id="3-创建设备树节点"><a href="#3-创建设备树节点" class="headerlink" title="3 创建设备树节点"></a>3 创建设备树节点</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">myled:</span> <span class="hljs-title class_">myled_test</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">pin</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;gpio5_3&quot;</span><br><span class="hljs-punctuation">&#125;;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">myled_ok:</span> <span class="hljs-title class_">myled_ok_test</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fsl,led&quot;</span><span class="hljs-comment">//有compatible属性的节点才能转换成platform_device</span><br><span class="hljs-attr">pin</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;gpio5_3&quot;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/sys/</span>firmware<span class="hljs-regexp">/devicetree/</span>base <span class="hljs-regexp">//</span>该目录下有设备树节点的信息myled_test、myled_ok_test<br><span class="hljs-regexp">/sys/</span>bus<span class="hljs-regexp">/platform/</span>devices<span class="hljs-regexp">//</span>该目录下有平台设备的信息myled_ok_test<br></code></pre></td></tr></table></figure><h2 id="4-设备树匹配过程"><a href="#4-设备树匹配过程" class="headerlink" title="4 设备树匹配过程"></a>4 设备树匹配过程</h2><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">of_driver_match_device</span>(dev,drv)<br><span class="hljs-built_in">of_match_device</span>(drv-&gt;of_match_table, dev)  <span class="hljs-comment">//驱动里面的of_match_device放有compatible</span><br></code></pre></td></tr></table></figure><h1 id="8-设备树示例"><a href="#8-设备树示例" class="headerlink" title="8 设备树示例"></a>8 设备树示例</h1><h2 id="1-LED和按键的设备树示例"><a href="#1-LED和按键的设备树示例" class="headerlink" title="1 LED和按键的设备树示例"></a>1 LED和按键的设备树示例</h2><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-alpha.dts</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">dtsled</span> &#123;<br>compatible <span class="hljs-operator">=</span> <span class="hljs-string">&quot;gpio-leds&quot;</span>;<span class="hljs-comment">//根据该属性找对应的驱动程序</span><br><br><span class="hljs-keyword">led0</span> &#123;<br>label<span class="hljs-operator">=</span> <span class="hljs-string">&quot;red&quot;</span>;<br>gpios <span class="hljs-operator">=</span> <span class="hljs-operator">&lt;&amp;</span>gpio1 <span class="hljs-number">3</span> GPIO_ACTIVE_LOW<span class="hljs-operator">&gt;</span>;<br>linux,<span class="hljs-keyword">default</span><span class="hljs-operator">-</span>trigger <span class="hljs-operator">=</span> <span class="hljs-string">&quot;heartbeat&quot;</span>;<br><span class="hljs-keyword">default</span><span class="hljs-operator">-</span>state <span class="hljs-operator">=</span> <span class="hljs-string">&quot;on&quot;</span>;<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sqf">gpio-<span class="hljs-built_in">keys</span> &#123;<br>compatible = <span class="hljs-string">&quot;gpio-keys&quot;</span>;<span class="hljs-comment">//根据该属性找对应的驱动程序</span><br><span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br><span class="hljs-meta">#size-cells = &lt;0&gt;;</span><br>autorepeat;<br><br>led0 &#123;<br>label= <span class="hljs-string">&quot;GPIO Key Enter&quot;</span>;<br>linux,code = &lt;KEY_ENTER&gt;;<br>gpios = &lt;&amp;gpio1 <span class="hljs-number">18</span> GPIO_ACTIVE_LOW&gt;;<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="2-I2C设备树示例"><a href="#2-I2C设备树示例" class="headerlink" title="2 I2C设备树示例"></a>2 I2C设备树示例</h2><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arduino">i2c1: i2c@<span class="hljs-number">021</span>a0000 &#123;<br><span class="hljs-meta">#address-cells = <span class="hljs-string">&lt;1&gt;</span>;</span><br><span class="hljs-meta">#size-cells = <span class="hljs-string">&lt;0&gt;</span>;</span><br>compatible = <span class="hljs-string">&quot;fsl,imx6ul-i2c&quot;</span>, <span class="hljs-string">&quot;fsl,imx21-i2c&quot;</span>;<span class="hljs-comment">//I2C相关驱动</span><br>reg = &lt;<span class="hljs-number">0x021a0000</span> <span class="hljs-number">0x4000</span>&gt;;<span class="hljs-comment">//寄存器基地址+长度</span><br>interrupts = &lt;GIC_SPI <span class="hljs-number">36</span> IRQ_TYPE_LEVEL_HIGH&gt;;<span class="hljs-comment">//中断</span><br>clocks = &lt;&amp;clks IMX6UL_CLK_I2C1&gt;;<span class="hljs-comment">//时钟</span><br>status = <span class="hljs-string">&quot;disabled&quot;</span>;<span class="hljs-comment">//状态</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-alpha.dts</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs llvm">&amp;i<span class="hljs-number">2</span><span class="hljs-keyword">c</span><span class="hljs-number">1</span> &#123;<br>clock-frequency <span class="hljs-operator">=</span> &lt;<span class="hljs-number">100000</span>&gt;<span class="hljs-comment">;//频率</span><br>pinctrl-names <span class="hljs-operator">=</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-comment">;</span><br>pinctrl<span class="hljs-number">-0</span> <span class="hljs-operator">=</span> &lt;&amp;pinctrl_i<span class="hljs-number">2</span><span class="hljs-keyword">c</span><span class="hljs-number">1</span>&gt;<span class="hljs-comment">;//引脚信息</span><br>status <span class="hljs-operator">=</span> <span class="hljs-string">&quot;okay&quot;</span><span class="hljs-comment">;//状态</span><br><br>ap<span class="hljs-number">3216</span><span class="hljs-keyword">c</span><span class="hljs-title">@1</span>e &#123; //在I<span class="hljs-number">2</span>C<span class="hljs-number">1</span>下面的具体设备，I<span class="hljs-number">2</span>C<span class="hljs-number">1</span>的子节点<br>compatible <span class="hljs-operator">=</span> <span class="hljs-string">&quot;alpha,ap3216c&quot;</span><span class="hljs-comment">; //具体设备的驱动</span><br>reg <span class="hljs-operator">=</span> &lt;<span class="hljs-number">0x1e</span>&gt;<span class="hljs-comment">; //设备地址</span><br>&#125;<span class="hljs-comment">;</span><br><span class="hljs-comment"></span><br>oled<span class="hljs-title">@3</span><span class="hljs-keyword">c</span> &#123; <br>compatible <span class="hljs-operator">=</span> <span class="hljs-string">&quot;alpha,oled&quot;</span><span class="hljs-comment">; </span><br>reg <span class="hljs-operator">=</span> &lt;<span class="hljs-number">0x3c</span>&gt;<span class="hljs-comment">; </span><br>&#125;<span class="hljs-comment">;</span><br><span class="hljs-comment"></span><span class="hljs-symbol"></span><br><span class="hljs-symbol">codec:</span> wm<span class="hljs-number">8960</span><span class="hljs-title">@1</span>a &#123; <br>compatible <span class="hljs-operator">=</span> <span class="hljs-string">&quot;wlf,wm8960&quot;</span><span class="hljs-comment">; </span><br>reg <span class="hljs-operator">=</span> &lt;<span class="hljs-number">0x1a</span>&gt;<span class="hljs-comment">; </span><br>clocks <span class="hljs-operator">=</span> &lt;&amp;clks IMX<span class="hljs-number">6</span>UL_CLK_SAI<span class="hljs-number">2</span>&gt;<span class="hljs-comment">; </span><br>clock-names <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mclk&quot;</span><span class="hljs-comment">; </span><br>wlf<span class="hljs-punctuation">,</span>shared-lrclk<span class="hljs-comment">; </span><br>&#125;<span class="hljs-comment">;</span><br>&#125;<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h2 id="3-SPI设备树示例"><a href="#3-SPI设备树示例" class="headerlink" title="3 SPI设备树示例"></a>3 SPI设备树示例</h2><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">ecspi3: ecspi<span class="hljs-meta">@02010000</span> &#123;<br><span class="hljs-comment">#address-cells = &lt;1&gt;;</span><br><span class="hljs-comment">#size-cells = &lt;0&gt;;</span><br>compatible = <span class="hljs-string">&quot;fsl,imx6ul-ecspi&quot;</span>, <span class="hljs-string">&quot;fsl,imx51-ecspi&quot;</span>;<br>reg = <span class="hljs-variable">&lt;0x02010000 0x4000&gt;</span>;<br>interrupts = <span class="hljs-variable">&lt;GIC_SPI 33 IRQ_TYPE_LEVEL_HIGH&gt;</span>;<br>clocks = <span class="hljs-variable">&lt;&amp;clks IMX6UL_CLK_ECSPI3&gt;</span>,<br> <span class="hljs-variable">&lt;&amp;clks IMX6UL_CLK_ECSPI3&gt;</span>;<br>clock-names = <span class="hljs-string">&quot;ipg&quot;</span>, <span class="hljs-string">&quot;per&quot;</span>;<br>dmas = <span class="hljs-variable">&lt;&amp;sdma 7 7 1&gt;</span>, <span class="hljs-variable">&lt;&amp;sdma 8 7 2&gt;</span>;<br>dma-names = <span class="hljs-string">&quot;rx&quot;</span>, <span class="hljs-string">&quot;tx&quot;</span>;<br>status = <span class="hljs-string">&quot;disabled&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-alpha.dts</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-variable">&amp;ecspi3</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">fsl,spi-num-chipselects</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">1</span>&gt;</span><span class="hljs-punctuation">;</span>           <span class="hljs-comment">//设置当前片选数量为 1</span><br><span class="hljs-attr">cs-gpios</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;gpio1</span> <span class="hljs-number">20</span> GPIO_ACTIVE_LOW&gt;</span><span class="hljs-punctuation">;</span>  <span class="hljs-comment">//描述片选引脚</span><br><span class="hljs-attr">pinctrl-names</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">;</span><br>pinctrl<span class="hljs-number">-0</span> = <span class="hljs-params">&lt;<span class="hljs-variable">&amp;pinctrl_ecspi3</span>&gt;</span><span class="hljs-punctuation">;</span>           <span class="hljs-comment">//设置 IO 要使用的 pinctrl 子节点</span><br><span class="hljs-attr">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;okay&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">spidev:</span> <span class="hljs-title class_">icm20608@0</span> <span class="hljs-punctuation">&#123;</span> <br><span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;alientek,icm20608&quot;</span><span class="hljs-punctuation">;</span> <br><span class="hljs-attr">spi-max-frequency</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">8000000</span>&gt;</span><span class="hljs-punctuation">;</span>      <span class="hljs-comment">//设置 SPI 最大时钟频率为 8MHz</span><br><span class="hljs-attr">reg</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-number">0</span>&gt;</span><span class="hljs-punctuation">;</span>                          <span class="hljs-comment">//icm20608 连接在 ECSPI3 的第 0 个通道上</span><br><span class="hljs-punctuation">&#125;;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><h2 id="4-LCD设备树示例"><a href="#4-LCD设备树示例" class="headerlink" title="4 LCD设备树示例"></a>4 LCD设备树示例</h2><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">lcdif: lcdif<span class="hljs-meta">@021c8000</span> &#123;<br>compatible = <span class="hljs-string">&quot;fsl,imx6ul-lcdif&quot;</span>, <span class="hljs-string">&quot;fsl,imx28-lcdif&quot;</span>;<br>reg = <span class="hljs-variable">&lt;0x021c8000 0x4000&gt;</span>;<br>interrupts = <span class="hljs-variable">&lt;GIC_SPI 5 IRQ_TYPE_LEVEL_HIGH&gt;</span>;<br>clocks = <span class="hljs-variable">&lt;&amp;clks IMX6UL_CLK_LCDIF_PIX&gt;</span>,<br> <span class="hljs-variable">&lt;&amp;clks IMX6UL_CLK_LCDIF_APB&gt;</span>,<br> <span class="hljs-variable">&lt;&amp;clks IMX6UL_CLK_DUMMY&gt;</span>;<br>clock-names = <span class="hljs-string">&quot;pix&quot;</span>, <span class="hljs-string">&quot;axi&quot;</span>, <span class="hljs-string">&quot;disp_axi&quot;</span>;<br>status = <span class="hljs-string">&quot;disabled&quot;</span>;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-alpha.dts</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">&amp;lcdif &#123;<br>pinctrl-names = <span class="hljs-string">&quot;default&quot;</span>;<br>pinctrl-0 = <span class="hljs-variable">&lt;&amp;pinctrl_lcdif_dat</span><br><span class="hljs-variable">     &amp;pinctrl_lcdif_ctrl&gt;</span>;<br>display = <span class="hljs-variable">&lt;&amp;display0&gt;</span>;<br>status = <span class="hljs-string">&quot;okay&quot;</span>;<br><br>display0: display &#123;<br>bits-per-pixel = <span class="hljs-variable">&lt;24&gt;</span>;<br>bus-width = <span class="hljs-variable">&lt;24&gt;</span>;<br><br>display-timings &#123;<br>native-mode = <span class="hljs-variable">&lt;&amp;timing0&gt;</span>;<br>timing0: timing0 &#123;<br>clock-frequency = <span class="hljs-variable">&lt;34200000&gt;</span>;   /<span class="hljs-symbol">*</span> LCD 像素时钟，单位 Hz <span class="hljs-symbol">*</span>/ <br>hactive = <span class="hljs-variable">&lt;800&gt;</span>;                /<span class="hljs-symbol">*</span> LCD X 轴像素个数 <span class="hljs-symbol">*</span>/<br>vactive = <span class="hljs-variable">&lt;480&gt;</span>;                /<span class="hljs-symbol">*</span> LCD Y 轴像素个数 <span class="hljs-symbol">*</span>/<br>hfront-porch = <span class="hljs-variable">&lt;210&gt;</span>; /<span class="hljs-symbol">*</span> LCD hfp 参数 <span class="hljs-symbol">*</span>/<br>hback-porch = <span class="hljs-variable">&lt;46&gt;</span>;/<span class="hljs-symbol">*</span> LCD hbp 参数 <span class="hljs-symbol">*</span>/<br>hsync-len = <span class="hljs-variable">&lt;1&gt;</span>;/<span class="hljs-symbol">*</span> LCD hspw 参数 <span class="hljs-symbol">*</span>/ <br>vback-porch = <span class="hljs-variable">&lt;23&gt;</span>;/<span class="hljs-symbol">*</span> LCD vbp 参数 <span class="hljs-symbol">*</span>/<br>vfront-porch = <span class="hljs-variable">&lt;22&gt;</span>;/<span class="hljs-symbol">*</span> LCD vfp 参数 <span class="hljs-symbol">*</span>/<br>vsync-len = <span class="hljs-variable">&lt;1&gt;</span>;/<span class="hljs-symbol">*</span> LCD vspw 参数 <span class="hljs-symbol">*</span>/<br><br>hsync-active = <span class="hljs-variable">&lt;0&gt;</span>;<br>vsync-active = <span class="hljs-variable">&lt;0&gt;</span>;<br>de-active = <span class="hljs-variable">&lt;1&gt;</span>;<br>pixelclk-active = <span class="hljs-variable">&lt;0&gt;</span>;<br>&#125;;<br>&#125;;<br>&#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="5-设备树编写方法"><a href="#5-设备树编写方法" class="headerlink" title="5 设备树编写方法"></a>5 设备树编写方法</h2><ul><li>使用芯片厂家提供的工具 </li><li>看绑定文档</li><li>参考同类型单板的设备树文件 </li><li>网上搜索</li><li>实在没办法时, 只能去研究驱动源码</li></ul><h1 id="9-Pinctrl和GPIO"><a href="#9-Pinctrl和GPIO" class="headerlink" title="9 Pinctrl和GPIO"></a>9 Pinctrl和GPIO</h1><h2 id="1-Pinctrl"><a href="#1-Pinctrl" class="headerlink" title="1 Pinctrl"></a>1 Pinctrl</h2><ul><li><p>imx6ull为例</p><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-alpha.dts</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">gpioled</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br><span class="hljs-meta">#size-cells = &lt;1&gt;;</span><br><span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;alpha-gpioled&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-attr">pinctrl-names</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">;</span><br><br>pinctrl<span class="hljs-number">-0</span> = <span class="hljs-params">&lt;<span class="hljs-variable">&amp;pinctrl_led</span>&gt;</span><span class="hljs-punctuation">;</span><span class="hljs-comment">//Pinctrl</span><br><br><span class="hljs-attr">led-gpio</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;gpio1</span> <span class="hljs-number">3</span> GPIO_ACTIVE_LOW&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-attr">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;okay&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">pinctrl_led:</span> <span class="hljs-title class_">ledgrp</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">fsl,pins</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;</span><br><span class="hljs-params">MX6UL_PAD_GPIO1_IO03__GPIO1_IO03  <span class="hljs-number">0x10B0</span>          /*config 是具体设置值*/</span><br><span class="hljs-params">&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br><br><span class="hljs-string">&quot;imx6ull-pinfunc.h&quot;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MX6UL_PAD_GPIO1_IO03__GPIO1_IO03                          0x0068 0x02F4 0x0000 0x5 0x0</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-GPIO"><a href="#2-GPIO" class="headerlink" title="2 GPIO"></a>2 GPIO</h2><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull-alpha.dts</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">gpioled</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-meta">#address-cells = &lt;1&gt;;</span><br><span class="hljs-meta">#size-cells = &lt;1&gt;;</span><br><span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;alpha-gpioled&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-attr">pinctrl-names</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;default&quot;</span><span class="hljs-punctuation">;</span><br>pinctrl<span class="hljs-number">-0</span> = <span class="hljs-params">&lt;<span class="hljs-variable">&amp;pinctrl_led</span>&gt;</span><span class="hljs-punctuation">;</span><br><br><span class="hljs-attr">led-gpio</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;gpio1</span> <span class="hljs-number">3</span> GPIO_ACTIVE_LOW&gt;</span><span class="hljs-punctuation">;</span><span class="hljs-comment">//GPIO</span><br><br><span class="hljs-attr">status</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;okay&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arduino">gpio1: gpio@<span class="hljs-number">0209</span>c000 &#123;<br>compatible = <span class="hljs-string">&quot;fsl,imx6ul-gpio&quot;</span>, <span class="hljs-string">&quot;fsl,imx35-gpio&quot;</span>;<br>reg = &lt;<span class="hljs-number">0x0209c000</span> <span class="hljs-number">0x4000</span>&gt;;<br>interrupts = &lt;GIC_SPI <span class="hljs-number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;,<br>     &lt;GIC_SPI <span class="hljs-number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;<br>gpio-controller;<br><span class="hljs-meta">#gpio-cells = <span class="hljs-string">&lt;2&gt;</span>;     <span class="hljs-comment">//用2个cell描述gpio引脚</span></span><br>interrupt-controller;<br><span class="hljs-meta">#interrupt-cells = <span class="hljs-string">&lt;2&gt;</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h1 id="10-应用程序和驱动程序的更多交互方式"><a href="#10-应用程序和驱动程序的更多交互方式" class="headerlink" title="10 应用程序和驱动程序的更多交互方式"></a>10 应用程序和驱动程序的更多交互方式</h1><h2 id="1-APP读取按键值的四种方式"><a href="#1-APP读取按键值的四种方式" class="headerlink" title="1 APP读取按键值的四种方式"></a>1 APP读取按键值的四种方式</h2><ul><li><strong>查询方式</strong></li><li><strong>休眠-唤醒方式</strong></li><li>poll <strong>方式</strong> </li><li><strong>异步通知方式</strong></li></ul><h2 id="2-中断系统的设备树分析"><a href="#2-中断系统的设备树分析" class="headerlink" title="2 中断系统的设备树分析"></a>2 中断系统的设备树分析</h2><blockquote><p>中断流程：在ARM架构里面详细分析过中断的流程</p></blockquote><p>linux源码根目录&#x2F;arch&#x2F;arm&#x2F;boot&#x2F;dts&#x2F;imx6ull.dtsi</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>c: <span class="hljs-built_in">int</span>errupt-<span class="hljs-symbol">controller@</span><span class="hljs-number">00</span>a01000 &#123;<br>compatible = <span class="hljs-string">&quot;arm,cortex-a7-gic&quot;</span>;<br>#<span class="hljs-built_in">int</span>errupt-cells = &lt;<span class="hljs-number">3</span>&gt;;          <span class="hljs-comment">/* &lt;类别 中断号 触发方式&gt; */</span><br><span class="hljs-built_in">int</span>errupt-controller;<br>reg = &lt;<span class="hljs-number">0x00a01000</span> <span class="hljs-number">0x1000</span>&gt;,<br>      &lt;<span class="hljs-number">0x00a02000</span> <span class="hljs-number">0x100</span>&gt;;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">gpc: gpc<span class="hljs-meta">@020dc000</span> &#123;<br>compatible = <span class="hljs-string">&quot;fsl,imx6ul-gpc&quot;</span>, <span class="hljs-string">&quot;fsl,imx6q-gpc&quot;</span>;<br>reg = <span class="hljs-variable">&lt;0x020dc000 0x4000&gt;</span>;<br>interrupt-controller;<br><span class="hljs-comment">#interrupt-cells = &lt;3&gt;;</span><br>interrupts = <span class="hljs-variable">&lt;GIC_SPI 89 IRQ_TYPE_LEVEL_HIGH&gt;</span>;<br>interrupt-parent = <span class="hljs-variable">&lt;&amp;intc&gt;</span>;/<span class="hljs-symbol">*</span> 继承intc <span class="hljs-symbol">*</span>/<br>fsl,mf-mix-wakeup-irq = <span class="hljs-variable">&lt;0xfc00000 0x7d00 0x0 0x1400640&gt;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs lasso">soc &#123;<br>#address<span class="hljs-params">-cells</span> = &lt;<span class="hljs-number">1</span>&gt;;<br>#size<span class="hljs-params">-cells</span> = &lt;<span class="hljs-number">1</span>&gt;;<br>compatible = <span class="hljs-string">&quot;simple-bus&quot;</span>;<br>interrupt<span class="hljs-params">-parent</span> = &lt;&amp;gpc&gt;;<span class="hljs-comment">/* 继承gpc */</span><br>ranges;<br><br><span class="hljs-params">...</span><span class="hljs-params">...</span>..<br><br>gpio1: gpio@<span class="hljs-number">0209</span>c000 &#123;<br>compatible = <span class="hljs-string">&quot;fsl,imx6ul-gpio&quot;</span>, <span class="hljs-string">&quot;fsl,imx35-gpio&quot;</span>;<br>reg = &lt;<span class="hljs-number">0x0209c000</span> <span class="hljs-number">0x4000</span>&gt;;<br>interrupts = &lt;GIC_SPI <span class="hljs-number">66</span> IRQ_TYPE_LEVEL_HIGH&gt;,<br>     &lt;GIC_SPI <span class="hljs-number">67</span> IRQ_TYPE_LEVEL_HIGH&gt;;<br>gpio<span class="hljs-params">-controller</span>;<br>#gpio<span class="hljs-params">-cells</span> = &lt;<span class="hljs-number">2</span>&gt;;<br>interrupt<span class="hljs-params">-controller</span>;<br>#interrupt<span class="hljs-params">-cells</span> = &lt;<span class="hljs-number">2</span>&gt;;<br>&#125;;<br><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span><span class="hljs-params">...</span>.<br>gpio5:<span class="hljs-params">...</span><span class="hljs-params">...</span>.<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="11-用一个程序总结驱动机制"><a href="#11-用一个程序总结驱动机制" class="headerlink" title="11 用一个程序总结驱动机制"></a>11 用一个程序总结驱动机制</h1><h1 id="12-驱动开发基础"><a href="#12-驱动开发基础" class="headerlink" title="12 驱动开发基础"></a>12 驱动开发基础</h1><ul><li>非阻塞方式：NOBLOCK，不等待，直接返回</li><li>休眠唤醒：中断</li><li>poll机制：有一个timeout，在指定的时间内检测有没有数据</li><li>异步通知机制：信号<ul><li>信号处理内部机制：实际上就是修改栈中LR的值，从而跳去执行信号处理函数，执行完后，触发异常，异常处理，恢复之前的LR</li></ul></li></ul><blockquote><p>推荐书：《linux源代码情景分析》，毛德操</p></blockquote><h1 id="13-实战-SR501人体红外模块驱动开发"><a href="#13-实战-SR501人体红外模块驱动开发" class="headerlink" title="13 实战_SR501人体红外模块驱动开发"></a>13 实战_SR501人体红外模块驱动开发</h1><h2 id="驱动编写方法"><a href="#驱动编写方法" class="headerlink" title="驱动编写方法"></a>驱动编写方法</h2><ul><li>中断</li><li>内核线程</li></ul><h2 id="1原理图"><a href="#1原理图" class="headerlink" title="1原理图"></a>1原理图</h2><p><img src="/./../photo/image-20231124155738845.png" alt="image-20231124155738845"></p><p>人体都有恒定的体温，一般在37度，所以会发出特定波长10uM左右的红外线，被动式红外探头就是靠探测人体发射的10uM左右的红外线而进行工作的。人体发射的10uM左右的红外线通过菲泥尔滤光片增强后聚集到红外感应源上。红外感应源通常采用热释电元件，这种元件在接收到人体红外辐射温度发生变化时就会失去电荷平衡，向外释放电荷，后续电路经检测处理后就能产生报警信号。</p><p>人体红外模块是一种能够检测人或动物发射的红外线而输出电信号的传感器。广泛应用于各种自动化控制装置中。比如常见的楼道自动开关、防盗报警等。如果有人在量程内运动，DO引脚将会输出有效信号。</p><p>实物和使用方法如下图所示，可以设置探测距离、延迟控制等：</p><p>通过跳线来设置是否可以重复触发，默认为L。其中L表示不可重复，H表示可重复。含义如下：</p><p>① 不可重复触发方式：</p><p>感应到人体并输出高电平后，延时时间一结束，输出将自动从高电平变为低电平。</p><p>② 重复触发方式： </p><p>感应到人体后输出高电平后，在延时时间段内，如果有人体在其感应范围内活动，其输出将一直保持高电平，直到人离开后才延时将高电平变为低电平(感应模块检测到人体的每一次活动后会自动顺延一个延时时间段，并且以最后一次活动的时间为延时时间的起始点)。</p><p>可以通过电位器实现封锁时间和检测距离的调节：</p><p>① 调节检测距离：</p><p>即有效距离的远近。调节距离电位器顺时针旋转，感应距离增大（约 7 米）；反之，感应距离减小（约 3 米）。</p><p>② 封锁时间：</p><p>感应模块在每一次感应输出后(高电平变为低电平)，可以紧跟着设置一个封锁时间，在此时间段内感应器不接收任何感应信号。</p><p>此功能可以实现(感应输出时间和封锁时间)两者的间隔工作，可应用于间隔探测产品；同时此功能可有效抑制负载切换过程中产生的各种干扰。</p><p>调节延时电位器顺时针旋转，感应延时加长（约300S），反之，感应延时减短（约0.5S）。</p><h2 id="2-实现设备树节点"><a href="#2-实现设备树节点" class="headerlink" title="2 实现设备树节点"></a>2 实现设备树节点</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">sr501</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;alpha-sr501&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-attr">gpios</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;gpio4</span> <span class="hljs-number">19</span> GPIO_ACTIVE_HIGH&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><h2 id="3-驱动框架"><a href="#3-驱动框架" class="headerlink" title="3 驱动框架"></a>3 驱动框架</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrupt.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sched.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/pm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/sysctl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/proc_fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio_keys.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/workqueue.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_platform.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/spinlock.h&gt;</span></span><br><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">sr501_open</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 从设备读数据 */</span><br><span class="hljs-comment">/* 设备文件 返回给用户空间的数据缓冲区 读取长度 相对于文件首地址的偏移 */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">sr501_read</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">char</span> __user *buf, </span></span><br><span class="hljs-params"><span class="hljs-function">                           <span class="hljs-type">size_t</span> cnt,        <span class="hljs-type">loff_t</span> *offt)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-comment">/* 向设备写数据 */</span><br><span class="hljs-comment">/* 设备文件 要写给设备写入的数据 写入长度 相对于文件首地址的偏移 */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">sr501_write</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-type">const</span> <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> cnt, <span class="hljs-type">loff_t</span> *offt)</span></span><br><span class="hljs-function"></span>&#123;<br>        <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">sr501_poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *filp, <span class="hljs-keyword">struct</span> poll_table_struct *wait)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/* 关闭设备 */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">sr501_release</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">struct</span> file *filp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> sr501_fops = &#123;<br>.owner = THIS_MODULE,<br>.open = sr501_open,<br>.read = sr501_read,<br>.write = sr501_write,<br>.poll = sr501_poll,<br>.release = sr501_release,<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">sr501_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;sr501 match sucess!\r\n&quot;</span>);<br>    <span class="hljs-built_in">register_chrdev</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;sr501&quot;</span>, &amp;sr501_fops);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">sr501_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">unregister_chrdev</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;sr501&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">of_device_id</span> sr501_of_match[] = &#123;<br>&#123; .compatible = <span class="hljs-string">&quot;alpha-sr501&quot;</span>, &#125;,<br>&#123; &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">platform_driver</span> sr501_device_driver = &#123;<br>.probe= sr501_probe,<br>.remove= sr501_remove,<br>.driver= &#123;<br>.name= <span class="hljs-string">&quot;sr501&quot;</span>,<br>.of_match_table = <span class="hljs-built_in">of_match_ptr</span>(sr501_of_match),<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">sr501_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\r\n&quot;</span>,__FILE__,__FUNCTION__,__LINE__);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">platform_driver_register</span>(&amp;sr501_device_driver);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">sr501_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">platform_driver_unregister</span>(&amp;sr501_device_driver);<br>&#125;<br><br><span class="hljs-built_in">module_init</span>(sr501_init);<br><span class="hljs-built_in">module_exit</span>(sr501_exit);<br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br></code></pre></td></tr></table></figure><h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">make dtbs<br>sudo cp arch<span class="hljs-regexp">/arm/</span>boot<span class="hljs-regexp">/dts/im</span>x6ull-alpha.dtb <span class="hljs-regexp">/home/</span>lk<span class="hljs-regexp">/linux/</span>tftpboot/ -rf<br>sudo cp sr501.ko  <span class="hljs-regexp">/home/</span>lk<span class="hljs-regexp">/linux/</span>nfs<span class="hljs-regexp">/rootfs/</span>lib<span class="hljs-regexp">/modules/</span><span class="hljs-number">4.1</span>.<span class="hljs-number">15</span>/ -rf<br></code></pre></td></tr></table></figure><h2 id="5-查看中断"><a href="#5-查看中断" class="headerlink" title="5 查看中断"></a>5 查看中断</h2><p><img src="/./../photo/image-20231124214601939.png" alt="image-20231124214601939"></p><h1 id="17-实战-SR04超声波测距模块驱动开发"><a href="#17-实战-SR04超声波测距模块驱动开发" class="headerlink" title="17 实战_SR04超声波测距模块驱动开发"></a>17 实战_SR04超声波测距模块驱动开发</h1><h2 id="驱动编写方法-1"><a href="#驱动编写方法-1" class="headerlink" title="驱动编写方法"></a>驱动编写方法</h2><ul><li>查询方式</li><li>中断</li></ul><h2 id="1-SR04工作原理"><a href="#1-SR04工作原理" class="headerlink" title="1 SR04工作原理"></a>1 SR04工作原理</h2><p><img src="/./../photo/01_sr04_sch.png" alt="image-20211223183302503"></p><p>要测距，需如下操作：</p><ul><li><p>触发：向Trig（脉冲触发引脚）发出一个大约10us的高电平。</p><ul><li>模块就自动发出8个40Khz的超声波，超声波遇到障碍物后反射回来，模块收到返回来的超声波。</li></ul></li><li><p>回响：模块接收到反射回来的超声波后，Echo引脚输出一个与检测距离成比例的高电平。</p></li><li><p>我们只要计算Echo引脚维持高电平的时间T即刻计算举例：D &#x3D; 340*T&#x2F;2。</p></li></ul><h2 id="2-原理图"><a href="#2-原理图" class="headerlink" title="2 原理图"></a>2 原理图</h2><p><img src="/./../photo/image-20231125155404835.png" alt="image-20231125155404835"></p><h2 id="3-方法1-轮询方式"><a href="#3-方法1-轮询方式" class="headerlink" title="3 方法1   轮询方式"></a>3 方法1   轮询方式</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">int us = <span class="hljs-number">0</span><span class="hljs-punctuation">;</span><br><br>local_irq_save(<span class="hljs-keyword">flags</span>)<span class="hljs-punctuation">;</span>    <span class="hljs-comment">// 关中断</span><br><br><span class="hljs-comment">//使用udelay来延时判断引脚电平</span><br><span class="hljs-keyword">while</span> (低电平)<span class="hljs-punctuation">;</span> <span class="hljs-comment">// 等待高电平</span><br><span class="hljs-keyword">while</span> (高电平)<span class="hljs-comment">&#123; udelay(1); us++; &#125;</span>  <span class="hljs-comment">// 累加时间</span><br><br>local_irq_restore(<span class="hljs-keyword">flags</span>)<span class="hljs-punctuation">;</span> <span class="hljs-comment">// 恢复中断</span><br></code></pre></td></tr></table></figure><h2 id="4-方法2中断"><a href="#4-方法2中断" class="headerlink" title="4 方法2中断"></a>4 方法2中断</h2><p>设置Echo中断为双边沿触发，在上升沿读取时间T1，在下降沿读取时间T2：T2-T1就是高电平的时间。</p><p>关键在于：使用什么函数读取时间？</p><p>内核在启动时，定时器便开始计数，通过获取计数，可计算得出运行时间。</p><p>获取时间函数如下：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">ktime_get_ns</span>();          <span class="hljs-comment">// 获取内核启动到现在的时间，在挂起时会暂停</span><br><span class="hljs-built_in">ktime_get_boottime_ns</span>(); <span class="hljs-comment">// 获取内核启动到现在的时间，不受挂起影响，是绝对时间</span><br><span class="hljs-built_in">ktime_get_real_ns</span>();     <span class="hljs-comment">// 获取Unix时间(1970年)到现在的时间，可能涉及闰秒更新，用得比较少</span><br><span class="hljs-built_in">ktime_get_raw_ns</span>();      <span class="hljs-comment">// 类似ktime_get_ns(),不涉及闰秒更新，用得比较少</span><br></code></pre></td></tr></table></figure><h2 id="5-实现设备树节点"><a href="#5-实现设备树节点" class="headerlink" title="5 实现设备树节点"></a>5 实现设备树节点</h2><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-title class_">sr04</span> <span class="hljs-punctuation">&#123;</span><br><span class="hljs-attr">compatible</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;alpha-sr04&quot;</span><span class="hljs-punctuation">;</span><br><span class="hljs-attr">trig-gpios</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;gpio1</span> <span class="hljs-number">1</span> GPIO_ACTIVE_LOW&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-attr">echo-gpios</span> <span class="hljs-operator">=</span> <span class="hljs-params">&lt;<span class="hljs-variable">&amp;gpio1</span> <span class="hljs-number">2</span> GPIO_ACTIVE_LOW&gt;</span><span class="hljs-punctuation">;</span><br><span class="hljs-punctuation">&#125;;</span><br></code></pre></td></tr></table></figure><h2 id="6-源码"><a href="#6-源码" class="headerlink" title="6 源码"></a>6 源码</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/miscdevice.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/major.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mutex.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/proc_fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/seq_file.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/tty.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kmod.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gfp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio/consumer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrupt.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/workqueue.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/current.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/drbd.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> major;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">class</span> *sr04_class;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_desc</span> *sr04_trig;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_desc</span> *sr04_echo;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> irq;<br><span class="hljs-type">static</span> <span class="hljs-type">wait_queue_head_t</span> sr04_wq;<br><span class="hljs-type">static</span> u64 sr04_data_ns = <span class="hljs-number">0</span>;  <br><br><span class="hljs-comment">/* 实现对应的open/read/write等函数，填入file_operations结构体                   */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">sr04_drv_read</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">loff_t</span> *offset)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-type">int</span> us = <span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">int</span> timeout_us = <span class="hljs-number">1000000</span>;<br><br><span class="hljs-built_in">local_irq_save</span>(flags);  <span class="hljs-comment">// 关中断</span><br><br><span class="hljs-comment">/* 发送10us高电平    , 测量距离 2cm-450cm */</span><br><span class="hljs-built_in">gpiod_set_value</span>(sr04_trig, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">udelay</span>(<span class="hljs-number">15</span>);<br><span class="hljs-built_in">gpiod_set_value</span>(sr04_trig, <span class="hljs-number">0</span>);<br><br><br><span class="hljs-comment">//使用udelay来延时判断引脚电平</span><br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">gpiod_get_value</span>(sr04_echo) &amp;&amp; timeout_us)<br>&#123;<br><span class="hljs-built_in">udelay</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 等待高电平</span><br>timeout_us--;<br>&#125;<br><span class="hljs-keyword">if</span> (!timeout_us)<br>&#123;<br><span class="hljs-built_in">local_irq_restore</span>(flags); <span class="hljs-comment">// 恢复中断</span><br><span class="hljs-keyword">return</span> -EAGAIN;<br>&#125;<br><br>timeout_us = <span class="hljs-number">1000000</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">gpiod_get_value</span>(sr04_echo) &amp;&amp; timeout_us)<br>&#123; <br><span class="hljs-built_in">udelay</span>(<span class="hljs-number">1</span>); <br>us++; <span class="hljs-comment">// 累加时间</span><br>timeout_us--;<br>&#125;  <br><br><span class="hljs-keyword">if</span> (!timeout_us)<br>&#123;<br><span class="hljs-built_in">local_irq_restore</span>(flags); <span class="hljs-comment">// 恢复中断</span><br><span class="hljs-keyword">return</span> -EAGAIN;<br>&#125;<br><br><span class="hljs-built_in">local_irq_restore</span>(flags); <span class="hljs-comment">// 恢复中断</span><br><span class="hljs-built_in">copy_to_user</span>(buf, &amp;us, <span class="hljs-number">4</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>   <span class="hljs-type">int</span> timeout;<br><br><span class="hljs-comment">/* 发送10us高电平    , 测量距离 2cm-450cm */</span><br><span class="hljs-built_in">gpiod_set_value</span>(sr04_trig, <span class="hljs-number">1</span>);<br><span class="hljs-built_in">udelay</span>(<span class="hljs-number">15</span>);<br><span class="hljs-built_in">gpiod_set_value</span>(sr04_trig, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">/* 等待数据 */</span><br>timeout = <span class="hljs-built_in">wait_event_interruptible_timeout</span>(sr04_wq, sr04_data_ns, HZ);<br><span class="hljs-keyword">if</span> (timeout)<br>&#123;<br><span class="hljs-built_in">copy_to_user</span>(buf, &amp;sr04_data_ns, <span class="hljs-number">4</span>);<br>sr04_data_ns = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-number">4</span>;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">return</span> -EAGAIN;<br>&#125; <br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> <span class="hljs-title">sr04_drv_poll</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *fp, poll_table * wait)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//printk(&quot;%s %s line %d\n&quot;, __FILE__, __FUNCTION__, __LINE__);</span><br><span class="hljs-comment">//poll_wait(fp, &amp;sr04_wait, wait);</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br><span class="hljs-comment">/* 定义自己的file_operations结构体                                              */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> sr04_fops = &#123;<br>.owner = THIS_MODULE,<br>.read    = sr04_drv_read,<br>.poll    = sr04_drv_poll,<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title">sr04_isr</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> val = <span class="hljs-built_in">gpiod_get_value</span>(sr04_echo);<br><br><span class="hljs-keyword">if</span> (val) <span class="hljs-comment">/* 上升沿 */</span><br>&#123;<br><span class="hljs-comment">/* 1. 记录数据 */</span><br>sr04_data_ns = <span class="hljs-built_in">ktime_get_ns</span>();<br><span class="hljs-comment">//printk(&quot;%s %s %d, val = 0x%x\n&quot;, __FILE__, __FUNCTION__, __LINE__, sr04_data);</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-comment">/* 下降沿 */</span><br>&#123;<br>sr04_data_ns = <span class="hljs-built_in">ktime_get_ns</span>() - sr04_data_ns;<br><span class="hljs-comment">/* 2. 唤醒APP:去同一个链表把APP唤醒 */</span><br><span class="hljs-built_in">wake_up</span>(&amp;sr04_wq);<br>&#125;<br><br><span class="hljs-keyword">return</span> IRQ_HANDLED; <span class="hljs-comment">// IRQ_WAKE_THREAD;</span><br>&#125;<br><br><br><br><br><span class="hljs-comment">/* 1. 从platform_device获得GPIO</span><br><span class="hljs-comment"> * 2. gpio=&gt;irq</span><br><span class="hljs-comment"> * 3. request_irq</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">sr04_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><span class="hljs-comment">/* 1. 获得硬件信息 */</span><br>sr04_trig = <span class="hljs-built_in">gpiod_get</span>(&amp;pdev-&gt;dev, <span class="hljs-string">&quot;trig&quot;</span>, GPIOD_OUT_LOW);<br>sr04_echo = <span class="hljs-built_in">gpiod_get</span>(&amp;pdev-&gt;dev, <span class="hljs-string">&quot;echo&quot;</span>, GPIOD_IN);<br><br>irq = <span class="hljs-built_in">gpiod_to_irq</span>(sr04_echo);<br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;irq: %d\r\n&quot;</span>,irq);<br><span class="hljs-built_in">request_irq</span>(irq, sr04_isr, IRQF_TRIGGER_RISING|IRQF_TRIGGER_FALLING, <span class="hljs-string">&quot;sr04&quot;</span>, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">/* 2. device_create */</span><br><span class="hljs-built_in">device_create</span>(sr04_class, <span class="hljs-literal">NULL</span>, <span class="hljs-built_in">MKDEV</span>(major, <span class="hljs-number">0</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;sr04&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">sr04_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><span class="hljs-built_in">device_destroy</span>(sr04_class, <span class="hljs-built_in">MKDEV</span>(major, <span class="hljs-number">0</span>));<br><span class="hljs-built_in">free_irq</span>(irq, <span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in">gpiod_put</span>(sr04_trig);<br><span class="hljs-built_in">gpiod_put</span>(sr04_echo);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">of_device_id</span> ask100_sr04[] = &#123;<br>    &#123; .compatible = <span class="hljs-string">&quot;alpha-sr04&quot;</span> &#125;,<br>    &#123; &#125;,<br>&#125;;<br><br><span class="hljs-comment">/* 1. 定义platform_driver */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">platform_driver</span> sr04s_driver = &#123;<br>    .probe      = sr04_probe,<br>    .remove     = sr04_remove,<br>    .driver     = &#123;<br>        .name   = <span class="hljs-string">&quot;alpha-sr04&quot;</span>,<br>        .of_match_table = ask100_sr04,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-comment">/* 2. 在入口函数注册platform_driver */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">sr04_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> err;<br>    <br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><br><span class="hljs-comment">/* 注册file_operations */</span><br>major = <span class="hljs-built_in">register_chrdev</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;sr04&quot;</span>, &amp;sr04_fops);  <br><br>sr04_class = <span class="hljs-built_in">class_create</span>(THIS_MODULE, <span class="hljs-string">&quot;sr04_class&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_ERR</span>(sr04_class)) &#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><span class="hljs-built_in">unregister_chrdev</span>(major, <span class="hljs-string">&quot;sr04&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">PTR_ERR</span>(sr04_class);<br>&#125;<br><br><span class="hljs-built_in">init_waitqueue_head</span>(&amp;sr04_wq);<br><br><br>    err = <span class="hljs-built_in">platform_driver_register</span>(&amp;sr04s_driver); <br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br><span class="hljs-comment">/* 3. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数</span><br><span class="hljs-comment"> *     卸载platform_driver</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">sr04_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><br>    <span class="hljs-built_in">platform_driver_unregister</span>(&amp;sr04s_driver);<br><span class="hljs-built_in">class_destroy</span>(sr04_class);<br><span class="hljs-built_in">unregister_chrdev</span>(major, <span class="hljs-string">&quot;sr04&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */</span><br><br><span class="hljs-built_in">module_init</span>(sr04_init);<br><span class="hljs-built_in">module_exit</span>(sr04_exit);<br><br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br></code></pre></td></tr></table></figure><h1 id="18-实战-DHT11温湿度传感器驱动开发"><a href="#18-实战-DHT11温湿度传感器驱动开发" class="headerlink" title="18 实战_DHT11温湿度传感器驱动开发"></a>18 实战_DHT11温湿度传感器驱动开发</h1><h2 id="驱动编写方法-2"><a href="#驱动编写方法-2" class="headerlink" title="驱动编写方法"></a>驱动编写方法</h2><ul><li>查询方式</li><li>中断</li><li>IIO子系统</li></ul><h2 id="1-DHT11工作原理"><a href="#1-DHT11工作原理" class="headerlink" title="1. DHT11工作原理"></a>1. DHT11工作原理</h2><h3 id="1-1-硬件信号"><a href="#1-1-硬件信号" class="headerlink" title="1.1 硬件信号"></a>1.1 硬件信号</h3><p><img src="/./../photo/01_sch.png" alt="image-20211225161948946"></p><p>需要先发一个开始信号给DHT11，才能接收数据。</p><p>下图为一次完整的传输示例，其中深黑色信号表示由主机驱动，即主机向DHT11发信号，浅灰色信号表示DHT11驱动，即DHT11发向主机发信号。</p><p><img src="/./../photo/02_operaions.png"></p><p>当主机没有与DHT11通信时，总线处于空闲状态，此时总线电平由于上拉电阻的作用处于高电平。</p><p>当主机与DHT11正在通信时，总线处于通信状态，一次完整的通信过程如下：</p><ul><li><p>主机将对应的GPIO管脚配置为输出，准备向DHT11发送数据；</p></li><li><p>主机发送一个开始信号：</p><ul><li>开始信号 &#x3D; 一个低脉冲 + 一个高脉冲。低脉冲至少持续18ms，高脉冲持续20-40us。</li></ul></li><li><p>主机将对应的GPIO管脚配置为输入，准备接受DHT11传来的数据，这时信号由上拉电阻拉高；</p></li><li><p>DHT11发出响应信号：</p><ul><li>响应信号 &#x3D; 一个低脉冲 + 一个高脉冲。低脉冲持续80us，高脉冲持续80us。</li></ul></li><li><p>DHT11发出数据信号：</p><ul><li>数据为0的一位信号 &#x3D; 一个低脉冲 + 一个高脉冲。低脉冲持续50us，高脉冲持续26～28us。</li><li>数据为1的一位信号 &#x3D; 一个低脉冲 + 一个高脉冲。低脉冲持续50us，高脉冲持续70us。</li></ul></li><li><p>DHT11发出结束信号：</p><ul><li>最后1bit数据传送完毕后，DHT11拉低总线50us，然后释放总线，总线由上拉电阻拉高进入空闲状态。</li></ul></li></ul><p>​                               </p><h3 id="1-2-数据格式"><a href="#1-2-数据格式" class="headerlink" title="1.2 数据格式"></a>1.2 数据格式</h3><p>数据格式: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">8bit湿度整数数据+8bit湿度小数数据<br>+8bi温度整数数据+8bit温度小数数据<br>+8bit校验和<br></code></pre></td></tr></table></figure><p>数据传送正确时,校验和等于“8bit湿度整数数据+8bit湿度小数数据+8bi温度整数数据+8bit温度小数数据”所得结果的末8位。</p><h2 id="2-编程思路"><a href="#2-编程思路" class="headerlink" title="2. 编程思路"></a>2. 编程思路</h2><p>有了上述基础知识后就可以开始编写程序了。</p><p>编程思路如下：</p><ul><li>设置好GPIO；</li><li>主机把GPIO设置为输出引脚，发送开始信号，然后把GPIO设置为输入引脚；</li><li>主机判断是否收到DHT11的回应信号；</li><li>接收到回应信号后，开始读取数据；</li><li>接收完数据后，校验、解析。</li></ul><p>关键在于如何得到一位数据，看看下图：</p><ul><li>先等待低电平结束，一直等到出现高电平；然后延时40us，读取GPIO值：这就是该位的数据值。</li></ul><p> <img src="/./../photo/03_dht11_time.png"></p><h2 id="3-编写驱动程序"><a href="#3-编写驱动程序" class="headerlink" title="3. 编写驱动程序"></a>3. 编写驱动程序</h2><h3 id="3-1-方法1-查询方式"><a href="#3-1-方法1-查询方式" class="headerlink" title="3.1 方法1: 查询方式"></a>3.1 方法1: 查询方式</h3><p>触发DHT11转换数据后，就把引脚配置为输入引脚，检测引脚的电平变化，并记录高低电平的时间，最后解析出温湿度。</p><p><strong>注意</strong>：要关闭中断。</p><p>示例代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">dht11_read_byte</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">//使用udelay来延时判断引脚电平</span><br>    <span class="hljs-keyword">while</span> (低电平); <span class="hljs-comment">// 等待高电平</span><br>    <span class="hljs-keyword">while</span> (高电平)&#123; udelay(<span class="hljs-number">1</span>); us++; &#125;  <span class="hljs-comment">// 累加时间</span><br>&#125;<br><br><span class="hljs-type">int</span> us = <span class="hljs-number">0</span>;<br><br>local_irq_save(flags);    <span class="hljs-comment">// 关中断</span><br>val1 = dht11_read_byte();<br>val2 = dht11_read_byte();<br>tmp1 = dht11_read_byte();<br>tmp2 = dht11_read_byte();<br>crc  = dht11_read_byte();<br>local_irq_restore(flags); <span class="hljs-comment">// 恢复中断</span><br></code></pre></td></tr></table></figure><h3 id="3-2-方法2-中断方式"><a href="#3-2-方法2-中断方式" class="headerlink" title="3.2 方法2: 中断方式"></a>3.2 方法2: 中断方式</h3><p>触发DHT11转换数据后，就把引脚配置为输入引脚，并注册中断：在中断函数中记录上升沿、下降沿的实际，解析出温湿度。</p><p>获取时间函数如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">ktime_get_ns();          <span class="hljs-comment">// 获取内核启动到现在的时间，在挂起时会暂停</span><br>ktime_get_boottime_ns(); <span class="hljs-comment">// 获取内核启动到现在的时间，不受挂起影响，是绝对时间</span><br>ktime_get_real_ns();     <span class="hljs-comment">// 获取Unix时间(1970年)到现在的时间，可能涉及闰秒更新，用得比较少</span><br>ktime_get_raw_ns();      <span class="hljs-comment">// 类似ktime_get_ns(),不涉及闰秒更新，用得比较少</span><br></code></pre></td></tr></table></figure><h3 id="3-3-方法3-使用IIO子系统"><a href="#3-3-方法3-使用IIO子系统" class="headerlink" title="3.3 方法3: 使用IIO子系统"></a>3.3 方法3: 使用IIO子系统</h3><p>内核已经自带DHT11的驱动程序：<code>drivers/iio/humidity/dht11.c</code>：</p><ul><li><p>配置内核<br><img src="/./../photo/04_config_dht11_kernel.png" alt="image-20211225162846563"></p></li><li><p>编写设备树，参考<code>Documentation\devicetree\bindings\iio\humidity\dht11.txt</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">// imx6ull<br>humidity_sensor &#123; compatible = &quot;dht11&quot;;<br>gpios = &lt;&amp;gpio4 19 0&gt;; <br>&#125;;<br><br>// stm32mp157<br>humidity_sensor &#123; compatible = &quot;dht11&quot;;<br>gpios = &lt;&amp;gpioa 50&gt;; <br>&#125;;<br></code></pre></td></tr></table></figure></li></ul><p>怎么使用？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /sys/bus/iio/devices/iio:device1/in_temp_input<br>cat /sys/bus/iio/devices/iio:device1/in_humidityrelative_input<br></code></pre></td></tr></table></figure><h1 id="21-实战-DS18B20驱动编程"><a href="#21-实战-DS18B20驱动编程" class="headerlink" title="21 实战_DS18B20驱动编程"></a>21 实战_DS18B20驱动编程</h1><h2 id="1-硬件连接"><a href="#1-硬件连接" class="headerlink" title="1.  硬件连接"></a>1.  硬件连接</h2><p><img src="/./../photo/01_sch-1701156562752.png" alt="image-20220104184716599"></p><h2 id="2-访问流程"><a href="#2-访问流程" class="headerlink" title="2. 访问流程"></a>2. 访问流程</h2><p>在一条数据线上，可以连接多个DS18B20。每个DS18B20都内嵌不同的ID，所以需要先选择某个DS18B20。</p><p>如果只有一个DS18B20，就不需要选择。</p><p>访问DS18B20的流程为：启动温度转换、读取温度。</p><p>怎么启动温度转换？方法如下：</p><ul><li>发出Start信号</li><li>得到回应</li><li>发出8位的数据，用于选择某个DS18B20</li><li>发出温度转换命令</li><li>等待温度转换完毕</li></ul><p>温度转换完毕后，数据存在DS18B20内部的暂存器中。怎么读出数据？方法如下：</p><ul><li>发出Start信号</li><li>得到回应</li><li>发出8位的数据，用于选择某个DS18B20</li><li>发出读暂存器的命令</li><li>读温度低8位</li><li>读温度高8位</li></ul><h2 id="3-硬件信号"><a href="#3-硬件信号" class="headerlink" title="3. 硬件信号"></a>3. 硬件信号</h2><h3 id="3-1-Start和回应"><a href="#3-1-Start和回应" class="headerlink" title="3.1 Start和回应"></a>3.1 Start和回应</h3><p>深黑色线表示由主机驱动信号，浅灰色线表示由DS18B20驱动信号。</p><p>最开始时引脚是高电平，想要开始传输信号：</p><ul><li>必须要拉低至少480us，这是复位信号；</li><li>然后拉高释放总线，等待15~60us之后，</li><li>如果GPIO上连有DS18B20芯片，它会拉低60~240us：这就是回应</li></ul><p>如果主机在最后检查到60～240us的低脉冲回应信号，则表示DS18B20初始化成功。</p><p><img src="/./../photo/02_start_and_ack.png" alt="image-20220104185739784"></p><h3 id="3-2-写一位数据"><a href="#3-2-写一位数据" class="headerlink" title="3.2 写一位数据"></a>3.2 写一位数据</h3><p>如果写0，拉低至少60us(写周期为60-120us)即可；</p><p>如果写1，先拉低至少1us，然后拉高，整个写周期至少为60us即可。</p><p><img src="/./../photo/03_write_bit.png" alt="image-20220104185839041"></p><h3 id="3-3-读一位数据"><a href="#3-3-读一位数据" class="headerlink" title="3.3 读一位数据"></a>3.3 读一位数据</h3><p>主机先拉低至少1us，随后读取电平，如果为0，即读到的数据是0，如果为1，即可读到的数据是1。</p><p>整个过程必须在15us内完成，15us后引脚都会被拉高。</p><p><img src="/./../photo/04_read_bit.png" alt="image-20220104190003488"></p><h2 id="4-DS18B20内部寄存器"><a href="#4-DS18B20内部寄存器" class="headerlink" title="4. DS18B20内部寄存器"></a>4. DS18B20内部寄存器</h2><p>参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">《嵌入式Linux应用开发完全手册V4.0_韦东山全系列视频文档-IMX6ULL开发板.docx》<br>第13篇 IMX6ULL裸机开发<br>第二十二章 DS18B20温度模块<br></code></pre></td></tr></table></figure><h2 id="5-编写驱动程序"><a href="#5-编写驱动程序" class="headerlink" title="5. 编写驱动程序"></a>5. 编写驱动程序</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/poll.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/errno.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/miscdevice.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/major.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mutex.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/proc_fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/seq_file.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/stat.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/tty.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kmod.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gfp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio/consumer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/platform_device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrupt.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/timer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/workqueue.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/current.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/drbd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/ktime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/version.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> major;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">class</span> *ds18b20_class;<br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_desc</span> *ds18b20_data_pin;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">my_udelay</span><span class="hljs-params">(<span class="hljs-type">int</span> us)</span></span><br><span class="hljs-function"></span>&#123;<br>u64 pre,last;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> LINUX_VERSION_CODE &lt; KERNEL_VERSION(5,0,0)</span><br>pre = <span class="hljs-built_in">ktime_get_boot_ns</span>();<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>last = <span class="hljs-built_in">ktime_get_boot_ns</span>();<br><span class="hljs-keyword">if</span>(last - pre &gt;= us*<span class="hljs-number">1000</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>pre = <span class="hljs-built_in">ktime_get_boottime_ns</span>();<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>&#123;<br>last = <span class="hljs-built_in">ktime_get_boottime_ns</span>();<br><span class="hljs-keyword">if</span> (last - pre &gt;= us * <span class="hljs-number">1000</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">ds18b20_wait_for_ack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> timeout_count = <span class="hljs-number">500</span>;<br><br><span class="hljs-comment">/* 如果是高电平,等待 */</span><br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">gpiod_get_value</span>(ds18b20_data_pin) &amp;&amp; --timeout_count)<br>&#123;<br><span class="hljs-built_in">udelay</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (!timeout_count)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-comment">/* 现在是低电平 */</span><br>timeout_count = <span class="hljs-number">500</span>;<br><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">gpiod_get_value</span>(ds18b20_data_pin) &amp;&amp; --timeout_count)<br>&#123;<br><span class="hljs-built_in">udelay</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (!timeout_count)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ds18b20_reset</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* 开始信号：主机驱动信号，发送480us低脉冲 */</span><br><span class="hljs-built_in">gpiod_set_value</span>(ds18b20_data_pin, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">my_udelay</span>(<span class="hljs-number">480</span>);<br><br><span class="hljs-comment">/* 等待应答 */</span><br><span class="hljs-built_in">gpiod_direction_input</span>(ds18b20_data_pin);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">ds18b20_wait_for_ack</span>())<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">ds18b20_write_byte</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;<span class="hljs-number">8</span>; i++)<br>&#123;<br><span class="hljs-keyword">if</span> (data &amp; (<span class="hljs-number">1</span>&lt;&lt;i))<br>&#123;<br><span class="hljs-comment">/* 输出1 */</span><br><span class="hljs-built_in">gpiod_direction_output</span>(ds18b20_data_pin, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">my_udelay</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">/* 设置为输入: 引脚默认为高 */</span><br><span class="hljs-built_in">gpiod_direction_input</span>(ds18b20_data_pin);<br><span class="hljs-built_in">my_udelay</span>(<span class="hljs-number">60</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-comment">/* 输出0 */</span><br><span class="hljs-built_in">gpiod_direction_output</span>(ds18b20_data_pin, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">my_udelay</span>(<span class="hljs-number">60</span>);<br><br><span class="hljs-comment">/* 设置为输入: 引脚默认为高 */</span><br><span class="hljs-built_in">gpiod_direction_input</span>(ds18b20_data_pin);<br><span class="hljs-built_in">my_udelay</span>(<span class="hljs-number">2</span>);<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> <span class="hljs-title">ds18b20_read_byte</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> data = <span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> i;<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>&#123;<br><span class="hljs-built_in">gpiod_direction_output</span>(ds18b20_data_pin, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">my_udelay</span>(<span class="hljs-number">2</span>);<br><br><span class="hljs-comment">/* 设置为输入 */</span><br><span class="hljs-built_in">gpiod_direction_input</span>(ds18b20_data_pin);<br><br><span class="hljs-comment">/* 7us之后读引脚 */</span><br><span class="hljs-built_in">my_udelay</span>(<span class="hljs-number">7</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">gpiod_get_value</span>(ds18b20_data_pin))<br>data |= (<span class="hljs-number">1</span>&lt;&lt;i);<br><br><span class="hljs-comment">/* 读到数据后, 等待足够60us */</span><br><span class="hljs-built_in">my_udelay</span>(<span class="hljs-number">60</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> data;<br>&#125;<br><br><br><span class="hljs-comment">/* 实现对应的open/read/write等函数，填入file_operations结构体                   */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">ssize_t</span> <span class="hljs-title">ds18b20_drv_read</span> <span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-type">char</span> __user *buf, <span class="hljs-type">size_t</span> size, <span class="hljs-type">loff_t</span> *offset)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> flags;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> tempL=<span class="hljs-number">0</span>,tempH=<span class="hljs-number">0</span>;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> integer;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> decimal1,decimal2,decimal;<br><span class="hljs-type">int</span> ret;<br><br><span class="hljs-keyword">if</span> (size != <span class="hljs-number">5</span>)<br><span class="hljs-keyword">return</span> -EINVAL;<br><br><span class="hljs-built_in">local_irq_save</span>(flags);  <span class="hljs-comment">// 关中断</span><br><br><span class="hljs-comment">/* 访问DS18B20的流程为：启动温度转换、读取温度 */</span><br><br><span class="hljs-comment">/* 启动温度转换 */</span><br><span class="hljs-comment">/* 1.发送开始信号 */</span><br><span class="hljs-comment">/* 2.等待回应信号 */</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">ds18b20_reset</span>())<br>&#123;<br><span class="hljs-built_in">gpiod_direction_output</span>(ds18b20_data_pin, <span class="hljs-number">1</span>);  <span class="hljs-comment">/* 每次开始前都是高电平 */</span><br><span class="hljs-built_in">local_irq_restore</span>(flags); <span class="hljs-comment">// 恢复中断</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">/* 3.发出8位的数据，用于选择某个DS18B20 */</span><br><span class="hljs-built_in">ds18b20_write_byte</span>(<span class="hljs-number">0xcc</span>); <span class="hljs-comment">//忽略rom指令，直接使用功能指令</span><br><br><span class="hljs-comment">/* 4.发出温度转换命令 */</span><br><span class="hljs-built_in">ds18b20_write_byte</span>(<span class="hljs-number">0x44</span>); <span class="hljs-comment">//温度转换指令</span><br><br><span class="hljs-comment">/* 5.等待温度转换完毕 */</span><br><span class="hljs-built_in">local_irq_restore</span>(flags); <span class="hljs-comment">// 恢复中断</span><br><span class="hljs-comment">//转换需要时间，延时1s</span><br><span class="hljs-built_in">set_current_state</span>(TASK_INTERRUPTIBLE);<br><span class="hljs-built_in">schedule_timeout</span>(HZ); <br><span class="hljs-built_in">local_irq_save</span>(flags);  <span class="hljs-comment">// 关中断</span><br><br><span class="hljs-comment">/* 不能省略！ */</span><br><span class="hljs-built_in">gpiod_direction_output</span>(ds18b20_data_pin, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 每次开始前都是高电平 */</span><br><span class="hljs-comment">/* 读取温度 */</span><br><span class="hljs-comment">/* 1.发送开始信号 */</span><br><span class="hljs-comment">/* 2.等待回应信号 */</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">ds18b20_reset</span>())<br>&#123;<br><span class="hljs-built_in">gpiod_direction_output</span>(ds18b20_data_pin, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 每次开始前都是高电平 */</span><br><span class="hljs-built_in">local_irq_restore</span>(flags); <span class="hljs-comment">// 恢复中断</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">/* 3.发出8位的数据，用于选择某个DS18B20 */</span><br><span class="hljs-built_in">ds18b20_write_byte</span>(<span class="hljs-number">0xcc</span>); <span class="hljs-comment">//忽略rom指令，直接使用功能指令</span><br><br><span class="hljs-comment">/* 4.发出读暂存器的命令 */</span><br><span class="hljs-built_in">ds18b20_write_byte</span>(<span class="hljs-number">0xbe</span>); <span class="hljs-comment">//忽读暂存器指令</span><br><br><span class="hljs-comment">/* 5.读温度低8位，读温度高8位 */</span><br>tempL = <span class="hljs-built_in">ds18b20_read_byte</span>(); <span class="hljs-comment">//读温度低8位</span><br>tempH = <span class="hljs-built_in">ds18b20_read_byte</span>(); <span class="hljs-comment">//读温度高8位</span><br><br><span class="hljs-comment">/* 数据处理 */</span><br><span class="hljs-keyword">if</span> (tempH &gt; <span class="hljs-number">0x7f</span>)      <span class="hljs-comment">//最高位为1时温度是负</span><br>&#123;<br>tempL    = ~tempL;             <span class="hljs-comment">//补码转换，取反加一</span><br>tempH    = ~tempH+<span class="hljs-number">1</span>;      <br>integer  = tempL/<span class="hljs-number">16</span>+tempH*<span class="hljs-number">16</span>;      <span class="hljs-comment">//整数部分</span><br>decimal1 = (tempL&amp;<span class="hljs-number">0x0f</span>)*<span class="hljs-number">10</span>/<span class="hljs-number">16</span>; <span class="hljs-comment">//小数第一位</span><br>decimal2 = (tempL&amp;<span class="hljs-number">0x0f</span>)*<span class="hljs-number">100</span>/<span class="hljs-number">16</span>%<span class="hljs-number">10</span>;<span class="hljs-comment">//小数第二位</span><br>decimal  = decimal1*<span class="hljs-number">10</span>+decimal2; <span class="hljs-comment">//小数两位</span><br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>integer  = tempL/<span class="hljs-number">16</span>+tempH*<span class="hljs-number">16</span>;      <span class="hljs-comment">//整数部分</span><br>decimal1 = (tempL&amp;<span class="hljs-number">0x0f</span>)*<span class="hljs-number">10</span>/<span class="hljs-number">16</span>; <span class="hljs-comment">//小数第一位</span><br>decimal2 = (tempL&amp;<span class="hljs-number">0x0f</span>)*<span class="hljs-number">100</span>/<span class="hljs-number">16</span>%<span class="hljs-number">10</span>;<span class="hljs-comment">//小数第二位</span><br>decimal  = decimal1*<span class="hljs-number">10</span>+decimal2; <span class="hljs-comment">//小数两位</span><br>&#125;<br><br><span class="hljs-built_in">local_irq_restore</span>(flags); <span class="hljs-comment">// 恢复中断</span><br><br><span class="hljs-built_in">gpiod_direction_output</span>(ds18b20_data_pin, <span class="hljs-number">1</span>);<span class="hljs-comment">/* 每次开始前都是高电平 */</span><br><br>ret = <span class="hljs-built_in">copy_to_user</span>(buf, &amp;integer, <span class="hljs-number">4</span>);<br>ret = <span class="hljs-built_in">copy_to_user</span>(buf+<span class="hljs-number">4</span>, &amp;decimal, <span class="hljs-number">1</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>&#125;<br><br><br><span class="hljs-comment">/* 定义自己的file_operations结构体                                              */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">file_operations</span> ds18b20_fops = &#123;<br>.owner = THIS_MODULE,<br>.read    = ds18b20_drv_read,<br>&#125;;<br><br><br><span class="hljs-comment">/* 1. 从platform_device获得GPIO</span><br><span class="hljs-comment"> * 2. gpio=&gt;irq</span><br><span class="hljs-comment"> * 3. request_irq</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ds18b20_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><br><span class="hljs-comment">/* 1. 获得硬件信息 */</span><br>ds18b20_data_pin = <span class="hljs-built_in">gpiod_get</span>(&amp;pdev-&gt;dev, <span class="hljs-literal">NULL</span>, GPIOD_OUT_LOW);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_ERR</span>(ds18b20_data_pin))<br>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">PTR_ERR</span>(ds18b20_data_pin);<br>&#125;<br><br><span class="hljs-comment">/* 2. 创建设备 */</span><br><span class="hljs-built_in">device_create</span>(ds18b20_class, <span class="hljs-literal">NULL</span>, <span class="hljs-built_in">MKDEV</span>(major, <span class="hljs-number">0</span>), <span class="hljs-literal">NULL</span>, <span class="hljs-string">&quot;ds18b20&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">ds18b20_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> platform_device *pdev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><span class="hljs-built_in">device_destroy</span>(ds18b20_class, <span class="hljs-built_in">MKDEV</span>(major, <span class="hljs-number">0</span>));<br><span class="hljs-built_in">gpiod_put</span>(ds18b20_data_pin);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">of_device_id</span> ask100_ds18b20[] = &#123;<br>    &#123; .compatible = <span class="hljs-string">&quot;alpha-ds18b20&quot;</span> &#125;,<br>    &#123; &#125;,<br>&#125;;<br><br><span class="hljs-comment">/* 1. 定义platform_driver */</span><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">platform_driver</span> ds18b20s_driver = &#123;<br>    .probe      = ds18b20_probe,<br>    .remove     = ds18b20_remove,<br>    .driver     = &#123;<br>        .name   = <span class="hljs-string">&quot;alpha-ds18b20&quot;</span>,<br>        .of_match_table = ask100_ds18b20,<br>    &#125;,<br>&#125;;<br><br><span class="hljs-comment">/* 2. 在入口函数注册platform_driver */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">ds18b20_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> err;<br>    <br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><br><span class="hljs-comment">/* 注册file_operations */</span><br>major = <span class="hljs-built_in">register_chrdev</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;ds18b20&quot;</span>, &amp;ds18b20_fops);  <br><br>ds18b20_class = <span class="hljs-built_in">class_create</span>(THIS_MODULE, <span class="hljs-string">&quot;ds18b20_class&quot;</span>);<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">IS_ERR</span>(ds18b20_class)) &#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><span class="hljs-built_in">unregister_chrdev</span>(major, <span class="hljs-string">&quot;ds18b20&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">PTR_ERR</span>(ds18b20_class);<br>&#125;<br><br>    err = <span class="hljs-built_in">platform_driver_register</span>(&amp;ds18b20s_driver); <br><br><span class="hljs-keyword">return</span> err;<br>&#125;<br><br><span class="hljs-comment">/* 3. 有入口函数就应该有出口函数：卸载驱动程序时，就会去调用这个出口函数</span><br><span class="hljs-comment"> *     卸载platform_driver</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">ds18b20_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s line %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br>    <span class="hljs-built_in">platform_driver_unregister</span>(&amp;ds18b20s_driver);<br><span class="hljs-built_in">class_destroy</span>(ds18b20_class);<br><span class="hljs-built_in">unregister_chrdev</span>(major, <span class="hljs-string">&quot;ds18b20&quot;</span>);<br>&#125;<br><br><br><span class="hljs-comment">/* 7. 其他完善：提供设备信息，自动创建设备节点                                     */</span><br><br><span class="hljs-built_in">module_init</span>(ds18b20_init);<br><span class="hljs-built_in">module_exit</span>(ds18b20_exit);<br><br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br><br><br><br></code></pre></td></tr></table></figure><h1 id="22-实战-红外遥控器HS0038的两种驱动程序"><a href="#22-实战-红外遥控器HS0038的两种驱动程序" class="headerlink" title="22 实战_红外遥控器HS0038的两种驱动程序"></a>22 实战_红外遥控器HS0038的两种驱动程序</h1><h2 id="1-硬件连接-1"><a href="#1-硬件连接-1" class="headerlink" title="1.  硬件连接"></a>1.  硬件连接</h2><p><img src="/./../photo/01_sch-1701229404264.png" alt="image-20220106190332522"></p><h2 id="2-通信协议"><a href="#2-通信协议" class="headerlink" title="2. 通信协议"></a>2. 通信协议</h2><p>我们按下遥控器按键的时候，遥控器自动发送某个红外信号，接收头接收到红外信号，然后把红外信号转换成电平信号，通过IRD这根线，传给SOC。整个传输，只涉及单向传输，由HS0038向主芯片传送。</p><p>因此，我们只需要编写程序，从IRD上获取数据即可，在这之前，我们需要先了解下数据是怎么表示的，也就是传输的红外数据的格式。</p><p>红外协议有：NEC、SONY、RC5、RC6等，常用的就是NEC格式，因此我们主要对NEC进行讲解。</p><p>在分析文章中的波形之前，我们先想象一下怎么在一条数据线上传输信号。</p><p>开始传输数据之前，一般都会发出一个start起始信号，通知对方我开始传输数据了，后面就是每一位每一位的数据。</p><p>NEC协议的开始是一段引导码：</p><p><img src="/./../photo/02_data_seq.png"></p><p>这个引导码由一个9ms的低脉冲加上一个4.5ms的高脉冲组成，它用来通知接收方我要开始传输数据了。</p><p><img src="/./../photo/03_pre_wave.png"></p><p>然后接着的是数据，数据由4字节组成：地址、地址(取反)、数据、数据(取反)，取反是用来校验用的。</p><p>地址是指遥控器的ID，每一类遥控器的ID都不一样，这样就可以防止操控电视的遥控器影响空调。数据就是遥控器上的不同按键值。</p><p>从前面的图可以知道，NEC每次要发32位（地址、地址取反、数据、数据取反，每个8位）的数据。数据的1和0，开始都是0.56ms的低脉冲，对于数据1，后面的高脉冲比较长，对于数据0，后面的高脉冲比较短。</p><p><img src="/./../photo/04_data_wave.png"></p><p>第一次按下按键时，它会发出引导码，地址，地址取反，数据，数据取反。</p><p>如果这时还没松开按键，这就是“长按”，怎么表示“长按”？遥控器会发送一个不一样的引导码，这个引导码由9ms的低脉冲，2.25ms的高脉冲组成，表示现在按的还是上次一样的按键，也叫连发码，它会一直发送，直到松开。</p><p><img src="/./../photo/05_repeat_wave.png"></p><h2 id="3-编程思路"><a href="#3-编程思路" class="headerlink" title="3. 编程思路"></a>3. 编程思路</h2><p>使用中断来实现：</p><ul><li>GPIO引脚配置为双边沿触发中断</li><li>记录中断发生时的时间</li><li>等接到完整的中断后，解析数据</li></ul><p><img src="/./../photo/06_use_irq.png" alt="image-20220106191056211"></p><h2 id="4-编程"><a href="#4-编程" class="headerlink" title="4. 编程"></a>4. 编程</h2><h3 id="4-1-中断方式"><a href="#4-1-中断方式" class="headerlink" title="4.1 中断方式"></a>4.1 中断方式</h3><h3 id="4-2-输入子系统"><a href="#4-2-输入子系统" class="headerlink" title="4.2 输入子系统"></a>4.2 输入子系统</h3><h1 id="24-实战-I2C设备驱动程序开发1-AT24C02程序框架"><a href="#24-实战-I2C设备驱动程序开发1-AT24C02程序框架" class="headerlink" title="24 实战_I2C设备驱动程序开发1_AT24C02程序框架"></a>24 实战_I2C设备驱动程序开发1_AT24C02程序框架</h1><h2 id="1-检查i2c1总线下的设备是否存在"><a href="#1-检查i2c1总线下的设备是否存在" class="headerlink" title="1 检查i2c1总线下的设备是否存在"></a>1 检查i2c1总线下的设备是否存在</h2><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">i2cdetect</span> -y <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h2 id="2-i2c和输入系统的结合"><a href="#2-i2c和输入系统的结合" class="headerlink" title="2 i2c和输入系统的结合"></a>2 i2c和输入系统的结合</h2><ul><li>GT9xx</li><li>FT5x06</li></ul><h1 id="27-实战-SPI设备驱动开发1-OLED屏幕"><a href="#27-实战-SPI设备驱动开发1-OLED屏幕" class="headerlink" title="27 实战_SPI设备驱动开发1_OLED屏幕"></a>27 实战_SPI设备驱动开发1_OLED屏幕</h1>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux卡片电脑</title>
    <link href="/2024/06/28/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/"/>
    <url>/2024/06/28/Linux%E5%8D%A1%E7%89%87%E7%94%B5%E8%84%91/</url>
    
    <content type="html"><![CDATA[<h1 id="1-硬件（Hardware）"><a href="#1-硬件（Hardware）" class="headerlink" title="1 硬件（Hardware）"></a>1 硬件（Hardware）</h1><blockquote><p>原理图部分太多，就不一一展示了！</p></blockquote><h2 id="1-1-实物图"><a href="#1-1-实物图" class="headerlink" title="1.1 实物图"></a>1.1 实物图</h2><p><img src="/./../photo/image-20240301132644102.png" alt="image-20240301132644102"></p><p><img src="/./../photo/image-20240301132711043.png" alt="image-20240301132711043"></p><p><img src="/./../photo/image-20240301132724403.png" alt="image-20240301132724403"></p><h2 id="1-2-核心板-PCB"><a href="#1-2-核心板-PCB" class="headerlink" title="1.2 核心板 PCB"></a>1.2 核心板 PCB</h2><h3 id="Top1层"><a href="#Top1层" class="headerlink" title="Top1层"></a>Top1层</h3><p><img src="/./../photo/image-20240301130613104.png" alt="image-20240301130613104"></p><h3 id="Gnd2层"><a href="#Gnd2层" class="headerlink" title="Gnd2层"></a>Gnd2层</h3><p><img src="/./../photo/image-20240301130710279.png" alt="image-20240301130710279"></p><h3 id="Power3层"><a href="#Power3层" class="headerlink" title="Power3层"></a>Power3层</h3><p><img src="/./../photo/image-20240301130807506.png" alt="image-20240301130807506"></p><h3 id="Bottom4层"><a href="#Bottom4层" class="headerlink" title="Bottom4层"></a>Bottom4层</h3><p><img src="/./../photo/image-20240301130819357.png" alt="image-20240301130819357"></p><h3 id="3D视图"><a href="#3D视图" class="headerlink" title="3D视图"></a>3D视图</h3><p><img src="/./../photo/image-20240301130918229.png" alt="image-20240301130918229"></p><h3 id="实物图"><a href="#实物图" class="headerlink" title="实物图"></a>实物图</h3><p><img src="/./../photo/image-20240301132034603.png" alt="image-20240301132034603"></p><h2 id="1-3-扩展板1-PCB"><a href="#1-3-扩展板1-PCB" class="headerlink" title="1.3 扩展板1 PCB"></a>1.3 扩展板1 PCB</h2><h3 id="Top1层-1"><a href="#Top1层-1" class="headerlink" title="Top1层"></a>Top1层</h3><p><img src="/./../photo/image-20240301132122695.png" alt="image-20240301132122695"></p><h3 id="Gnd2层-1"><a href="#Gnd2层-1" class="headerlink" title="Gnd2层"></a>Gnd2层</h3><p><img src="/./../photo/image-20240301132132255.png" alt="image-20240301132132255"></p><h3 id="Power3层-1"><a href="#Power3层-1" class="headerlink" title="Power3层"></a>Power3层</h3><p><img src="/./../photo/image-20240301132146304.png" alt="image-20240301132146304"></p><h3 id="Bottom4层-1"><a href="#Bottom4层-1" class="headerlink" title="Bottom4层"></a>Bottom4层</h3><p><img src="/./../photo/image-20240301132212856.png" alt="image-20240301132212856"></p><h3 id="3D视图-1"><a href="#3D视图-1" class="headerlink" title="3D视图"></a>3D视图</h3><p><img src="/./../photo/image-20240301132315207.png" alt="image-20240301132315207"></p><h3 id="实物图-1"><a href="#实物图-1" class="headerlink" title="实物图"></a>实物图</h3><p><img src="/./../photo/image-20240301132229665.png" alt="image-20240301132229665"></p><h2 id="1-4-扩展板2-PCB"><a href="#1-4-扩展板2-PCB" class="headerlink" title="1.4 扩展板2 PCB"></a>1.4 扩展板2 PCB</h2><h3 id="Top1层-2"><a href="#Top1层-2" class="headerlink" title="Top1层"></a>Top1层</h3><p><img src="/./../photo/image-20240301132937659.png" alt="image-20240301132937659"></p><h3 id="Gnd2层-2"><a href="#Gnd2层-2" class="headerlink" title="Gnd2层"></a>Gnd2层</h3><p><img src="/./../photo/image-20240301132949897.png" alt="image-20240301132949897"></p><h3 id="Power3层-2"><a href="#Power3层-2" class="headerlink" title="Power3层"></a>Power3层</h3><p><img src="/./../photo/image-20240301133002855.png" alt="image-20240301133002855"></p><h3 id="Bottom4层-2"><a href="#Bottom4层-2" class="headerlink" title="Bottom4层"></a>Bottom4层</h3><p><img src="/./../photo/image-20240301133014067.png" alt="image-20240301133014067"></p><h3 id="3D视图-2"><a href="#3D视图-2" class="headerlink" title="3D视图"></a>3D视图</h3><p><img src="/./../photo/image-20240301133037486.png" alt="image-20240301133037486"></p><h3 id="实物图-2"><a href="#实物图-2" class="headerlink" title="实物图"></a>实物图</h3><p><img src="/./../photo/image-20240301133057512.png" alt="image-20240301133057512"></p><h1 id="2-系统移植"><a href="#2-系统移植" class="headerlink" title="2 系统移植"></a>2 系统移植</h1><h2 id="2-1-安装交叉编译器"><a href="#2-1-安装交叉编译器" class="headerlink" title="2.1 安装交叉编译器"></a>2.1 安装交叉编译器</h2><h4 id="1-下载交叉编译器-arm-cortexa9-linux-gnueabihf-4-9-3-tar-xz，然后解压编译器"><a href="#1-下载交叉编译器-arm-cortexa9-linux-gnueabihf-4-9-3-tar-xz，然后解压编译器" class="headerlink" title="1 下载交叉编译器 arm-cortexa9-linux-gnueabihf-4.9.3.tar.xz，然后解压编译器"></a>1 下载交叉编译器 arm-cortexa9-linux-gnueabihf-4.9.3.tar.xz，然后解压编译器</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mkdir</span> -p /opt/YuanPi-Plus/toolchain<br>tar xf arm-cortexa9-linux-gnueabihf-4.9.3.tar.xz -C /opt/FriendlyARM/toolchain/<br></code></pre></td></tr></table></figure><h4 id="2-将编译器的路径加入到-PATH-中，vi-bashrc，在末尾加入以下内容："><a href="#2-将编译器的路径加入到-PATH-中，vi-bashrc，在末尾加入以下内容：" class="headerlink" title="2 将编译器的路径加入到 PATH 中，vi ~&#x2F;.bashrc，在末尾加入以下内容："></a>2 将编译器的路径加入到 PATH 中，vi ~&#x2F;.bashrc，在末尾加入以下内容：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">PATH</span>=/opt/FriendlyARM/toolchain/4.9.3/bin:$PATH<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">GCC_COLORS</span>=auto<br><span class="hljs-comment"># 执行一下~/.bashrc脚本，让设置立即在当前shell窗口中生效，注意&quot;.&quot;后面有个空格：. ~/.bashrc</span><br></code></pre></td></tr></table></figure><h4 id="3-这个编译器是-64-位的，不能在-32-位的-Linux-系统上运行，安装完成后，验证是否安装成功："><a href="#3-这个编译器是-64-位的，不能在-32-位的-Linux-系统上运行，安装完成后，验证是否安装成功：" class="headerlink" title="3 这个编译器是 64 位的，不能在 32 位的 Linux 系统上运行，安装完成后，验证是否安装成功："></a>3 这个编译器是 64 位的，不能在 32 位的 Linux 系统上运行，安装完成后，验证是否安装成功：</h4><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs subunit">arm-linux-gcc -v<br># 显示出gcc version 4.9.3 (ctng<span class="hljs-string">-1</span>.21.0<span class="hljs-string">-229</span>g-FA)即成功了<br></code></pre></td></tr></table></figure><h2 id="2-2-编译适配-U-boot"><a href="#2-2-编译适配-U-boot" class="headerlink" title="2.2 编译适配 U-boot"></a>2.2 编译适配 U-boot</h2><h4 id="1-下载-U-boot-源码，移植自FriendlyARM的仓库"><a href="#1-下载-U-boot-源码，移植自FriendlyARM的仓库" class="headerlink" title="1 下载 U-boot 源码，移植自FriendlyARM的仓库"></a>1 下载 U-boot 源码，移植自<a href="https://gitee.com/link?target=https://github.com/friendlyarm/u-boot.git">FriendlyARM</a>的仓库</h4><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">git <span class="hljs-keyword">clone</span> <span class="hljs-title">https</span>://github.com/friendlyarm/u-boot.git -b sunxi-v2017.x --depth <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="2-安装-Python-库："><a href="#2-安装-Python-库：" class="headerlink" title="2 安装 Python 库："></a>2 安装 Python 库：</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">apt-<span class="hljs-built_in">get</span> install swig python-<span class="hljs-built_in">dev</span> python3-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><h4 id="3-使用-nanopi-h3-defconfig-配置："><a href="#3-使用-nanopi-h3-defconfig-配置：" class="headerlink" title="3 使用 nanopi_h3_defconfig 配置："></a>3 使用 nanopi_h3_defconfig 配置：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 修改DDR3频率为768M，经过测试我的硬件最大支持这个频率</span><br>vim configs/nanopi_h3_defconfig<br><span class="hljs-comment"># 将 CONFIG_DRAM_CLK=408 修改为 CONFIG_DRAM_CLK=768</span><br>make nanopi_h3_defconfig <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-<br></code></pre></td></tr></table></figure><h4 id="4-编译-U-boot："><a href="#4-编译-U-boot：" class="headerlink" title="4 编译 U-boot："></a>4 编译 U-boot：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux- -j12<br><span class="hljs-comment"># 编译成功后会生成文件u-boot-sunxi-with-spl.bin</span><br></code></pre></td></tr></table></figure><h4 id="5-更新-SD-上的-U-boot："><a href="#5-更新-SD-上的-U-boot：" class="headerlink" title="5 更新 SD 上的 U-boot："></a>5 更新 SD 上的 U-boot：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">dd <span class="hljs-attribute">if</span>=u-boot-sunxi-with-spl.bin <span class="hljs-attribute">of</span>=/dev/sdX <span class="hljs-attribute">bs</span>=1024 <span class="hljs-attribute">seek</span>=8<br>sync &amp;&amp; eject /dev/sdX<br><span class="hljs-comment"># /dev/sdX替换为实际的TF卡设备文件名。</span><br><span class="hljs-comment"># sync命令可以确保数据成功写到TF卡中，eject命令用于弹出TF卡。</span><br></code></pre></td></tr></table></figure><h4 id="6-SD-卡运行系统时，可以先用-scp-命令拷贝-u-boot-sunxi-with-spl-bin-到开发板上，然后用-dd-命令更新-SD-卡上的-U-boot"><a href="#6-SD-卡运行系统时，可以先用-scp-命令拷贝-u-boot-sunxi-with-spl-bin-到开发板上，然后用-dd-命令更新-SD-卡上的-U-boot" class="headerlink" title="6 SD 卡运行系统时，可以先用 scp 命令拷贝 u-boot-sunxi-with-spl.bin 到开发板上，然后用 dd 命令更新 SD 卡上的 U-boot:"></a>6 SD 卡运行系统时，可以先用 scp 命令拷贝 u-boot-sunxi-with-spl.bin 到开发板上，然后用 dd 命令更新 SD 卡上的 U-boot:</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">scp u-boot-sunxi-with-spl.bin root@192.168.0.106:/root/<br>dd <span class="hljs-attribute">if</span>=/root/u-boot-sunxi-with-spl.bin <span class="hljs-attribute">of</span>=/dev/mmcblk0 <span class="hljs-attribute">bs</span>=1024 <span class="hljs-attribute">seek</span>=8<br><span class="hljs-comment"># root@后面替换成板子上的IP地址，EMMC也可以用此方法</span><br><span class="hljs-comment"># H3的启动设备的设备节点总是/dev/mmcblk0</span><br></code></pre></td></tr></table></figure><h4 id="7-成功效果如下："><a href="#7-成功效果如下：" class="headerlink" title="7 成功效果如下："></a>7 成功效果如下：</h4><p><img src="/./../photo/2.%E8%BD%AF%E4%BB%B6%E9%80%82%E9%85%8D1.png" alt="img"></p><h2 id="2-3-编译适配-Linux-内核"><a href="#2-3-编译适配-Linux-内核" class="headerlink" title="2.3 编译适配 Linux 内核"></a>2.3 编译适配 Linux 内核</h2><h4 id="1-下载-Linux-内核源码，移植自FriendlyARM的仓库"><a href="#1-下载-Linux-内核源码，移植自FriendlyARM的仓库" class="headerlink" title="1 下载 Linux 内核源码，移植自FriendlyARM的仓库"></a>1 下载 Linux 内核源码，移植自<a href="https://gitee.com/link?target=https://github.com/friendlyarm/u-boot.git">FriendlyARM</a>的仓库</h4><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> clone https://github.com/friendlyarm/linux.git -b sunxi-<span class="hljs-number">4</span>.<span class="hljs-number">14</span>.y --depth <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="2-默认配置先跑起来："><a href="#2-默认配置先跑起来：" class="headerlink" title="2 默认配置先跑起来："></a>2 默认配置先跑起来：</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> install u-boot-tools<br>touch .scmversion<br>make sunxi_defconfig <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-<br>make zImage dtbs <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-<br><span class="hljs-comment"># 编译完成后会在arch/arm/boot/目录下生成zImage，在arch/arm/boot/dts/目录下生成dtb文件</span><br></code></pre></td></tr></table></figure><h4 id="3-更新-SD-上的-zImage-和-dtb-文件：假设-SD-卡的-boot-分区挂载在-media-SD-boot"><a href="#3-更新-SD-上的-zImage-和-dtb-文件：假设-SD-卡的-boot-分区挂载在-media-SD-boot" class="headerlink" title="3 更新 SD 上的 zImage 和 dtb 文件：假设 SD 卡的 boot 分区挂载在 &#x2F;media&#x2F;SD&#x2F;boot&#x2F;"></a>3 更新 SD 上的 zImage 和 dtb 文件：假设 SD 卡的 boot 分区挂载在 &#x2F;media&#x2F;SD&#x2F;boot&#x2F;</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cp</span> <span class="hljs-built_in">arch</span>/arm/boot/zImage /media/SD/boot/<br><span class="hljs-built_in">cp</span> <span class="hljs-built_in">arch</span>/arm/boot/dts/sun8i-*-nanopi-*.dtb /media/SD/boot/<br><span class="hljs-comment"># 也可以用scp命令通过网络更新：</span><br>scp <span class="hljs-built_in">arch</span>/arm/boot/zImage root@192.168.31.134:/boot<br>scp <span class="hljs-built_in">arch</span>/arm/boot/dts/sun8i-*-nanopi-*.dtb root@192.168.31.134:/boot<br></code></pre></td></tr></table></figure><h4 id="4-bootargs-与-bootcmd：全志-H3-使用-boot-cmd-生成-boot-scr-来描述配置，boot-cmd："><a href="#4-bootargs-与-bootcmd：全志-H3-使用-boot-cmd-生成-boot-scr-来描述配置，boot-cmd：" class="headerlink" title="4 bootargs 与 bootcmd：全志 H3 使用 boot.cmd 生成 boot.scr 来描述配置，boot.cmd："></a>4 bootargs 与 bootcmd：全志 H3 使用 boot.cmd 生成 boot.scr 来描述配置，boot.cmd：</h4><p><img src="/./../photo/2.%E8%BD%AF%E4%BB%B6%E9%80%82%E9%85%8D2.png" alt="img"></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Recompile with: mkimage -C none -A arm -T script -d boot.cmd boot.scr CPU=H3</span><br><span class="hljs-comment"># OS=friendlycore/ubuntu-oled/ubuntu-wifiap/openwrt/debian/debian-nas...</span><br> <br> echo <span class="hljs-string">&quot;running boot.scr&quot;</span><br> setenv fsck.repair <span class="hljs-literal">yes</span><br> setenv ramdisk rootfs.cpio.gz<br> setenv kernel zImage<br> <br> setenv env_addr 0x43000000<br> setenv kernel_addr 0x46000000<br> setenv ramdisk_addr 0x47000000<br> setenv dtb_addr 0x48000000<br> <br> fatload mmc 0 <span class="hljs-variable">$&#123;kernel_addr&#125;</span> <span class="hljs-variable">$&#123;kernel&#125;</span><br> fatload mmc 0 <span class="hljs-variable">$&#123;ramdisk_addr&#125;</span> <span class="hljs-variable">$&#123;ramdisk&#125;</span><br> setenv ramdisk_size <span class="hljs-variable">$&#123;filesize&#125;</span><br> <br> fatload mmc 0 <span class="hljs-variable">$&#123;dtb_addr&#125;</span> sun8i-h3-YuanPi-plus.dtb<br> fdt addr <span class="hljs-variable">$&#123;dtb_addr&#125;</span><br> <br> # setup MAC<span class="hljs-built_in"> address</span><br><span class="hljs-built_in"></span> fdt <span class="hljs-built_in">set</span> ethernet0 local-mac-address <span class="hljs-variable">$&#123;mac_node&#125;</span><br> <br> # setup boot_device<br> fdt <span class="hljs-built_in">set</span> mmc0 boot_device &lt;1&gt;<br> <br> setenv fbcon map:1<br> <br> setenv overlayfs <span class="hljs-attribute">data</span>=/dev/mmcblk0p3<br> #setenv hdmi_res drm_kms_helper.<span class="hljs-attribute">edid_firmware</span>=HDMI-A-1:edid/1280x720.bin <span class="hljs-attribute">video</span>=HDMI-A-1:1280x720@60<br> <br> setenv bootargs <span class="hljs-attribute">console</span>=tty1 <span class="hljs-attribute">console</span>=ttyS0,115200 earlyprintk <span class="hljs-attribute">root</span>=/dev/mmcblk0p2 <span class="hljs-attribute">rootfstype</span>=ext4 rw rootwait fsck.<span class="hljs-attribute">repair</span>=<span class="hljs-variable">$&#123;fsck.repair&#125;</span> <span class="hljs-attribute">panic</span>=10 <span class="hljs-variable">$&#123;extra&#125;</span> <span class="hljs-attribute">fbcon</span>=<span class="hljs-variable">$&#123;fbcon&#125;</span> <span class="hljs-variable">$&#123;hdmi_res&#125;</span> <span class="hljs-variable">$&#123;overlayfs&#125;</span><br> bootz <span class="hljs-variable">$&#123;kernel_addr&#125;</span> <span class="hljs-variable">$&#123;ramdisk_addr&#125;</span>:<span class="hljs-variable">$&#123;ramdisk_size&#125;</span> <span class="hljs-variable">$&#123;dtb_addr&#125;</span><br><br></code></pre></td></tr></table></figure><h4 id="5-boot-cmd-–-boot-scr：将-boot-scr-也放入-SD-卡的-boot-中即可"><a href="#5-boot-cmd-–-boot-scr：将-boot-scr-也放入-SD-卡的-boot-中即可" class="headerlink" title="5 boot.cmd –&gt; boot.scr：将 boot.scr 也放入 SD 卡的 &#x2F;boot 中即可"></a>5 boot.cmd –&gt; boot.scr：将 boot.scr 也放入 SD 卡的 &#x2F;boot 中即可</h4><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">mkimage -C none -A arm -T <span class="hljs-keyword">script </span>-d <span class="hljs-keyword">boot.cmd </span><span class="hljs-keyword">boot.scr </span>CPU=H3<br></code></pre></td></tr></table></figure><h2 id="2-4-根文件系统"><a href="#2-4-根文件系统" class="headerlink" title="2.4 根文件系统"></a>2.4 根文件系统</h2><h4 id="1-根文件系统解压到-SD-卡："><a href="#1-根文件系统解压到-SD-卡：" class="headerlink" title="1 根文件系统解压到 SD 卡："></a>1 根文件系统解压到 SD 卡：</h4><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo tar -xvf rootfs.tar -C <span class="hljs-regexp">/media/</span>qing<span class="hljs-regexp">/rootfs/</span>  <br></code></pre></td></tr></table></figure><h4 id="2-编译和更新驱动模块：更新-SD-卡上-rootfs-的驱动模块"><a href="#2-编译和更新驱动模块：更新-SD-卡上-rootfs-的驱动模块" class="headerlink" title="2 编译和更新驱动模块：更新 SD 卡上 rootfs 的驱动模块:"></a>2 编译和更新驱动模块：更新 SD 卡上 rootfs 的驱动模块:</h4><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">make modules <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-<br>make modules_install <span class="hljs-attribute">INSTALL_MOD_PATH</span>=/media/SD/rootfs/ <span class="hljs-attribute">ARCH</span>=arm <span class="hljs-attribute">CROSS_COMPILE</span>=arm-linux-<br></code></pre></td></tr></table></figure><blockquote><p>make modules_install 命令的作用是：</p><ol><li>将编译好的内核模块从内核源代码目录 copy 到 &#x2F;lib&#x2F;modules 下。也可自己指定 ko 安装路径，在交叉编译的情况下，需要将 ko 模块安装到 rootfs。也即：INSTALL_MOD_PATH&#x3D;&#x2F;media&#x2F;SD&#x2F;rootfs&#x2F;。</li><li>运行 modules_install 的另一个作用是会运行 depmod 去生成 modules.dep 文件，该文件记录了模块之间的依赖关系。这样当 modprobe XXX 的时候就能够把 XXX 所依赖的模块一并加载了。</li></ol></blockquote><h2 id="2-5-挂载-nfs"><a href="#2-5-挂载-nfs" class="headerlink" title="2.5 挂载 nfs"></a>2.5 挂载 nfs</h2><ol><li>ubuntu 先安装 nfs 服务：apt-get install nfs-kernel-server rpcbind</li><li>配置相关文件夹为 nfs 文件夹：vi &#x2F;etc&#x2F;exports</li><li>在最后一行加上文件夹路径：&#x2F;home&#x2F;qing&#x2F;work&#x2F;nfs&#x2F;rootfs_friendlycore-focal_4.14 *(rw,sync,no_root_squash)</li><li>然后重启 ubuntu 服务：&#x2F;etc&#x2F;init.d&#x2F;nfs-kernel-server restart</li><li>被挂载的文件夹最好 ：chmod 777 xxx&#x2F;</li><li>在开发板里面也要安装 nfs 服务：apt-get install nfs-kernel-server rpcbind</li><li>重启开发板的 nfs 服务：&#x2F;etc&#x2F;init.d&#x2F;nfs-kernel-server restart</li><li>挂载：mount -t nfs <em><strong>ubuntu-IP</strong></em>:&#x2F;home&#x2F;qing&#x2F;work&#x2F;nfs&#x2F;rootfs_friendlycore-focal_4.14&#x2F; &#x2F;mnt&#x2F; -o nolock</li></ol><p>参考 OrangePi，以太网要修改 sun8i-h3-YuanPi-plus.dts：因为友善 M1-Plus 用了 RTL8211E，我们是直连的。</p><h1 id="3-软件适配"><a href="#3-软件适配" class="headerlink" title="3.软件适配"></a>3.软件适配</h1><h2 id="3-1-st7789v-彩屏-SPI"><a href="#3-1-st7789v-彩屏-SPI" class="headerlink" title="3.1 st7789v 彩屏 (SPI)"></a>3.1 st7789v 彩屏 (SPI)</h2><h3 id="3-1-1-修改设备树"><a href="#3-1-1-修改设备树" class="headerlink" title="3.1.1 修改设备树"></a>3.1.1 修改设备树</h3><h4 id="1-首先复制一份-sun8i-h3-nanopi-m1-plus-dts-重命名为-sun8i-h3-YuanPi-plus-dts，并修改设备树目录下的-Makefile-加上我们的设备树。最后在-sun8i-h3-YuanPi-plus-dts-中添加："><a href="#1-首先复制一份-sun8i-h3-nanopi-m1-plus-dts-重命名为-sun8i-h3-YuanPi-plus-dts，并修改设备树目录下的-Makefile-加上我们的设备树。最后在-sun8i-h3-YuanPi-plus-dts-中添加：" class="headerlink" title="1 首先复制一份 sun8i-h3-nanopi-m1-plus.dts 重命名为 sun8i-h3-YuanPi-plus.dts，并修改设备树目录下的 Makefile 加上我们的设备树。最后在 sun8i-h3-YuanPi-plus.dts 中添加："></a>1 首先复制一份 sun8i-h3-nanopi-m1-plus.dts 重命名为 sun8i-h3-YuanPi-plus.dts，并修改设备树目录下的 Makefile 加上我们的设备树。最后在 sun8i-h3-YuanPi-plus.dts 中添加：</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">&amp;spi0 &#123;<br>    pinctrl-0 = <span class="hljs-variable">&lt;&amp;spi0_pins &amp;spi0_cs_pins&gt;</span>;<br>    cs-gpios = <span class="hljs-variable">&lt;&amp;pio 2 3 GPIO_ACTIVE_HIGH&gt;</span>;<br><br>    st7789vw: st7789vw<span class="hljs-meta">@0&#123;</span><br>    compatible =<span class="hljs-string">&quot;sitronix,st7789vw&quot;</span>;<br>    reg = <span class="hljs-variable">&lt;0&gt;</span>;<br>    status = <span class="hljs-string">&quot;okay&quot;</span>;<br>    spi-max-frequency = <span class="hljs-variable">&lt;50000000&gt;</span>;<br>    buswidth = <span class="hljs-variable">&lt;8&gt;</span>;<br>    rotate = <span class="hljs-variable">&lt;0&gt;</span>;<br>    fps = <span class="hljs-variable">&lt;60&gt;</span>;<br>    rgb;<br>    spi-cpol;<br>    spi-cpha;<br>    dc-gpios    = <span class="hljs-variable">&lt;&amp;pio 0 0 GPIO_ACTIVE_HIGH&gt;</span>; /<span class="hljs-symbol">*</span> PA0 <span class="hljs-symbol">*</span>/<br>    reset-gpios = <span class="hljs-variable">&lt;&amp;pio 0 1 GPIO_ACTIVE_HIGH&gt;</span>; /<span class="hljs-symbol">*</span> PA1 <span class="hljs-symbol">*</span>/<br>    debug = <span class="hljs-variable">&lt;0x00&gt;</span>;<br>    &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="2-修改-sun8i-h3-nanopi-dtsi，将-spi0-结点下的设备都-disabled："><a href="#2-修改-sun8i-h3-nanopi-dtsi，将-spi0-结点下的设备都-disabled：" class="headerlink" title="2 修改 sun8i-h3-nanopi.dtsi，将 spi0 结点下的设备都 disabled："></a>2 修改 sun8i-h3-nanopi.dtsi，将 spi0 结点下的设备都 disabled：</h4><p><img src="/./../photo/3.1.1%E4%BF%AE%E6%94%B9%E8%AE%BE%E5%A4%87%E6%A0%912.png" alt="img"></p><h3 id="3-1-2-修改-kernel"><a href="#3-1-2-修改-kernel" class="headerlink" title="3.1.2 修改 kernel"></a>3.1.2 修改 kernel</h3><blockquote><p>**fbtft 的作用:**驱动各种 spi 接口的 TFT-LCD。</p><p><strong>如果要移植其他显示屏，我们一般只需要重写init_display，和set_addr_win，分别对于初始化和设置写入范围。</strong></p></blockquote><h4 id="1-make-menuconfig-使能-fbtft-框架，并勾选-fb-st7789vw-c："><a href="#1-make-menuconfig-使能-fbtft-框架，并勾选-fb-st7789vw-c：" class="headerlink" title="1 make menuconfig 使能 fbtft 框架，并勾选 fb_st7789vw.c："></a>1 make menuconfig 使能 fbtft 框架，并勾选 fb_st7789vw.c：</h4><p><img src="/./../photo/3.1.2%E4%BF%AE%E6%94%B9kernel1.png" alt="img"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust">Device Drivers  --<span class="hljs-punctuation">-&gt;</span><br>    [*] Staging drivers  --<span class="hljs-punctuation">-&gt;</span><br>        &lt;*&gt;   Support <span class="hljs-keyword">for</span> <span class="hljs-title class_">small</span> TFT LCD display modules  --<span class="hljs-punctuation">-&gt;</span><br>            &lt;*&gt;   Support sysfs <span class="hljs-keyword">for</span> <span class="hljs-title class_">small</span> TFT LCD display modules<br>            &lt;*&gt;   FB driver <span class="hljs-keyword">for</span> <span class="hljs-title class_">the</span> ST7789VW LCD Controller <br>            &lt;*&gt;   Generic FB driver <span class="hljs-keyword">for</span> <span class="hljs-title class_">TFT</span> LCD displays<br>            &lt;*&gt;   Module to <span class="hljs-keyword">for</span> <span class="hljs-title class_">adding</span> FBTFT devices<br></code></pre></td></tr></table></figure><h4 id="2-修改-drivers-staging-fbtft-fb-st7789vw-c："><a href="#2-修改-drivers-staging-fbtft-fb-st7789vw-c：" class="headerlink" title="2 修改 drivers&#x2F;staging&#x2F;fbtft&#x2F;fb_st7789vw.c："></a>2 修改 drivers&#x2F;staging&#x2F;fbtft&#x2F;fb_st7789vw.c：</h4><p>我们的屏幕不需要偏移，将偏移去除：</p><p><img src="/./../photo/3.1.2%E4%BF%AE%E6%94%B9kernel2.png" alt="3.1.2修改kernel2"></p><p>修改分辨率：</p><p><img src="/3.1.2%E4%BF%AE%E6%94%B9kernel3.png" alt="3.1.2修改kernel3"></p><p>最后修改初始化代码：将 init_display (struct fbtft_par *par) 中初始化代码换成当下屏幕的即可。</p><h3 id="3-1-3-修改-bootargs"><a href="#3-1-3-修改-bootargs" class="headerlink" title="3.1.3 修改 bootargs"></a>3.1.3 修改 bootargs</h3><h4 id="修改-boot-cmd-–-boot-scr，让屏幕作为-console："><a href="#修改-boot-cmd-–-boot-scr，让屏幕作为-console：" class="headerlink" title="修改 boot.cmd –&gt; boot.scr，让屏幕作为 console："></a>修改 boot.cmd –&gt; boot.scr，让屏幕作为 console：</h4><p><img src="/./../photo/3.1.3%E4%BF%AE%E6%94%B9bootargs1.png" alt="3.1.3修改bootargs1"></p><h3 id="3-1-4-编译烧录"><a href="#3-1-4-编译烧录" class="headerlink" title="3.1.4 编译烧录"></a>3.1.4 编译烧录</h3><p>编译出 zImage、sun8i-h3-YuanPi-plus.dtb、boot.scr，重新烧录，成功！</p><p><img src="/./../photo/image-20240301160315717.png" alt="image-20240301160315717"></p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h2 id="3-2-GT911-电容触摸-IIC"><a href="#3-2-GT911-电容触摸-IIC" class="headerlink" title="3.2 GT911 电容触摸 (IIC)"></a>3.2 GT911 电容触摸 (IIC)</h2><h3 id="3-2-1-修改设备树"><a href="#3-2-1-修改设备树" class="headerlink" title="3.2.1 修改设备树"></a>3.2.1 修改设备树</h3><p>GT911 使用的是 IIC 接口，可以设置中断模式，当有触摸动作则会触发中断，在中断中读取寄存器信息，通过 input 上报坐标，因为板子上的 i2c0 在硬件上已经上拉，所以设备树不用上拉，修改设备树如下：sun8i-h3-YuanPi-plus.dts</p><p><img src="/./../photo/3.2.1%E4%BF%AE%E6%94%B9%E8%AE%BE%E5%A4%87%E6%A0%911.png" alt="3.2.1修改设备树1"></p><h3 id="3-2-2-编写驱动"><a href="#3-2-2-编写驱动" class="headerlink" title="3.2.2 编写驱动"></a>3.2.2 编写驱动</h3><p>电容触摸屏驱动其实就是以下几种 linux 驱动框架的组合：</p><ol><li>IIC 设备驱动，因为电容触摸 IC 基本都是 IIC 接口的，因此大框架就是 IIC 设备驱动。</li><li>通过中断引脚 (INT) 向 内核上报触摸信息，因此需要用到中断驱动框架。坐标的上报在中断服务函数中完成。</li><li>触摸屏的坐标信息、屏幕按下和抬起信息都属于 input 子系统，因此向内核上报触摸屏坐标信息就得使用 input 子系统。只是我们得按照 linux 内核规定的规则来上报坐标信息。</li></ol><p>在实际驱动 GT911 需要注意如下几点：</p><ol><li>与其他的 IIC 设备不同，GT911 的器件地址需要根据初始化时序来确定，地址确定后才能用 i2cdetect 检测出地址。</li><li>当输出中断后请在一个中断周期内读走坐标并将 buffer status (0x814E) 写为 0，若未在中断内读走坐标，下次 IC 即使检测到坐标更新会再输出一个中断脉冲，但不更新坐标，如果一直没有读取坐标则会一直打脉冲，导致中断一直被触发。</li><li>我们的屏幕进行了旋转，所以读取出来的坐标也需要在软件上进行调整，如下：</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">我们的屏幕旋转了<span class="hljs-number">90</span>度，对应如下：<br>原先      --&gt;   旋转后   <br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)</span>     --&gt;</span>  (<span class="hljs-number">0</span>,<span class="hljs-number">240</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">240</span>,<span class="hljs-number">0</span>)</span>   --&gt;</span>  (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">0</span>,<span class="hljs-number">320</span>)</span>   --&gt;</span>  (<span class="hljs-number">320</span>,<span class="hljs-number">240</span>)<br><span class="hljs-function"><span class="hljs-params">(<span class="hljs-number">240</span>,<span class="hljs-number">320</span>)</span> --&gt;</span>  (<span class="hljs-number">320</span>,<span class="hljs-number">0</span>)<br>所以对应的调整关系是:<br><span class="hljs-function"><span class="hljs-params">(X,Y)</span>     --&gt;</span>  (Y,|X-<span class="hljs-number">240</span>|)<br></code></pre></td></tr></table></figure><p><em><strong>完整代码如下所示，相应注释已给出：</strong></em></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/kernel.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/init.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/module.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_device.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/slab.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mutex.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/mod_devicetable.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/bitops.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/jiffies.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/property.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/acpi.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/i2c.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/nvmem-provider.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/regmap.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/pm_runtime.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/gpio/consumer.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/uaccess.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/fs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/delay.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_gpio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/spinlock.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/atomic.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;asm/unaligned.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/mt.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/input/touchscreen.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/of_irq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;linux/interrupt.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GT_CTRL_REG         0X8040  <span class="hljs-comment">/* GT911控制寄存器         */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GT_9xx_CFGS_REG     0X8047  <span class="hljs-comment">/* GT9147配置起始地址寄存器    */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GT_1xx_CFGS_REG     0X8050  <span class="hljs-comment">/* GT1151配置起始地址寄存器    */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GT_PID_REG         0X8140  <span class="hljs-comment">/* GT911产品ID寄存器       */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GT_GSTID_REG         0X814E  <span class="hljs-comment">/* GT911当前检测到的触摸情况 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> GT_TP1_REG         0X814F  <span class="hljs-comment">/* 第一个触摸点数据地址 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_SUPPORT_POINTS      5       <span class="hljs-comment">/* 最多5点电容触摸 */</span></span><br><br><span class="hljs-type">const</span> u8 irq_table[] = &#123;IRQ_TYPE_EDGE_RISING, IRQ_TYPE_EDGE_FALLING, IRQ_TYPE_LEVEL_LOW, IRQ_TYPE_LEVEL_HIGH&#125;;  <span class="hljs-comment">/* 触发方式 */</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gt911_dev</span> &#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_desc</span>   *reset_pin;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gpio_desc</span>   *irq_pin;<br><span class="hljs-type">int</span> irqnum;<span class="hljs-comment">/* 中断号    */</span><br><span class="hljs-type">int</span> irqtype;<span class="hljs-comment">/* 中断类型         */</span><br><span class="hljs-type">int</span> max_x;<span class="hljs-comment">/* 最大横坐标   */</span><br><span class="hljs-type">int</span> max_y; <span class="hljs-comment">/* 最大纵坐标*/</span><br><span class="hljs-type">void</span> *private_data;<span class="hljs-comment">/* 私有数据 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">input_dev</span> *input;<span class="hljs-comment">/* input结构体 */</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_client</span> *client;<span class="hljs-comment">/* I2C客户端 */</span><br><br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">gt911_dev</span> gt911;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description     : 复位GT911</span><br><span class="hljs-comment"> * @param - client : 要操作的i2c</span><br><span class="hljs-comment"> * @param - multidev: 自定义的multitouch设备</span><br><span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gt911_reset</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-keyword">struct</span> gt911_dev *dev)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;reset_pin and int_pin = 0 hold 10ms!\n&quot;</span>);<br>    <span class="hljs-built_in">gpiod_set_value</span>(dev-&gt;reset_pin, <span class="hljs-number">0</span>); <span class="hljs-comment">//设低电平</span><br>    <span class="hljs-built_in">gpiod_set_value</span>(dev-&gt;irq_pin, <span class="hljs-number">0</span>);   <span class="hljs-comment">//设低电平</span><br>    <span class="hljs-built_in">mdelay</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;reset_pin = 1 hold 10ms!\n&quot;</span>);<br>    <span class="hljs-built_in">gpiod_set_value</span>(dev-&gt;reset_pin, <span class="hljs-number">1</span>); <span class="hljs-comment">//设高电平</span><br>    <span class="hljs-built_in">mdelay</span>(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;set int_pin as input!\n&quot;</span>);<br>    <span class="hljs-built_in">gpiod_direction_input</span>(dev-&gt;irq_pin);<br><br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;now gt911&#x27;s addr is 0xBA/0xBB, and i2c addr is 0x5d\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 向GT911多个寄存器写入数据，寄存器的地址指针会在写操作后自动加 1，所以当需要对连续地址的寄存器进行写操作时，可以在一次写操作中连续写入。</span><br><span class="hljs-comment"> * @param - dev:  GT911设备</span><br><span class="hljs-comment"> * @param - reg:  要写入的寄存器首地址</span><br><span class="hljs-comment"> * @param - val:  要写入的数据缓冲区</span><br><span class="hljs-comment"> * @param - len:  要写入的数据长度</span><br><span class="hljs-comment"> * @return   :   操作结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> s32 <span class="hljs-title">gt911_write_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gt911_dev *dev, u16 reg, u8 *buf, u8 len)</span></span><br><span class="hljs-function"></span>&#123;<br>u8 b[<span class="hljs-number">256</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_msg</span> msg;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_client</span> *client = (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;client;<br><br>b[<span class="hljs-number">0</span>] = reg &gt;&gt; <span class="hljs-number">8</span>;<span class="hljs-comment">/* 寄存器首地址低8位 */</span><br>    b[<span class="hljs-number">1</span>] = reg &amp; <span class="hljs-number">0XFF</span>;<span class="hljs-comment">/* 寄存器首地址高8位 */</span><br><span class="hljs-built_in">memcpy</span>(&amp;b[<span class="hljs-number">2</span>],buf,len);<span class="hljs-comment">/* 将要写入的数据拷贝到数组b里面 */</span><br><br>msg.addr = client-&gt;addr;<span class="hljs-comment">/* gt911地址 */</span><br>msg.flags = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 标记为写数据 */</span><br><br>msg.buf = b;<span class="hljs-comment">/* 要写入的数据缓冲区 */</span><br>msg.len = len + <span class="hljs-number">2</span>;<span class="hljs-comment">/* 要写入的数据长度，总长度要加上两个寄存器 */</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-built_in">i2c_transfer</span>(client-&gt;adapter, &amp;msg, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description: 从GT911读取多个寄存器数据</span><br><span class="hljs-comment"> * @param - dev:  GT911设备</span><br><span class="hljs-comment"> * @param - reg:  要读取的寄存器首地址</span><br><span class="hljs-comment"> * @param - buf:  读取到的数据</span><br><span class="hljs-comment"> * @param - len:  要读取的数据长度</span><br><span class="hljs-comment"> * @return : 操作结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gt911_read_regs</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> gt911_dev *dev, u16 reg, u8 *buf, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret;<br>    u8 regdata[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_msg</span> msg[<span class="hljs-number">2</span>];<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_client</span> *client = (<span class="hljs-keyword">struct</span> i2c_client *)dev-&gt;client;<br>    <br>    <span class="hljs-comment">/* GT911寄存器长度为2个字节 */</span><br>    regdata[<span class="hljs-number">0</span>] = reg &gt;&gt; <span class="hljs-number">8</span>;<br>    regdata[<span class="hljs-number">1</span>] = reg &amp; <span class="hljs-number">0xFF</span>;<br><br><span class="hljs-comment">/* msg[0]为发送要读取的首地址 */</span><br>msg[<span class="hljs-number">0</span>].addr = client-&gt;addr;<span class="hljs-comment">/* GT911的i2c地址 */</span><br>msg[<span class="hljs-number">0</span>].flags = !I2C_M_RD;<span class="hljs-comment">/* 标记为发送数据 */</span><br>msg[<span class="hljs-number">0</span>].buf = &amp;regdata[<span class="hljs-number">0</span>];<span class="hljs-comment">/* 读取的首地址 */</span><br>msg[<span class="hljs-number">0</span>].len = <span class="hljs-number">2</span>;<span class="hljs-comment">/* reg长度*/</span><br><br><span class="hljs-comment">/* msg[1]读取数据 */</span><br>msg[<span class="hljs-number">1</span>].addr = client-&gt;addr;<span class="hljs-comment">/* GT911的i2c地址 */</span><br>msg[<span class="hljs-number">1</span>].flags = I2C_M_RD;<span class="hljs-comment">/* 标记为读取数据*/</span><br>msg[<span class="hljs-number">1</span>].buf = buf;<span class="hljs-comment">/* 读取数据缓冲区 */</span><br>msg[<span class="hljs-number">1</span>].len = len;<span class="hljs-comment">/* 要读取的数据长度*/</span><br><br>ret = <span class="hljs-built_in">i2c_transfer</span>(client-&gt;adapter, msg, <span class="hljs-number">2</span>);<br><span class="hljs-keyword">if</span>(ret == <span class="hljs-number">2</span>) &#123;<br>ret = <span class="hljs-number">0</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>ret = -EREMOTEIO;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description     : GT911读取固件</span><br><span class="hljs-comment"> * @param - client : 要操作的i2c</span><br><span class="hljs-comment"> * @param - multidev: 自定义的multitouch设备</span><br><span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gt911_read_firmware</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-keyword">struct</span> gt911_dev *dev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>, version = <span class="hljs-number">0</span>;<br>u16 id = <span class="hljs-number">0</span>;<br>u8 data[<span class="hljs-number">7</span>]=&#123;<span class="hljs-number">0</span>&#125;;<br><span class="hljs-type">char</span> id_str[<span class="hljs-number">5</span>];<br>ret = <span class="hljs-built_in">gt911_read_regs</span>(dev, GT_PID_REG, data, <span class="hljs-number">6</span>);<br><span class="hljs-keyword">if</span> (ret) &#123;<br><span class="hljs-built_in">dev_err</span>(&amp;client-&gt;dev, <span class="hljs-string">&quot;Unable to read PID.\n&quot;</span>);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><span class="hljs-built_in">memcpy</span>(id_str, data, <span class="hljs-number">4</span>);<br>id_str[<span class="hljs-number">4</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">kstrtou16</span>(id_str, <span class="hljs-number">10</span>, &amp;id))<br>    &#123;<br>        id = <span class="hljs-number">0x1001</span>;<br>    &#125;<br>version = <span class="hljs-built_in">get_unaligned_le16</span>(&amp;data[<span class="hljs-number">4</span>]);<br><span class="hljs-built_in">dev_info</span>(&amp;client-&gt;dev, <span class="hljs-string">&quot;ID %d, version: %04x\n&quot;</span>, id, version);<br><span class="hljs-keyword">switch</span> (id) &#123;    <span class="hljs-comment">/* 由于不同的芯片配置寄存器地址不一样需要判断一下  */</span><br>    <span class="hljs-keyword">case</span> <span class="hljs-number">911</span>:<br>        ret = <span class="hljs-built_in">gt911_read_regs</span>(dev, GT_9xx_CFGS_REG, data, <span class="hljs-number">7</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">break</span>;<br>    &#125;<br><span class="hljs-keyword">if</span> (ret) &#123;<br><span class="hljs-built_in">dev_err</span>(&amp;client-&gt;dev, <span class="hljs-string">&quot;Unable to read Firmware.\n&quot;</span>);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br>dev-&gt;max_x = (data[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>) + data[<span class="hljs-number">1</span>];<br>dev-&gt;max_y = (data[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">8</span>) + data[<span class="hljs-number">3</span>];<br>dev-&gt;irqtype = data[<span class="hljs-number">6</span>] &amp; <span class="hljs-number">0x3</span>;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;X_MAX: %d, Y_MAX: %d, Touch Number: %d, TRIGGER: 0x%02x\n&quot;</span>, dev-&gt;max_x, dev-&gt;max_y, data[<span class="hljs-number">5</span>], dev-&gt;irqtype);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">我们的屏幕旋转了90度，对应如下：</span><br><span class="hljs-comment">原先      --&gt;   旋转后   </span><br><span class="hljs-comment">(0,0)     --&gt;  (0,240)</span><br><span class="hljs-comment">(240,0)   --&gt;  (0,0)</span><br><span class="hljs-comment">(0,320)   --&gt;  (320,240)</span><br><span class="hljs-comment">(240,320) --&gt;  (320,0)</span><br><span class="hljs-comment">所以对应的调整关系是:</span><br><span class="hljs-comment">(X,Y)     --&gt;  (Y,|X-240|)</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">adjust_x_y</span><span class="hljs-params">(<span class="hljs-type">int</span> *x, <span class="hljs-type">int</span> *y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> tmp;<br>tmp = *x;<br>*x = *y;<br><span class="hljs-keyword">if</span>(tmp &gt;= gt911.max_x)<br>*y = tmp - gt911.max_x;<br><span class="hljs-keyword">else</span><br>*y = gt911.max_x - tmp;<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">irqreturn_t</span> <span class="hljs-title">gt911_irq_handler</span><span class="hljs-params">(<span class="hljs-type">int</span> irq, <span class="hljs-type">void</span> *dev_id)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> touch_num = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> input_x, input_y;<br>    <span class="hljs-type">int</span> id = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br>    u8 data;<br>    u8 touch_data[<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">gt911_dev</span> *dev = dev_id;<br><br>    ret = <span class="hljs-built_in">gt911_read_regs</span>(dev, GT_GSTID_REG, &amp;data, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">if</span> (data == <span class="hljs-number">0x00</span>)  &#123;     <span class="hljs-comment">/* 没有触摸数据，直接返回 */</span><br>        <span class="hljs-keyword">goto</span> fail;<br>    &#125; <span class="hljs-keyword">else</span> &#123;                 <span class="hljs-comment">/* 统计触摸点数据 */</span><br>        touch_num = data &amp; <span class="hljs-number">0x0f</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//这里暂时使用单点触摸 </span><br>    <span class="hljs-keyword">if</span>(touch_num) &#123;         <span class="hljs-comment">/* 单点触摸按下 */</span><br>        <span class="hljs-built_in">gt911_read_regs</span>(dev, GT_TP1_REG, touch_data, <span class="hljs-number">5</span>);<br>        id = touch_data[<span class="hljs-number">0</span>] &amp; <span class="hljs-number">0x0F</span>;<br>        <span class="hljs-keyword">if</span>(id == <span class="hljs-number">0</span>) &#123;<br>            input_x  = touch_data[<span class="hljs-number">1</span>] | (touch_data[<span class="hljs-number">2</span>] &lt;&lt; <span class="hljs-number">8</span>);<br>            input_y  = touch_data[<span class="hljs-number">3</span>] | (touch_data[<span class="hljs-number">4</span>] &lt;&lt; <span class="hljs-number">8</span>);<br><br>            <span class="hljs-comment">//旋转了屏幕，从软件上调整坐标</span><br>            <span class="hljs-built_in">adjust_x_y</span>(&amp;input_x, &amp;input_y);<br><br>            <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;X: %d, Y: %d\n&quot;</span>, input_x, input_y);<br><br>            <span class="hljs-comment">//上报坐标</span><br>            <span class="hljs-built_in">input_mt_slot</span>(dev-&gt;input, id);<br>    <span class="hljs-built_in">input_mt_report_slot_state</span>(dev-&gt;input, MT_TOOL_FINGER, <span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">input_report_abs</span>(dev-&gt;input, ABS_MT_POSITION_X, input_x);<br>    <span class="hljs-built_in">input_report_abs</span>(dev-&gt;input, ABS_MT_POSITION_Y, input_y);<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(touch_num == <span class="hljs-number">0</span>)&#123;                <span class="hljs-comment">/* 单点触摸释放 */</span><br>        <span class="hljs-built_in">input_mt_slot</span>(dev-&gt;input, id);<br>        <span class="hljs-built_in">input_mt_report_slot_state</span>(dev-&gt;input, MT_TOOL_FINGER, <span class="hljs-literal">false</span>);<br>    &#125;<br><br><span class="hljs-built_in">input_mt_report_pointer_emulation</span>(dev-&gt;input, <span class="hljs-literal">true</span>);<br>    <span class="hljs-built_in">input_sync</span>(dev-&gt;input);<br><br>    data = <span class="hljs-number">0x00</span>;                <span class="hljs-comment">/* 向0X814E寄存器写0 */</span><br>    <span class="hljs-built_in">gt911_write_regs</span>(dev, GT_GSTID_REG, &amp;data, <span class="hljs-number">1</span>);<br><br>fail:<br><span class="hljs-keyword">return</span> IRQ_HANDLED;<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * @description     : GT911中断初始化</span><br><span class="hljs-comment"> * @param - client : 要操作的i2c</span><br><span class="hljs-comment"> * @param - multidev: 自定义的multitouch设备</span><br><span class="hljs-comment"> * @return          : 0，成功;其他负值,失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">gt911_ts_irq</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-keyword">struct</span> gt911_dev *dev)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span> ret = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/* 申请中断,client-&gt;irq就是IO中断， */</span><br>ret = <span class="hljs-built_in">devm_request_threaded_irq</span>(&amp;client-&gt;dev, client-&gt;irq, <span class="hljs-literal">NULL</span>,<br>gt911_irq_handler, irq_table[dev-&gt;irqtype] | IRQF_ONESHOT,<br>client-&gt;name, &amp;gt911);<br><span class="hljs-keyword">if</span> (ret) &#123;<br><span class="hljs-built_in">dev_err</span>(&amp;client-&gt;dev, <span class="hljs-string">&quot;Unable to request touchscreen IRQ.\n&quot;</span>);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">GT911_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client, <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> i2c_device_id *id)</span></span><br><span class="hljs-function"></span>&#123;<br><br>u8 data, ret;<br>gt911.client = client;<br><br>    <span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><br>    <span class="hljs-comment">/* 1，获取设备树中的中断和复位引脚 */</span><br>gt911.irq_pin = <span class="hljs-built_in">devm_gpiod_get</span>(&amp;client-&gt;dev,<span class="hljs-string">&quot;interrupt&quot;</span>,GPIOD_OUT_LOW);<br>gt911.reset_pin = <span class="hljs-built_in">devm_gpiod_get</span>(&amp;client-&gt;dev, <span class="hljs-string">&quot;reset&quot;</span>, GPIOD_OUT_LOW);<br><br><span class="hljs-comment">/* 2，复位GT911 */</span><br><span class="hljs-built_in">gt911_reset</span>(client, &amp;gt911);<br><br>    <span class="hljs-comment">/* 3，初始化GT911 */</span><br>    data = <span class="hljs-number">0x02</span>;<br>    <span class="hljs-built_in">gt911_write_regs</span>(&amp;gt911, GT_CTRL_REG, &amp;data, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 软复位 */</span><br>    <span class="hljs-built_in">mdelay</span>(<span class="hljs-number">100</span>);<br>    data = <span class="hljs-number">0x0</span>;<br>    <span class="hljs-built_in">gt911_write_regs</span>(&amp;gt911, GT_CTRL_REG, &amp;data, <span class="hljs-number">1</span>); <span class="hljs-comment">/* 停止软复位 */</span><br>    <span class="hljs-built_in">mdelay</span>(<span class="hljs-number">100</span>);<br><br>    <span class="hljs-comment">/* 4,初始化GT911，读取固件  */</span><br>ret = <span class="hljs-built_in">gt911_read_firmware</span>(client, &amp;gt911);<br><span class="hljs-keyword">if</span>(ret != <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;Fail !!! check !!\r\n&quot;</span>);<br><span class="hljs-keyword">goto</span> fail;<br>    &#125;<br><br>    <span class="hljs-comment">/* 5，input设备注册 */</span><br>gt911.input = <span class="hljs-built_in">devm_input_allocate_device</span>(&amp;client-&gt;dev);<br><span class="hljs-keyword">if</span> (!gt911.input) &#123;<br>ret = -ENOMEM;<br><span class="hljs-keyword">goto</span> fail;<br>&#125;<br>gt911.input-&gt;name = client-&gt;name;<br>gt911.input-&gt;id.bustype = BUS_I2C;<br>gt911.input-&gt;dev.parent = &amp;client-&gt;dev;<br><br>__set_bit(EV_KEY, gt911.input-&gt;evbit);<br>__set_bit(EV_ABS, gt911.input-&gt;evbit);<br>__set_bit(BTN_TOUCH, gt911.input-&gt;keybit);<br><br><span class="hljs-built_in">input_set_abs_params</span>(gt911.input, ABS_X, <span class="hljs-number">0</span>, gt911.max_x, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">input_set_abs_params</span>(gt911.input, ABS_Y, <span class="hljs-number">0</span>, gt911.max_y, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">input_set_abs_params</span>(gt911.input, ABS_MT_POSITION_X,<span class="hljs-number">0</span>, gt911.max_x, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">input_set_abs_params</span>(gt911.input, ABS_MT_POSITION_Y,<span class="hljs-number">0</span>, gt911.max_y, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);     <br>ret = <span class="hljs-built_in">input_mt_init_slots</span>(gt911.input, MAX_SUPPORT_POINTS, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (ret) &#123;<br><span class="hljs-keyword">goto</span> fail;<br>&#125;<br><br>ret = <span class="hljs-built_in">input_register_device</span>(gt911.input);<br><span class="hljs-keyword">if</span> (ret)<br><span class="hljs-keyword">goto</span> fail;<br><br>    <span class="hljs-comment">/* 6，最后初始化中断 */</span><br>ret = <span class="hljs-built_in">gt911_ts_irq</span>(client, &amp;gt911);<br><span class="hljs-keyword">if</span>(ret &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">goto</span> fail;<br>&#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>fail:<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">of_device_id</span> of_match_ids_GT911[] = &#123;<br>&#123; .compatible = <span class="hljs-string">&quot;my_gt911&quot;</span>,.data = <span class="hljs-literal">NULL</span> &#125;,<br>&#123; <span class="hljs-comment">/* END OF LIST */</span> &#125;,<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_device_id</span> GT911_ids[] = &#123;<br>&#123; <span class="hljs-string">&quot;gt911&quot;</span>,(<span class="hljs-type">kernel_ulong_t</span>)<span class="hljs-literal">NULL</span> &#125;,<br>&#123; <span class="hljs-comment">/* END OF LIST */</span> &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">GT911_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> i2c_client *client)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">i2c_driver</span> i2c_GT911_driver = &#123;<br>.driver = &#123;<br>.name = <span class="hljs-string">&quot;gt911&quot;</span>,<br>.of_match_table = of_match_ids_GT911,<br>&#125;,<br>.probe = GT911_probe,<br>.remove = GT911_remove,<br>.id_table = GT911_ids,<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> __init <span class="hljs-title">i2c_driver_GT911_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printk</span>(<span class="hljs-string">&quot;%s %s %d\n&quot;</span>, __FILE__, __FUNCTION__, __LINE__);<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">i2c_add_driver</span>(&amp;i2c_GT911_driver);<br>&#125;<br><span class="hljs-built_in">module_init</span>(i2c_driver_GT911_init);<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> __exit <span class="hljs-title">i2c_driver_GT911_exit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">i2c_del_driver</span>(&amp;i2c_GT911_driver);<br>&#125;<br><span class="hljs-built_in">module_exit</span>(i2c_driver_GT911_exit);<br><br><span class="hljs-built_in">MODULE_AUTHOR</span>(<span class="hljs-string">&quot;LK&quot;</span>);<br><span class="hljs-built_in">MODULE_LICENSE</span>(<span class="hljs-string">&quot;GPL&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-2-3-移植-tslib"><a href="#3-2-3-移植-tslib" class="headerlink" title="3.2.3 移植 tslib"></a>3.2.3 移植 tslib</h3><p>tslib 是一个开源的第三方库，用于触摸屏性能调试，使用电阻屏的时候一般使用 tslib 进行校准。虽然电容屏不需要校准，但主要的是 tslib 提供了一些其他软件，我们可以通过这些软件来测试触摸屏工作是否正常。最新版本的 tslib 已经支持了多点电容触摸屏，因此可以通过 tslib 来直观的测试多点电容触摸屏驱动，这个要比观看 eventX 原始数据方便的多。</p><p>①获取 tslib 源码。git 地址为：<a href="https://github.com/kergoth/tslib">https://github.com/kergoth/tslib</a> ，目前最新的版本是 1.21。</p><p>②修改 tslib 源码所属用户，修改解压得到的 tslib-1.21 目录所属用户为当前用户，这一步一定要做！否则在稍后的编译中会遇到各种问题。我当前 ubuntu 的登录用户名为 “lk”，修改命令如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> chown lk:lk tslib-<span class="hljs-number">1</span>.<span class="hljs-number">21</span> -R<br></code></pre></td></tr></table></figure><p>③ubuntu 工具安装：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> install autoconf<br>sudo apt-<span class="hljs-built_in">get</span> install automake<br>sudo apt-<span class="hljs-built_in">get</span> install libtool<br></code></pre></td></tr></table></figure><p>④编译 tslib：编译完成后在安装目录中，bin 目录下是可执行文件，包括 tslib 的测试工具。etc 目录下是 tslib 的配置文件，lib 目录下是相关的库文件，将所有文件拷贝到开发板中。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-string">./autogen.sh</span><br><span class="hljs-string">./configure</span> <span class="hljs-params">--host=arm-linux</span> <span class="hljs-params">--prefix=</span><span class="hljs-string">&quot;安装目录&quot;</span><br>make &amp;&amp; make install <br></code></pre></td></tr></table></figure><p>⑤配置 tslib</p><ol><li>打开 etc&#x2F;ts.conf 文件，找到 module_raw input，如果这句前面有 “#” 的话就删除掉 “#”。</li><li>在开发板终端输入：</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 注意，下面路径是根目录，如果没有这些文件，运行时会生成</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">TSLIB_TSDEVICE</span>=/dev/input/event2<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">TSLIB_CALIBFILE</span>=/etc/pointercal<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">TSLIB_CONFFILE</span>=/etc/ts.conf<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">TSLIB_PLUGINDIR</span>=/lib/ts<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">TSLIB_CONSOLEDEVICE</span>=none<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">TSLIB_FBDEVICE</span>=/dev/fb1<br></code></pre></td></tr></table></figure><p>⑥ tslib 测试：使用 ts_test_mt 来测试触摸屏工作是否正常，测试结果如下，一切正常：</p><p><em><strong>至此，从头写 GT911 触摸驱动就圆满完成了！</strong></em></p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GCC编译器详解</title>
    <link href="/2024/06/28/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/06/28/GCC%E7%BC%96%E8%AF%91%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-GCC编译器的介绍"><a href="#1-GCC编译器的介绍" class="headerlink" title="1 GCC编译器的介绍"></a>1 GCC编译器的介绍</h1><p>源文件需要经过编译才能生成可执行文件。在 Windows 下进行开发时，只需要点几个按钮即可编译，集成开发环境(比如 Visual studio)已经将各种编译工具的使用封装好了。Linux 下也有很优秀的集成开发工具，但是更多的时候是 直接使用编译工具；即使使用集成开发工具，也需要掌握一些编译选项。  PC 机上的编译工具链为 gcc、ld、objcopy、objdump 等，它们编译出来的程序在 x86 平台上运行。要编译出能在 ARM 平台上运行的程序，必须使用交叉编 译工具 xxx-gcc、xxx-ld 等(不同版本的编译器的前缀不一样，比如 arm-linuxgcc)，下面分别介绍。</p><h1 id="2-GCC编译过程"><a href="#2-GCC编译过程" class="headerlink" title="2 GCC编译过程"></a>2 GCC编译过程</h1><p>一个 C&#x2F;C++文件要经过预处理(preprocessing)、编译(compilation)、汇 编(assembly)和链接(linking)等 4 步才能变成可执行文件。</p><p><img src="/./../photo/image-20231106151713868.png" alt="image-20231106151713868"></p><p>通过不同的 gcc 选项可以控制这些过程： </p><p><img src="/./../photo/image-20231106151728007.png" alt="image-20231106151728007"></p><h2 id="2-1-预处理"><a href="#2-1-预处理" class="headerlink" title="2.1 预处理"></a>2.1 预处理</h2><p>C&#x2F;C++源文件中，以“#”开头的命令被称为预处理命令，如包含命令 “#include”、宏定义命令“#define”、条件编译命令“#if”、“#ifdef”等。 预处理就是将要包含(include)的文件插入原文件中、将宏定义展开、根据条件 编译命令选择要使用的代码，最后将这些东西输出到一个“.i”文件中等待进一 步处理。 </p><h2 id="2-2-编译"><a href="#2-2-编译" class="headerlink" title="2.2 编译"></a>2.2 编译</h2><p>编译就是把 C&#x2F;C++代码(比如上述的“.i”文件)“翻译”成汇编代码，所用 到的工具为 cc1(它的名字就是 cc1，x86 有自己的 cc1 命令，ARM 板也有自己的cc1 命令)。 </p><h2 id="2-3-汇编"><a href="#2-3-汇编" class="headerlink" title="2.3 汇编"></a>2.3 汇编</h2><p>汇编就是将第二步输出的汇编代码翻译成符合一定格式的机器代码，在Linux 系统上一般表现为 ELF 目标文件(OBJ 文件)，用到的工具为 as。x86 有 自己的 as 命令，ARM 版也有自己的 as 命令，也可能是 xxxx-as（比如 armlinux-as）。</p><p><strong>“反汇编”</strong>是指将机器代码转换为汇编代码，这在调试程序时常常用到。</p><h2 id="2-4-链接"><a href="#2-4-链接" class="headerlink" title="2.4 链接"></a>2.4 链接</h2><p>链接就是将上步生成的 OBJ 文件和系统库的 OBJ 文件、库文件链接起来，最 终生成了可以在特定平台运行的可执行文件，用到的工具为 ld 或 collect2。 </p><h2 id="2-5-gcc使用示例："><a href="#2-5-gcc使用示例：" class="headerlink" title="2.5 gcc使用示例："></a>2.5 gcc使用示例：</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc hello.c<span class="hljs-comment">//输出一个名为 a.out 的可执行程序，然后可以执行./a.out </span><br></code></pre></td></tr></table></figure><p><img src="/./../photo/image-20231106152210408.png" alt="image-20231106152210408"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -o hello hello.c<span class="hljs-comment">// 输出名为 hello 的可执行程序，然后可以执行./hello </span><br></code></pre></td></tr></table></figure><p><img src="/./../photo/image-20231106152418847.png" alt="image-20231106152418847"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -o hello hello.c -<span class="hljs-type">static</span> <span class="hljs-comment">// 静态链接 </span><br>gcc -c -o hello.o hello.c <span class="hljs-comment">// 先编译(不链接) </span><br>gcc -o hello hello.o <span class="hljs-comment">// 再链接</span><br></code></pre></td></tr></table></figure><p><img src="/./../photo/image-20231106152738286.png" alt="image-20231106152738286"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -o hello hello.c -v<span class="hljs-comment">//可以查看编译信息</span><br></code></pre></td></tr></table></figure><p><img src="/./../photo/image-20231106152934785.png" alt="image-20231106152934785"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -E -o hello.i hello.c   <span class="hljs-comment">//预处理</span><br>gcc -S -o hello.s hello.i<span class="hljs-comment">//编译</span><br>gcc -c -o hello.o hello.s<span class="hljs-comment">//汇编</span><br>gcc -o hello hello.o<span class="hljs-comment">//链接</span><br></code></pre></td></tr></table></figure><h1 id="3-常用编译选项"><a href="#3-常用编译选项" class="headerlink" title="3 常用编译选项"></a>3 常用编译选项</h1><table><thead><tr><th><strong>常用选项</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>-E</td><td>预处理，开发过程中想快速确定某个宏可以使用“-E -dM”</td></tr><tr><td>-c</td><td>把预处理、编译、汇编都做了，但是不链接</td></tr><tr><td>-o</td><td>指定输出文件</td></tr><tr><td>-I（i）</td><td>指定头文件目录</td></tr><tr><td>-L</td><td>指定链接时库文件目录</td></tr><tr><td>-v</td><td>显示制作 GCC 工具自身时的配置命令；同时显示编译器驱动程序、预处理器、 编译器的版本号</td></tr><tr><td>-l</td><td>指定链接哪一个库文件</td></tr><tr><td>-S</td><td>编译后即停止，不进行汇编</td></tr></tbody></table><h1 id="4-头文件-与“-”区别"><a href="#4-头文件-与“-”区别" class="headerlink" title="4 头文件&lt; &gt;与“ ”区别"></a>4 头文件&lt; &gt;与“ ”区别</h1><ul><li>&lt;&gt;:在库文件目录下查找头文件</li><li>“ ”:     在当前目录下查找头文件</li></ul><p>举个例子:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"> <span class="hljs-number">1</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br> <span class="hljs-number">2</span> <span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sub.h&quot;</span></span><br> <span class="hljs-number">3</span><br> <span class="hljs-number">4</span> <span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br> 5 &#123;<br> <span class="hljs-number">6</span>        <span class="hljs-type">int</span> i;<br> <span class="hljs-number">7</span>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Main fun!\n&quot;</span>);<br> <span class="hljs-number">8</span>        sub_fun();<br> <span class="hljs-number">9</span>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">10</span> &#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c">gcc -o test main.c sub.c<span class="hljs-comment">//编译成功，不会出现任何错误</span><br></code></pre></td></tr></table></figure><p>将上述代码中的第2行改成：#include “sub.h”，再次编译</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -o test main.<span class="hljs-keyword">c</span> <span class="hljs-keyword">sub</span>.<span class="hljs-keyword">c</span>//报错<span class="hljs-punctuation">,</span>因为在库文件目录中没有<span class="hljs-keyword">sub</span>.h<br></code></pre></td></tr></table></figure><p><img src="/./../photo/image-20231106161746679.png" alt="image-20231106161746679"></p><ul><li><p>解决方法：</p><ul><li><p>在库文件目录中添加sub.h</p></li><li><p>在编译时指定头文件目录</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -o test <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> sub<span class="hljs-selector-class">.c</span>  -I ./<span class="hljs-comment">//指定在当前目录下查找头文件</span><br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="5-编译多个文件"><a href="#5-编译多个文件" class="headerlink" title="5 编译多个文件"></a>5 编译多个文件</h1><ul><li><p>一起编译、链接：</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm">gcc -o test main.<span class="hljs-keyword">c</span> <span class="hljs-keyword">sub</span>.<span class="hljs-keyword">c</span><br></code></pre></td></tr></table></figure></li><li><p>分开编译，统一链接：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -c -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>gcc -c -o sub<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.c</span><br>gcc -o test <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> sub.o<br></code></pre></td></tr></table></figure></li></ul><h1 id="5-制作、使用动态库"><a href="#5-制作、使用动态库" class="headerlink" title="5 制作、使用动态库"></a>5 制作、使用动态库</h1><ul><li><p>第一步 制作、编译:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -c -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>gcc -c -o sub<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.c</span><br>gcc -shared -o libsub<span class="hljs-selector-class">.so</span> sub<span class="hljs-selector-class">.o</span> sub2<span class="hljs-selector-class">.o</span> sub3<span class="hljs-selector-class">.o</span><span class="hljs-comment">//可以使用多个.o生成动态库</span><br>gcc -o test <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> -lsub  -L ./<span class="hljs-comment">//指定动态库所在目录</span><br></code></pre></td></tr></table></figure></li><li><p>第2步 运行： </p><ul><li><p>先把 libsub.so 放到 Ubuntu 的&#x2F;lib 目录，然后就可以运行 test 程序。 </p></li><li><p>如果不想把 libsub.so 放到&#x2F;lib，也可以放在某个目录比如&#x2F;a，然后如下执</p></li></ul>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/a <br>./test<br></code></pre></td></tr></table></figure></li></ul><h1 id="6-制作、使用静态库"><a href="#6-制作、使用静态库" class="headerlink" title="6 制作、使用静态库"></a>6 <strong>制作、使用静态库</strong></h1><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -c -o <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> <br>gcc -c -o sub<span class="hljs-selector-class">.o</span> sub<span class="hljs-selector-class">.c</span> <br>ar crs libsub<span class="hljs-selector-class">.a</span> sub<span class="hljs-selector-class">.o</span> sub2<span class="hljs-selector-class">.o</span> sub3<span class="hljs-selector-class">.o</span>(可以使用多个<span class="hljs-selector-class">.o</span> 生成静态库) <br>gcc -o test <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> libsub<span class="hljs-selector-class">.a</span> (如果<span class="hljs-selector-class">.a</span> 不在当前目录下，需要指定它的绝对或相对路径) <br></code></pre></td></tr></table></figure><p>运行：不需要把静态库 libsub.a 放到板子上。 </p><p><strong>注意：</strong>执行 arm-buildroot-linux-gnueabihf-gcc -c -o sub.o sub.c 交叉编译需要在最后面加上-fPIC 参数。 </p><h1 id="7-很有用的选项"><a href="#7-很有用的选项" class="headerlink" title="7 很有用的选项"></a>7 很有用的选项</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs php">gcc -E main.c <span class="hljs-comment">// 查看预处理结果，比如头文件是哪个 </span><br>gcc -E -dM main.c &gt; <span class="hljs-number">1</span>.txt <span class="hljs-comment">// 把所有的宏展开，存在 1.txt 里 </span><br>gcc -Wp,-MD,abc.dep -c -o main.o main.c <span class="hljs-comment">// 生成依赖文件 abc.dep，后面 Makefile 会用 </span><br><span class="hljs-keyword">echo</span> <span class="hljs-string">&#x27;main()&#123;&#125;&#x27;</span>| gcc -E -v - <span class="hljs-comment">// 它会列出头文件目录、库目录(LIBRARY_PATH) </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PC性能检测站</title>
    <link href="/2024/06/28/PC%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E7%AB%99/"/>
    <url>/2024/06/28/PC%E6%80%A7%E8%83%BD%E6%A3%80%E6%B5%8B%E7%AB%99/</url>
    
    <content type="html"><![CDATA[<h1 id="1-硬件"><a href="#1-硬件" class="headerlink" title="1 硬件"></a>1 硬件</h1><h2 id="1-1-实物图"><a href="#1-1-实物图" class="headerlink" title="1.1 实物图"></a>1.1 实物图</h2><p><img src="/./../photo/image-20240301180803046.png" alt="image-20240301180803046"></p><p><img src="/./../photo/image-20240301180824622.png" alt="image-20240301180824622"></p><h2 id="1-1-原理图"><a href="#1-1-原理图" class="headerlink" title="1.1 原理图"></a>1.1 原理图</h2><p><img src="/./../photo/image-20240301175301750.png" alt="image-20240301175301750"></p><h2 id="1-2-PCB"><a href="#1-2-PCB" class="headerlink" title="1.2 PCB"></a>1.2 PCB</h2><p><img src="/./../photo/image-20240313160523991.png" alt="image-20240313160523991"></p><h1 id="2-软件"><a href="#2-软件" class="headerlink" title="2 软件"></a>2 软件</h1><h2 id="2-1-创建工程以及移植"><a href="#2-1-创建工程以及移植" class="headerlink" title="2.1 创建工程以及移植"></a>2.1 创建工程以及移植</h2><h3 id="RT-Thread-Nano-联合-CubeMX编程"><a href="#RT-Thread-Nano-联合-CubeMX编程" class="headerlink" title="RT-Thread Nano 联合 CubeMX编程"></a>RT-Thread Nano 联合 CubeMX编程</h3><ul><li>使用 RT-Thread  Studio 新建一个 RT-Thread Nano 项目，选择芯片信号</li><li>在test文件夹下，双击CubeMX Settings打开CubeMX</li><li>配置RCC、GPIO、UART、SPI、DMA、USB、USB_DEVICE(虚拟串口)等，选择工具链为Makefile，生成代码</li><li>在test文件夹下，双击RT-Thread Settings打开，选择需要用到的组件，如互斥量、信号量等</li></ul><h3 id="移植图形库u8g2"><a href="#移植图形库u8g2" class="headerlink" title="移植图形库u8g2"></a>移植图形库u8g2</h3><p>根据OLED驱动芯片、显示大小、驱动总线来选择</p><h3 id="USB虚拟串口"><a href="#USB虚拟串口" class="headerlink" title="USB虚拟串口"></a>USB虚拟串口</h3><p>通常我们使用STM32进行串口通信会选择其硬件串口，但在某些情况下串口会不够用，这个时候就可以选择USB的虚拟串口，这样可以增加一个串口。</p><h4 id="在CubeMX里面配置USB需要两个地方"><a href="#在CubeMX里面配置USB需要两个地方" class="headerlink" title="在CubeMX里面配置USB需要两个地方"></a>在CubeMX里面配置USB需要两个地方</h4><ul><li><p>一个是Connectivity下勾选USB，在Mode下勾选Device，下面的参数保持默认即可。其他芯片类型的选项可能不同，选择有Device字样的就OK。</p><p><img src="/./../photo/image-20240314160237186.png" alt="image-20240314160237186"></p></li><li><p>第二在Middleware下选择USB_DEVICE，在右边的下拉菜单选择Communication Device Class（Virtual Port Com），下面的参数设置可以保持默认，除非你了解各个参数是干什么的，否则不建议修改。这些参数涉及到了USB的设备描述符、字符串描述符、缓存等等。</p><p><img src="/./../photo/image-20240314160318465.png" alt="image-20240314160318465"></p></li></ul><h4 id="USB虚拟串口涉及的文件有下面三类："><a href="#USB虚拟串口涉及的文件有下面三类：" class="headerlink" title="USB虚拟串口涉及的文件有下面三类："></a>USB虚拟串口涉及的文件有下面三类：</h4><ul><li><p>底层</p><p><img src="/./../photo/image-20240314160459162.png" alt="image-20240314160459162"></p></li><li><p>中间层</p><p><img src="/./../photo/image-20240314160626178.png" alt="image-20240314160626178"></p></li><li><p>应用层</p><p><img src="/./../photo/image-20240314161442924.png" alt="image-20240314161442924"></p></li></ul><p>实际使用只需要关注应用层就行。&#x3D;&#x3D;在使用的时候需要安装STM32提供的虚拟串口驱动&#x3D;&#x3D;</p><p>在usb_device.c文件下实现了USB设备的初始化，只需要调用它就完成了所有的USB初始化工作</p><p>通过在main中调用这个函数，电脑就已经可以将芯片的USB识别为一个串口了</p><h2 id="2-3-开发环境"><a href="#2-3-开发环境" class="headerlink" title="2.3 开发环境"></a>2.3 开发环境</h2><ul><li>操作系统：Windows10（RT-Thread Nano + CubeMX）</li><li>文本编辑器：vscode</li><li>gcc开发环境：MinGW-64，gcc版本8.1.0，将经典的开源C语言编译器 GCC 移植到了 Windows 平台下</li><li>编译器（交叉编译工具链）：arm-none-eabi-gcc版本10.3.1</li><li>调试器：ST-link，调试口SWD</li><li>代码管理工具：git</li></ul><h2 id="2-4-源代码分析"><a href="#2-4-源代码分析" class="headerlink" title="2.4 源代码分析"></a>2.4 源代码分析</h2><h3 id="源码目录"><a href="#源码目录" class="headerlink" title="源码目录"></a>源码目录</h3><p><img src="/./../photo/image-20240313135721291.png" alt="image-20240313135721291"></p><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs scss">int <span class="hljs-selector-tag">main</span>(void)<br>&#123;<br><span class="hljs-built_in">eeprom_init</span>();        <span class="hljs-comment">//模拟eeprom初始化</span><br><br><span class="hljs-built_in">oled_init</span>();          <span class="hljs-comment">// OLED初始化，oled刷新数据线程2</span><br><span class="hljs-built_in">DMA1_channel7_Init</span>(); <span class="hljs-comment">// DMA初始化</span><br><br><span class="hljs-built_in">MX_GPIO_Init</span>();  <span class="hljs-comment">// GPIOA12初始化</span><br><span class="hljs-built_in">rt_thread_mdelay</span>(<span class="hljs-number">500</span>);<br><span class="hljs-built_in">MX_USB_DEVICE_Init</span>();  <span class="hljs-comment">//USB初始化</span><br><br><span class="hljs-built_in">led_init</span>();  <span class="hljs-comment">//LED初始化，呼吸灯线程5</span><br><br><span class="hljs-built_in">data_decode_init</span>();   <span class="hljs-comment">//数据解码线程3、定时器线程100</span><br><br><span class="hljs-built_in">oled_show_init</span>();    <span class="hljs-comment">//gui线程20、oled线程20</span><br><br>return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="oled-c"><a href="#oled-c" class="headerlink" title="oled.c"></a>oled.c</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs scss">void <span class="hljs-built_in">oled_set_light</span>(uint8_t value) <span class="hljs-comment">//设置亮度</span><br>void <span class="hljs-built_in">oled_set_power</span>(uint8_t en)   <span class="hljs-comment">//设置是否开启显示</span><br>void <span class="hljs-built_in">oled_set_direction</span>(uint8_t direction)<span class="hljs-comment">//设置显示方向</span><br><br><span class="hljs-comment">/* OLED初始化 */</span><br>void <span class="hljs-built_in">oled_init</span>(void)<br>&#123;<br><span class="hljs-comment">/* 初始化信号量 */</span><br>    <span class="hljs-built_in">rt_sem_init</span>(&amp;sem_oled_dma_TxCplt, &quot;dmatxcplt&quot;, <span class="hljs-number">0</span>, RT_IPC_FLAG_FIFO);<br>    <span class="hljs-comment">/* 初始化互斥量 */</span><br>    <span class="hljs-built_in">rt_mutex_init</span>(&amp;mutex_oled_lock, &quot;oled_lock&quot;, RT_IPC_FLAG_FIFO);<br><br>    <span class="hljs-comment">/* 创建OLED线程 */</span><br>    <span class="hljs-built_in">rt_thread_init</span>(&amp;oled_send_thread, <br>                    &quot;oled_spi&quot;,<br>                    oled_send_entry,<br>                    RT_NULL,<br>                    &amp;oled_send_thread_stack[<span class="hljs-number">0</span>],<br>                    sizeof(oled_send_thread_stack),<br>                    <span class="hljs-number">2</span>,<br>                    <span class="hljs-number">20</span>);<br><br>    <span class="hljs-comment">/* 1.复位SSD1306 */</span><br>    <span class="hljs-comment">/* 2.驱动IC初始化代码：直接使用厂家推荐的设置 */</span><br>    <br>    <span class="hljs-comment">/* 开启oled进程 */</span><br>    <span class="hljs-built_in">rt_thread_startup</span>(&amp;oled_send_thread);<br>&#125;<br><br><span class="hljs-comment">// oled数据发送线程入口函数</span><br>void <span class="hljs-built_in">oled_send_entry</span>(void *parameter)<br>&#123;<br><span class="hljs-comment">/* 获取互斥量 */</span><br><span class="hljs-comment">/* 开启片选 */</span><br><br><span class="hljs-comment">/* 1.设置页地址和列地址 */</span><br><span class="hljs-comment">/* 获取信号量，等待DMA发送完毕 */</span><br><span class="hljs-comment">/* 2.将vdb[8][128]中的数据刷新到oled上显示 */</span><br><span class="hljs-comment">/* 获取信号量，等待DMA发送完毕 */</span><br><br><span class="hljs-comment">/* 关闭片选 */</span><br><span class="hljs-comment">/* 释放互斥量 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="decode-c"><a href="#decode-c" class="headerlink" title="decode.c"></a>decode.c</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><code class="hljs xl"><span class="hljs-comment">/* 数据解码初始化 */</span><br>void data_decode_init()<br>&#123;<br><span class="hljs-comment">/* 初始化信号量 */</span><br>rt_sem_init(&amp;sem_usb_rx, <span class="hljs-string">&quot;sem_usb_tx&quot;</span>, <span class="hljs-number">0</span>, RT_IPC_FLAG_FIFO);<br><br><span class="hljs-comment">/* 创建数据解码线程 */</span><br>ret = rt_thread_init(&amp;data_decode_thread,<br>                         <span class="hljs-string">&quot;decode&quot;</span>,<br>                         data_decode_entry,<br>                         RT_NULL,<br>                         &amp;data_decode_thread_stack[<span class="hljs-number">0</span>],<br>                         sizeof(data_decode_thread_stack),<br>                         <span class="hljs-number">3</span>,<br>                         <span class="hljs-number">20</span>);<br>     <span class="hljs-comment">/* 开启数据解码进程 */</span>                  <br>    rt_thread_startup(&amp;data_decode_thread);                     <br>&#125;<br><br><span class="hljs-comment">//存放数据的数据框架</span><br>typedef struct<br>&#123;<br>    uint8_t head;   <span class="hljs-comment">//码头</span><br>    uint8_t func_code; <span class="hljs-comment">//功能码</span><br>    uint8_t data_len;  <span class="hljs-comment">//数据长度</span><br>    uint8_t *<span class="hljs-keyword">data</span>;   <span class="hljs-comment">//数据</span><br>    uint8_t checksum;  <span class="hljs-comment">//校验和</span><br>    uint8_t tail;<span class="hljs-comment">//码尾</span><br><br>    uint8_t data_cnt;   <span class="hljs-comment">//数据个数</span><br>    uint8_t state;<span class="hljs-comment">//状态</span><br><br>    uint16_t rec_error_cnt; <span class="hljs-comment">//超时计数</span><br>&#125; data_frame_t;<br><br><span class="hljs-comment">// 数据解码线程入口函数</span><br>void data_decode_entry(void *parameter)<br>&#123;<br>    uint8_t <span class="hljs-keyword">data</span> = <span class="hljs-number">0</span>;<br>    uint8_t data_buffer[<span class="hljs-number">150</span>];<br><br><span class="hljs-comment">/* 创建定时线程 */</span><br>    rt_timer_init(&amp;no_data_rx_timer,<br>                  <span class="hljs-string">&quot;no_data_rx&quot;</span>,<br>                  no_data_rx_timer_timeout,<br>                  (void *)&amp;data_frame, <br>                  <span class="hljs-number">100</span>,<br>                  RT_TIMER_FLAG_ONE_SHOT);<br>    <br>    <span class="hljs-comment">//初始化数据框架，设置数据内容为0，设置码头、码尾</span><br>    data_frame_init(&amp;data_frame, data_buffer, sizeof(data_buffer), <span class="hljs-number">0</span>x87, <span class="hljs-number">0</span>x16);<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<span class="hljs-comment">//从usb_rxcb环形缓冲区中取出一个字节放入到data里面，返回值为0表示为空</span><br>        <span class="hljs-keyword">while</span> (rt_ringbuffer_getchar(&amp;usb_rxcb, &amp;<span class="hljs-keyword">data</span>) == <span class="hljs-number">0</span>)  <br>        &#123;<br>            rt_sem_take(&amp;sem_usb_rx, RT_WAITING_FOREVER);<br>        &#125;<br><br>        data_receive_prepare(&amp;data_frame, <span class="hljs-keyword">data</span>);<br>        rt_timer_start(&amp;no_data_rx_timer); <span class="hljs-comment">// 启动定时器，100ms未接受数据，数据帧重置</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">/* 定时线程的入口函数 */</span><br>void no_data_rx_timer_timeout(void *parameter)<br>&#123;<br>    <span class="hljs-function"><span class="hljs-title">data_frame_reset</span>((data_frame_t *)parameter); //实际上就是让data_frame-&gt;</span>state = <span class="hljs-number">0</span><br>&#125;<br><br><br><span class="hljs-comment">/* 对取出来的data数据处理，按照数据框架放入其中 */</span><br>void data_receive_prepare(data_frame_t *data_frame, uint8_t <span class="hljs-keyword">data</span>)<br>&#123;<br>    <span class="hljs-function"><span class="hljs-title">if</span> (data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">state</span> == 0 &amp;&amp; <span class="hljs-keyword">data</span> == data_frame-&gt;</span>head) <span class="hljs-comment">//码头</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (data_frame-&gt;</span>state == <span class="hljs-number">1</span>) <span class="hljs-comment">//功能码</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">2</span>;<br><br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>data_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>data_cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>func_code = <span class="hljs-keyword">data</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (data_frame-&gt;</span>state == <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-keyword">data</span> &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//数据长度</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">3</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>data_len = <span class="hljs-keyword">data</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>data_cnt = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">state</span> == 3 &amp;&amp; data_frame-&gt;</span>data_len &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">//数据</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>[data_frame-&gt;</span>data_cnt++] = <span class="hljs-keyword">data</span>;<br>        <span class="hljs-function"><span class="hljs-title">if</span> (data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">data_cnt</span> == data_frame-&gt;</span>data_len)<br>        &#123;<br>            <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">4</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (data_frame-&gt;</span>state == <span class="hljs-number">4</span>) <span class="hljs-comment">//数据校验码</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">5</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>checksum = <span class="hljs-keyword">data</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">else</span> <span class="hljs-keyword">if</span> (data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">state</span> == 5 &amp;&amp; <span class="hljs-keyword">data</span> == data_frame-&gt;</span>tail) <span class="hljs-comment">//码尾</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">0</span>;<br>        data_receive_anl(data_frame); <span class="hljs-comment">//接收到一帧完整的数据后，对这帧数据进项解析</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>data_len = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>data_cnt = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>state = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-title">data_frame</span>-&gt;</span>rec_error_cnt++;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 对一帧完整的数据data_frame进行数据解析 */</span><br>void data_receive_anl(data_frame_t *data_frame)<br>&#123;<br>    uint8_t sum = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-title">sum</span> += data_frame-&gt;</span>head;<br>    <span class="hljs-function"><span class="hljs-title">sum</span> += data_frame-&gt;</span>func_code;<br>    <span class="hljs-function"><span class="hljs-title">sum</span> += data_frame-&gt;</span>data_len;<br>    <span class="hljs-function"><span class="hljs-title">for</span> (uint8_t i = 0; i &lt; data_frame-&gt;</span>data_len; i++)<br>    &#123;<br>        <span class="hljs-function"><span class="hljs-title">sum</span> += *(data_frame-&gt;</span><span class="hljs-keyword">data</span> + i);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">if</span> (!(sum == data_frame-&gt;</span>checksum)) <span class="hljs-comment">//首先对这帧数据进行校验和</span><br>    &#123;<br>        return;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>xF0) <span class="hljs-comment">//根据功能码，提取不同的数据信息</span><br>    &#123;<br>    case <span class="hljs-number">0</span>x10: <span class="hljs-comment">//cpu数据信息</span><br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.cpu_data.cpu_act = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x01:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.cpu_data.cpupkg_temp = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        default:<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x20: <span class="hljs-comment">//RAM</span><br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.ram_data.mem_act = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x01:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.ram_data.mem_used = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        default:<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x30: <span class="hljs-comment">//GPU</span><br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.gpu_data.gpu_temp = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x01:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.gpu_data.gpu_act = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x02:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.gpu_data.gpu_mem_act = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x03:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.gpu_data.gpu_mem_used = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x04:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.gpu_data.gpu_mem_total = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        default:<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x40: <span class="hljs-comment">//NET</span><br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.net_data.download_rate = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x01:<br>            <span class="hljs-function"><span class="hljs-title">pc_data</span>.net_data.upload_rate = hextofloat(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        default:<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x50: <span class="hljs-comment">//others</span><br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00: <span class="hljs-comment">//0x50</span><br>            break;<br><br>        case <span class="hljs-number">0</span>x0F: <span class="hljs-comment">//频谱</span><br>            <span class="hljs-function"><span class="hljs-title">show_spectrum_data_update</span>(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        default:<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x60: <span class="hljs-comment">//接收gif</span><br>        <span class="hljs-function"><span class="hljs-title">gif_frame_write</span>(data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">func_code</span> &amp; 0x0F, data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>, data_frame-&gt;</span>data_len);<br>        break;<br><br>    case <span class="hljs-number">0</span>x70: <span class="hljs-comment">//显示</span><br>        oled_idle_mode_timer_reset();<br><br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00: <span class="hljs-comment">//0x70 性能监控</span><br>            show_pc_data_update(&amp;pc_data);<br>            oled_mode_switch(MODE_MONITOR);<br>            break;<br><br>        case <span class="hljs-number">0</span>x01: <span class="hljs-comment">//0x71 //GIF显示</span><br>            oled_mode_switch(MODE_GIF);<br>            break;<br><br>        case <span class="hljs-number">0</span>x02: <span class="hljs-comment">//0x72 //频谱</span><br>            oled_mode_switch(MODE_SPECTRUM);<br>            break;<br><br>        default:<br>            oled_mode_switch(MODE_IDLE);<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x80:<br>        <span class="hljs-function"><span class="hljs-title">switch</span> (data_frame-&gt;</span>func_code &amp; <span class="hljs-number">0</span>x0F)<br>        &#123;<br>        case <span class="hljs-number">0</span>x00:<br>            <span class="hljs-function"><span class="hljs-title">device_control</span>(data_frame-&gt;</span><span class="hljs-keyword">data</span>);<br>            break;<br><br>        case <span class="hljs-number">0</span>x01:<br>            device_config_send();<br>            break;<br>        &#125;<br>        break;<br><br>    case <span class="hljs-number">0</span>x90: <span class="hljs-comment">// set logo pic</span><br>        <span class="hljs-function"><span class="hljs-title">logo_bmp_update</span>(data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">func_code</span> &amp; 0x0F, data_frame-&gt;</span><span class="hljs-function"><span class="hljs-title">data</span>, data_frame-&gt;</span>data_len);<br>        break;<br><br>    case <span class="hljs-number">0</span>xF0: <span class="hljs-comment">//上位机寻找本设备</span><br>        device_ack();<br>        break;<br><br>    default:<br>        break;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="draw-c"><a href="#draw-c" class="headerlink" title="draw.c"></a>draw.c</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs csharp">uint8_t new_mode = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 待切换至的模式  0 空闲   1 性能监视器   2 频谱  3 动画</span><br>uint8_t now_mode = <span class="hljs-number">0</span>;       <span class="hljs-comment">// 当前的模式</span><br>uint8_t mode_switching = <span class="hljs-number">0</span>; <span class="hljs-comment">// 模式切换动画进行中</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">idle_mode_enter</span>()</span>;     <span class="hljs-comment">// idle mode 的进入动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monitor_mode_enter</span>()</span>;  <span class="hljs-comment">// monitor mode 的进入动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spectrum_mode_enter</span>()</span>; <span class="hljs-comment">// spectrum mode 的进入动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gif_mode_enter</span>()</span>;      <span class="hljs-comment">// gif mode 的进入动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">idle_mode_leave</span>()</span>;     <span class="hljs-comment">// idle mode 的退出动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">monitor_mode_leave</span>()</span>;  <span class="hljs-comment">// monitor mode 的退出动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">spectrum_mode_leave</span>()</span>; <span class="hljs-comment">// spectrum mode 的退出动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">gif_mode_leave</span>()</span>;      <span class="hljs-comment">// gif mode 的退出动画</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mode_switch_over_cb</span>()</span>; <span class="hljs-comment">// 模式切换完毕的回调函数</span><br><br><span class="hljs-comment">/* 显示初始化 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">oled_show_init</span>()</span><br>&#123;<br> gui_init(); <span class="hljs-comment">//有一个gui_thread线程，用于不断的去绘制gui</span><br> <br><span class="hljs-comment">//    rt_thread_init(&amp;gui_thread, //gui线程初始化</span><br><span class="hljs-comment">//                   &quot;gui&quot;,</span><br><span class="hljs-comment">//                   gui_entry,</span><br><span class="hljs-comment">//                   RT_NULL,</span><br><span class="hljs-comment">//                   &amp;gui_thread_stack[0],</span><br><span class="hljs-comment">//                   sizeof(gui_thread_stack),</span><br><span class="hljs-comment">//                   1,</span><br><span class="hljs-comment">//                   20);</span><br><span class="hljs-comment">//    rt_thread_startup(&amp;gui_thread);</span><br> <br> <br> <span class="hljs-comment">/* 初始化 */</span><br> <span class="hljs-comment">/* 1.logo */</span><br> <span class="hljs-comment">/* 2.cpu */</span><br> <span class="hljs-comment">/* 3.mem */</span><br> <span class="hljs-comment">/* 4.gpu */</span><br> <span class="hljs-comment">/* 5.nic */</span><br> <span class="hljs-comment">/* 6.频谱 */</span><br> <span class="hljs-comment">/* 7.gif显示模式 */</span><br> <br> <span class="hljs-comment">/* 创建oled绘制线程 */</span><br> ret = rt_thread_init(&amp;oled_draw_thread,<br>                         <span class="hljs-string">&quot;oled_draw&quot;</span>,<br>                         oled_draw_entry,<br>                         RT_NULL,<br>                         &amp;oled_draw_thread_stack[<span class="hljs-number">0</span>],<br>                         <span class="hljs-keyword">sizeof</span>(oled_draw_thread_stack),<br>                         <span class="hljs-number">4</span>,<br>                         <span class="hljs-number">20</span>);<br>     rt_thread_startup(&amp;oled_draw_thread);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数据传输流程"><a href="#数据传输流程" class="headerlink" title="数据传输流程"></a>数据传输流程</h4><ul><li><h4 id="1-数据来源：通过RTT自带的环形缓冲区函数，将PC传过来的数据buf写入到usb-rxcb里面"><a href="#1-数据来源：通过RTT自带的环形缓冲区函数，将PC传过来的数据buf写入到usb-rxcb里面" class="headerlink" title="1.数据来源：通过RTT自带的环形缓冲区函数，将PC传过来的数据buf写入到usb_rxcb里面"></a>1.数据来源：通过RTT自带的环形缓冲区函数，将PC传过来的数据buf写入到usb_rxcb里面</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scss">static int8_t <span class="hljs-built_in">CDC_Receive_FS</span>(uint8_t *Buf, uint32_t *Len)<br>&#123;<br>  <span class="hljs-comment">/* USER CODE BEGIN 6 */</span><br>  <span class="hljs-built_in">USBD_CDC_SetRxBuffer</span>(&amp;hUsbDeviceFS, &amp;Buf[<span class="hljs-number">0</span>]);<br>  <span class="hljs-built_in">USBD_CDC_ReceivePacket</span>(&amp;hUsbDeviceFS);<br><br>  <span class="hljs-built_in">rt_ringbuffer_put</span>(&amp;usb_rxcb, Buf, *Len);     <span class="hljs-comment">/* 往环形缓冲区中写入数据 */</span><br>  <span class="hljs-built_in">rt_sem_release</span>(&amp;sem_usb_rx);<br><br>  return (USBD_OK);<br>  <span class="hljs-comment">/* USER CODE END 6 */</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><h4 id="2-从环形缓冲区usb-rxcb中取出一个字节放入data中"><a href="#2-从环形缓冲区usb-rxcb中取出一个字节放入data中" class="headerlink" title="2.从环形缓冲区usb_rxcb中取出一个字节放入data中"></a>2.从环形缓冲区usb_rxcb中取出一个字节放入data中</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts">rt_ringbuffer_getchar(<span class="hljs-variable">&amp;usb_rxcb</span>, <span class="hljs-variable">&amp;data</span>)<span class="hljs-punctuation">;</span><br></code></pre></td></tr></table></figure></li><li><h4 id="3-处理data-组合成一帧数据"><a href="#3-处理data-组合成一帧数据" class="headerlink" title="3.处理data,组合成一帧数据"></a>3.处理data,组合成一帧数据</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> head;<span class="hljs-comment">//码头  0X87</span><br>    <span class="hljs-type">uint8_t</span> func_code;<span class="hljs-comment">//功能码</span><br>    <span class="hljs-type">uint8_t</span> data_len;<span class="hljs-comment">//数据长度</span><br>    <span class="hljs-type">uint8_t</span> *data;<span class="hljs-comment">//数据</span><br>    <span class="hljs-type">uint8_t</span> checksum;<span class="hljs-comment">//数据校验码</span><br>    <span class="hljs-type">uint8_t</span> tail;<span class="hljs-comment">//码尾  0X16</span><br><br>    <span class="hljs-type">uint8_t</span> data_cnt;<span class="hljs-comment">//统计数据位，与data_len进行比较</span><br>    <span class="hljs-type">uint8_t</span> state;<span class="hljs-comment">//状态</span><br><br>    <span class="hljs-type">uint16_t</span> rec_error_cnt; <span class="hljs-comment">//错误码</span><br>&#125; <span class="hljs-type">data_frame_t</span>;<br><br><span class="hljs-built_in">data_receive_prepare</span>(&amp;data_frame, data);<br></code></pre></td></tr></table></figure></li><li><h4 id="4-接收完一帧数据后，先对数据进行校验，再识别不同的功能码，做出对应的处理"><a href="#4-接收完一帧数据后，先对数据进行校验，再识别不同的功能码，做出对应的处理" class="headerlink" title="4.接收完一帧数据后，先对数据进行校验，再识别不同的功能码，做出对应的处理"></a>4.接收完一帧数据后，先对数据进行校验，再识别不同的功能码，做出对应的处理</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-number">0</span>X10pc_data<span class="hljs-selector-class">.cpu_data</span><span class="hljs-selector-class">.cpu_act</span><br><span class="hljs-number">0</span>X11pc_data<span class="hljs-selector-class">.cpu_data</span><span class="hljs-selector-class">.cpupkg_temp</span><br><br><span class="hljs-number">0</span>X20pc_data<span class="hljs-selector-class">.ram_data</span><span class="hljs-selector-class">.mem_act</span><br><span class="hljs-number">0</span>X21pc_data<span class="hljs-selector-class">.ram_data</span><span class="hljs-selector-class">.mem_used</span><br><br><span class="hljs-number">0</span>X30pc_data<span class="hljs-selector-class">.gpu_data</span><span class="hljs-selector-class">.gpu_temp</span><br><span class="hljs-number">0</span>X31pc_data<span class="hljs-selector-class">.gpu_data</span><span class="hljs-selector-class">.gpu_act</span><br><span class="hljs-number">0</span>X32pc_data<span class="hljs-selector-class">.gpu_data</span><span class="hljs-selector-class">.gpu_mem_act</span><br><span class="hljs-number">0</span>X33pc_data<span class="hljs-selector-class">.gpu_data</span><span class="hljs-selector-class">.gpu_mem_used</span><br><span class="hljs-number">0</span>X34pc_data<span class="hljs-selector-class">.gpu_data</span><span class="hljs-selector-class">.gpu_mem_total</span><br><br><span class="hljs-number">0</span>X40pc_data<span class="hljs-selector-class">.net_data</span><span class="hljs-selector-class">.download_rate</span><br><span class="hljs-number">0</span>X41pc_data<span class="hljs-selector-class">.net_data</span><span class="hljs-selector-class">.upload_rate</span><br><br><span class="hljs-number">0</span>X50保留<br><span class="hljs-number">0</span>X5F<span class="hljs-built_in">show_spectrum_data_update</span>(data_frame-&gt;data);<br><br><span class="hljs-number">0</span>X60 <span class="hljs-built_in">gif_frame_write</span>(data_frame-&gt;func_code &amp; <span class="hljs-number">0</span>x0F, data_frame-&gt;data, data_frame-&gt;data_len);<br><br><span class="hljs-number">0</span>X70<span class="hljs-built_in">show_pc_data_update</span>(&amp;pc_data);      <span class="hljs-built_in">oled_mode_switch</span>(MODE_MONITOR);<br><span class="hljs-number">0</span>X71<span class="hljs-built_in">oled_mode_switch</span>(MODE_GIF);<br><span class="hljs-number">0</span>X72<span class="hljs-built_in">oled_mode_switch</span>(MODE_SPECTRUM);<br><span class="hljs-number">0</span>X7N<span class="hljs-built_in">oled_mode_switch</span>(MODE_IDLE);<br><br><span class="hljs-number">0</span>X80<span class="hljs-built_in">device_control</span>(data_frame-&gt;data);<br><span class="hljs-number">0</span>X81<span class="hljs-built_in">device_config_send</span>();<br><br><span class="hljs-number">0</span>X90<span class="hljs-built_in">logo_bmp_update</span>(data_frame-&gt;func_code &amp; <span class="hljs-number">0</span>x0F, data_frame-&gt;data, data_frame-&gt;data_len);<br><br><span class="hljs-number">0</span>XF0<span class="hljs-built_in">device_ack</span>();<br><br></code></pre></td></tr></table></figure></li></ul><p>24种不同的功能码  </p><h1 id="3-遇到问题"><a href="#3-遇到问题" class="headerlink" title="3 遇到问题"></a>3 遇到问题</h1><h2 id="1、更新显存到OLED的时候不成功"><a href="#1、更新显存到OLED的时候不成功" class="headerlink" title="1、更新显存到OLED的时候不成功"></a>1、更新显存到OLED的时候不成功</h2><p>因为以前用OLED的时候，是在裸机上操作的，需要更新的时候调用一次函数就行，不存在并发的问题</p><p>上了操作系统就会出现这个问题，当我线程这次更新的时候还没完成，又被别的线程抢占了，导致出现这个问题</p><p>在更新显存线程里加上互斥锁，在SPI的DMA发送函数前获取信号量，发完完后释放信号量</p><h2 id="2、使用USB虚拟串口（空闲中断-DMA）接收电脑传过来的数据时，因为接收的数据量很大，CPU来不及处理，就有一部分数据丢失掉了"><a href="#2、使用USB虚拟串口（空闲中断-DMA）接收电脑传过来的数据时，因为接收的数据量很大，CPU来不及处理，就有一部分数据丢失掉了" class="headerlink" title="2、使用USB虚拟串口（空闲中断+DMA）接收电脑传过来的数据时，因为接收的数据量很大，CPU来不及处理，就有一部分数据丢失掉了"></a>2、使用USB虚拟串口（空闲中断+DMA）接收电脑传过来的数据时，因为接收的数据量很大，CPU来不及处理，就有一部分数据丢失掉了</h2><p>加了一个环形缓冲区，接收来的数据先放入环形缓冲区里面，以后每次从环形缓冲区里面取数据，等来CPU的处理</p>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>c</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ARM体系架构</title>
    <link href="/2024/06/28/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/"/>
    <url>/2024/06/28/ARM%E4%BD%93%E7%B3%BB%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以下内容部分摘录自《ARM Cortex-M3 权威指南》、《ARM Cortex-M3与Cortex-M4权威指南》、《ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition》、韦东山老师的课程《深入理解ARM架构》，仅用于个人交流与学习，如涉及侵权请联系站长删除！</p></blockquote><h1 id="第一章-ARM架构版本及处理器系列介绍"><a href="#第一章-ARM架构版本及处理器系列介绍" class="headerlink" title="第一章 ARM架构版本及处理器系列介绍"></a>第一章 ARM架构版本及处理器系列介绍</h1><h2 id="1-ARM背景"><a href="#1-ARM背景" class="headerlink" title="1.ARM背景"></a>1.ARM背景</h2><p>ARM在1990年成立，当初的名字是“Advanced RISC Machines Ltd.,”，当时它是三家公司的合资——它们分别是苹果电脑，Acorn电脑公司，以及VLSI技术（公司）。</p><p>ARM的版本分为两类，一个是内核版本，一个处理器版本。</p><ul><li>内核版本也就是ARM架构，如ARMv1、ARMv2、ARMv3、ARMv4、ARMv5、ARMv6、ARMv7、ARMv8等。</li><li>处理器版本也就是ARM处理器，如ARM1、ARM9、ARM11、ARM Cortex-A（A7、A9、A15），ARM Cortex-M（M1、M3、M4）、ARM Cortex-R，这个也是我们通常意义上所指的ARM版本。</li></ul><h2 id="2-ARM架构与处理器的关系"><a href="#2-ARM架构与处理器的关系" class="headerlink" title="2.ARM架构与处理器的关系"></a>2.ARM架构与处理器的关系</h2><p>基于不同的ARM架构可以设计出不同特点的ARM处理器。比如基于ARMv3架构设计出的处理器ARM6、ARM7，这两款处理器适用于不同的场景，硬件可能不同，但是架构指令集是一样的。</p><p>举个例子，比如说盖房子，早期因为发展落后，盖的都是平房，这就是一种架构(ARMv5)，然后这种平房架构你可以设计出一款三室一厅的款式， 这叫ARM7处理器。 然后其他人(芯片设计公司)想盖房子的就买你这个款式去盖，接着过一段时间，有人觉得光三室一厅的不好， 我还想每个房间有独立卫! 于是，ARM就满足你们的要求，出个独卫的款式(ARM9)。</p><p>即ARMv5等是指令集的架构，ARM7&#x2F;9等是基于架构设计出的内核处理器。ARM的架构都是基于RISC指令集而设计的，内核处理器是实现这一指令集的硬件架构的基础。</p><h2 id="3-ARM版本"><a href="#3-ARM版本" class="headerlink" title="3.ARM版本"></a>3.ARM版本</h2><p><img src="/./../photo/a.png"></p><p>最近的几年，基于从ARMv6开始的新设计理念，ARM进一步扩展了它的CPU设计，成果 就是ARMv7架构的闪亮登场。在这个版本中，内核架构首次从单一款式变成3种款式。 </p><ul><li><p>款式A：设计用于高性能的“开放应用平台”——越来越接近电脑了 </p></li><li><p>款式R：用于高端的嵌入式系统，尤其是那些带有实时要求的——又要快又要实时。 </p></li><li><p>款式M：用于深度嵌入的，单片机风格的系统中——本文章主要讲解的知识。</p></li></ul><p>让我们再进距离地考察这3种款式： </p><ul><li>款式A（ARMv7‐A）：需要运行复杂应用程序的“应用处理器” 。支持大型嵌入式操作系统，比如Symbian（诺基亚智能手机用），Linux，以及微软 的Windows CE和智能手机操作系统Windows Mobile。这些应用需要劲爆的处理性能，并 且需要硬件MMU实现的完整而强大的虚拟内存机制，还基本上会配有Java支持，有时 还要求一个安全程序执行环境。典型的产品包括高端手机和手持仪器，电子钱包以及金融事务处理机。 </li><li>款式R（ARMv7‐R）：硬实时且高性能的处理器。标的是高端实时市场。那些高级的玩意，像高档轿车的组件，大型发电机控制器，机器手臂控制器等，它们使用的处理 器不但要很好很强大，还要极其可靠，对事件的反应也要极其敏捷。 </li><li>款式M（ARMv7‐M）：认准了旧世代单片机的应用而量身定制。在这些应用中，尤其是 对于实时控制系统，低成本、低功耗、极速中断反应以及高处理效率，都是至关重要的。  Cortex系列是v7架构的第一次亮相，其中Cortex‐M3就是按款式M设计的。</li></ul><h1 id="第二章-ARM基础知识"><a href="#第二章-ARM基础知识" class="headerlink" title="第二章 ARM基础知识"></a>第二章 ARM基础知识</h1><h2 id="1-哈弗架构与冯诺伊曼架构"><a href="#1-哈弗架构与冯诺伊曼架构" class="headerlink" title="1.哈弗架构与冯诺伊曼架构"></a>1.<strong>哈弗架构与冯诺伊曼架构</strong></h2><p>CPU架构可以分为哈弗架构与冯诺伊曼架构，如下图所示。</p><ul><li><p><strong>哈弗架构</strong>中指令与数据分开存放，CPU可以同时读入指令、读写数据。</p><p><img src="/./../photo/b.png"></p></li><li><p><strong>冯诺伊曼架构</strong>中指令、数据混合存放，CPU依次读取指令、读写数据，不可同时操作指令和数据。</p><p><img src="/./../photo/c.png"></p></li></ul><blockquote><p>Cortex‐M3采用了哈佛结构，拥有独立的指令总线和数据总线，可以让取指与数据访问 并行不悖。</p></blockquote><h2 id="2-RISC与CISC"><a href="#2-RISC与CISC" class="headerlink" title="2. RISC与CISC"></a>2. RISC与CISC</h2><ul><li><strong>复杂指令集CISC</strong>:   以Intel、AMD的X86 CPU为代表，CISC也是要通过操作内存、寄存器、运算器来完成复杂指令的。它在实现时，是将复杂指令转换成了一个微程序，微程序在制造CPU时就已存储于微服务存储器。一个微程序包含若干条微指令（也称微码），执行复杂指令时，实际上是在执行一个微程序。这也带来两种指令集的一个差别，微程序的执行是不可被打断的，而RISC指令之间可以被打断，所以理论上RISC可更快响应中断。特点：</li><li><strong>精简指令集RISC</strong>：以ARM、IBM Power为代表，设计初衷针对CISC CPU复杂的弊端，选择一些可以在单个CPU周期完成的指令，以降低CPU的复杂度，将复杂性交给编译器</li></ul><blockquote><p><strong>ARM公司的芯片都使用RISC指令集，对内存只有load&#x2F;store操作，数据的处理是在CPU寄存器上进行。</strong></p></blockquote><ul><li>二者的比较：<ul><li>CISC的指令能力强，单多数指令使用率低却增加了CPU的复杂度，指令是可变长格式；</li><li>RISC的指令大部分为单周期指令，指令长度固定，操作寄存器，对于内存只有Load&#x2F;Store操作</li><li>CISC支持多种寻址方式；RISC支持的寻址方式</li><li>CISC通过微程序控制技术实现；</li><li>RISC增加了通用寄存器，硬布线逻辑控制为主，采用流水线</li><li>CISC的研制周期长</li><li>RISC优化编译，有效支持高级语言</li></ul></li></ul><h1 id="第三章-ARM-寄存器"><a href="#第三章-ARM-寄存器" class="headerlink" title="第三章 ARM 寄存器"></a>第三章 ARM 寄存器</h1><p>这里以Cortex‐M3 &#x2F;Cortex‐M4&#x2F;Cortex‐A7处理器为例，他们拥有 R0‐R15 的寄存器组。其中 R13 作为堆栈指针 SP。SP 有两个，但在同一 时刻只能有一个可以看到，这也就是所谓的“banked”寄存器。</p><p><img src="/./../photo/image-20231021162714042.png" alt="image-20231021162714042"></p><ul><li>R0-R12：通用寄存器 ，R0‐R12 都是 32 位通用寄存器，用于数据操作。但是注意：绝大多数 16 位 Thumb 指令只能访 问 R0‐R7，而 32 位 Thumb‐2 指令可以访问所有寄存器。</li><li>Banked R13: 两个堆栈指针 <ul><li>主堆栈指针（MSP）：复位后缺省使用的堆栈指针，用于操作系统内核以及异常处理例程（包 括中断服务例程） </li><li>进程堆栈指针（PSP）：由用户的应用程序代码使用。</li></ul></li><li>R14：连接寄存器，当呼叫一个子程序时，由 R14 存储返回地址 </li><li>R15：程序计数寄存器 ，指向当前的程序地址。如果修改它的值，就能改变程序的执行流</li><li>特殊功能寄存器 <ul><li>程序状态字寄存器组（PSRs）  </li><li>中断屏蔽寄存器组（PRIMASK, FAULTMASK, BASEPRI）  </li><li>控制寄存器（CONTROL）</li></ul></li></ul><p><img src="/./../photo/image-20231021163136833.png" alt="image-20231021163136833"></p><p>功能如下表：</p><p><img src="/./../photo/image-20231021163233661.png" alt="image-20231021163233661"></p><h1 id="第四章-ARM汇编"><a href="#第四章-ARM汇编" class="headerlink" title="第四章 ARM汇编"></a>第四章 ARM汇编</h1><h2 id="1-ARM汇编概述"><a href="#1-ARM汇编概述" class="headerlink" title="1.ARM汇编概述"></a>1.ARM汇编概述</h2><p>①最初，ARM公司发布两类指令集：</p><ul><li><p><strong>Thumb指令集：</strong>这是16位的，每条指令占据16位，节省空间</p></li><li><p><strong>ARM指令集：</strong>这是32位的，每条指令占据32位，高效，但是太占空间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV R1, #1;Thumb指令：len(mov) + len(r1) + len(立即数) = 16bit<br>MOV R1, #1;ARM指令：len(mov) + len(r1) + len(立即数) = 32bit<br></code></pre></td></tr></table></figure></li></ul><p>要节省空间时用Thumb指令，要效率时用ARM指令</p><p>②一个CPU既可以运行Thumb指令，也能运行ARM指令。怎么区分当前指令是Thumb还是ARM指令呢？</p><p>​程序状态寄存器中有一位，名为“T”，它等于1时表示当前运行的是Thumb指令。</p><p>③假设函数A是使用Thumb指令写的，函数B是使用ARM指令写的，怎么调用A&#x2F;B？</p><p>​我们可以往PC寄存器里写入函数A或B的地址，就可以调用A或B，</p><p>④但是怎么让CPU在执行A函数是进入Thumb状态，在执行B函数时进入ARM状态？</p><p>​做个手脚：</p><p>​调用函数A时，让PC寄存器的BIT0等于1，即：PC&#x3D;函数A地址+(1&lt;&lt;0)；</p><p>​调用函数B时，让PC寄存器的BIT0等于0:，即：PC&#x3D;函数B地址</p><p>⑤但是这样做太麻烦，于是引入Thumb2指令集</p><ul><li><strong>Thumb2指令集：</strong>它支持16位指令、32位指令混合编程。</li></ul><h2 id="2-区分指令集"><a href="#2-区分指令集" class="headerlink" title="2.区分指令集"></a>2.区分指令集</h2><p>ARM公司推出了： Unified Assembly Language UAL，统一汇编语言，我们不需要去区分这些指令集</p><p>我们只需要在程序前面用CODE32&#x2F;CODE16&#x2F;THUMB表示指令集:ARM&#x2F;Thumb&#x2F;Thumb2</p><h2 id="3-汇编指令格式"><a href="#3-汇编指令格式" class="headerlink" title="3.汇编指令格式"></a>3.汇编指令格式</h2><blockquote><p>参考《DEN0013D_cortex_a_series_PG.pdf》P70</p><p>《ARM Cortex-M3与Cortex-M4权威指南.pdf》第5章汇编指令可以分为几大类：数据处理、内存访问、跳转、饱和运算、其他指令</p></blockquote><p>以“数据处理”指令为例，UAL汇编格式为：</p><p><img src="/./../photo/image-20231021175310394.png" alt="image-20231021175310394"></p><ul><li><p>Operation表示各类汇编指令，比如ADD、MOV；</p></li><li><p>cond表示conditon，即该指令执行的条件；</p></li><li><p>S表示该指令执行后，会去修改程序状态寄存器；</p></li><li><p>Rd为目的寄存器，用来存储运算的结果；</p></li><li><p>Rn、Operand2是两个源操作数</p></li></ul><h2 id="4-常用汇编指令"><a href="#4-常用汇编指令" class="headerlink" title="4.常用汇编指令"></a>4.常用汇编指令</h2><h3 id="1-内存访问指令"><a href="#1-内存访问指令" class="headerlink" title="1.内存访问指令"></a>1.内存访问指令</h3><p>加载指令LDR：Load Register</p><p>读多个寄存器</p><p>存储指令STR：Store Register</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0X20000<br>LDR R1, =0X1234<br>STR R1,[R0]      ;将R1里面的值写入到R0指向的地址里<br><br>LDMIA R0!, &#123; R4-R11 &#125;;lrmia: ldr mutiple inc after<br>;ldr r0 [r4]   r0 = r0 + 4<br>;ldr r0 [r5]   r0 = r0 + 4<br></code></pre></td></tr></table></figure><h3 id="2-数据处理指令"><a href="#2-数据处理指令" class="headerlink" title="2.数据处理指令"></a>2.数据处理指令</h3><p>加法指令ADD</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV R2,#1<br>MOV R3,#2<br>ADD R1,R2,R3;R1 = R2 + R3<br></code></pre></td></tr></table></figure><p>减法指令SUB</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">MOV R2,#1<br>MOV R3,#2<br>ADD R1,R3,R2;R1 = R3 - R2<br></code></pre></td></tr></table></figure><p>位操作指令AND&#x2F;BIC&#x2F;ORR</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0XFFFFFFFF<br>AND R0,R0,#(1&lt;&lt;4);与：只保留第四位<br>LDR R0, =0XFFFFFFFF<br>BIC R0,R0,#(1&lt;&lt;4);位清除：清除第四位<br>LDR R0, =0<br>ORR R0,#(1&lt;&lt;2|1&lt;&lt;3);或：设置第2、3位为1<br></code></pre></td></tr></table></figure><p>比较指令CMP&#x2F;TST</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asm">LDR R0, =0X12<br>LDR R1, =0X12<br>CMP R0,R1;比较R0-R1里面的结果，结果存放在程序装载寄存器<br>MOVEQ R0, #2；如果相等，执行这条指令，R0=2<br><br>TST R0,R1;测试R0&amp;R1的结果<br></code></pre></td></tr></table></figure><h3 id="3-跳转指令"><a href="#3-跳转指令" class="headerlink" title="3.跳转指令"></a>3.跳转指令</h3><ul><li><p>B：Branch，跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">B Delay<br>Delay<br>MOV R0, #5<br>Loop<br>SUBS R0,R0,#1<br>BNE Loop;不等于0就一直循环<br>MOV PC, LR;结束，将LR值返回给PC<br></code></pre></td></tr></table></figure></li><li><p>BL：Branch with Link，跳转前先把返回地址保持在LR寄存器中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asm">BL Delay<br>MOV R1, #1;执行完之后会直接跳转到这条指令 PC=LR+4<br>Delay<br>MOV R0, #5<br>Loop<br>SUBS R0,R0,#1<br>BNE Loop;不等于0就一直循环<br>MOV PC, LR;结束，将LR值返回给PC<br></code></pre></td></tr></table></figure></li><li><p>BX：Branch and eXchange，根据跳转地址的BIT0切换为ARM或Thumb状态(0：ARM状态，1：Thumb状态)</p></li><li><p>BLX：Branch with Link and eXchange ，根据跳转地址的BIT0切换为ARM或Thumb状态(0：ARM状态，1：Thumb状态)#</p></li></ul><h3 id="4-CPU操作指令"><a href="#4-CPU操作指令" class="headerlink" title="4.CPU操作指令"></a>4.CPU操作指令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">;开启CPU接收中断<br>cpsie i<br>cpsie f<br><br>;存储器屏蔽指令:确保前面的指令和数据都处理完成<br>dsb;数据同步屏蔽<br>isb;指令同步屏蔽<br></code></pre></td></tr></table></figure><h1 id="五、异常与中断"><a href="#五、异常与中断" class="headerlink" title="五、异常与中断"></a>五、异常与中断</h1><h2 id="1-异常与中断的概念引入与处理流程"><a href="#1-异常与中断的概念引入与处理流程" class="headerlink" title="1.异常与中断的概念引入与处理流程"></a>1.异常与中断的概念引入与处理流程</h2><h3 id="1-1-使用生活实例引入中断"><a href="#1-1-使用生活实例引入中断" class="headerlink" title="1.1 使用生活实例引入中断"></a>1.1 使用生活实例引入中断</h3><p><img src="/./../photo/001_mother_son.png"></p><p>假设有个大房间里面有小房间，婴儿正在睡觉，他的妈妈在外面看书。<br>问：这个母亲怎么才能知道这个小孩醒？</p><ol><li>过一会打开一次房门，看婴儿是否睡醒，然后接着看书</li><li>一直等到婴儿发出声音以后再过去查看，期间都在读书</li></ol><p>第一种方法叫做<strong>查询方式</strong>：</p><ul><li>优点：简单 </li><li>缺点： 累</li></ul><p>如何写程序？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br><span class="hljs-number">1</span> read <span class="hljs-title function_">book</span><span class="hljs-params">(读书)</span><br>2 open <span class="hljs-title function_">door</span><span class="hljs-params">(开门)</span><br>  <span class="hljs-title function_">if</span><span class="hljs-params">(小孩还在睡)</span><br> <span class="hljs-title function_">return</span><span class="hljs-params">(继续读书)</span><br>   <span class="hljs-keyword">else</span><br> 照顾小孩<br>&#125;<br></code></pre></td></tr></table></figure><p>第二种方法叫<strong>中断方式</strong>：</p><ul><li>优点：不累</li><li>缺点：复杂</li></ul><p>如何写程序：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>&#123;<br>read book<br>&#125;<br>中断服务程序() <span class="hljs-comment">//核心问题：如何被调用？</span><br>&#123;<br>处理照顾小孩<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-母亲如何处理中断"><a href="#1-2-母亲如何处理中断" class="headerlink" title="1.2 母亲如何处理中断"></a>1.2 母亲如何处理中断</h3><p>我们还是看看母亲被小孩哭声打断如何照顾小孩？</p><p>母亲的处理过程</p><ul><li>平时看书</li><li>发生了各种声音，如何处理这些声音<ul><li>有远处的猫叫（听而不闻，忽略）</li><li>门铃声有快递（开门收快递）</li><li>小孩哭声（打开房门，照顾小孩）</li></ul></li><li>母亲的处理<ul><li>只会处理门铃声和小孩哭声<ul><li>先在书中放入书签，合上书(保存现场)</li><li>去处理 (调用对应的中断服务程序)</li><li>继续看书(恢复现场)</li></ul></li></ul></li></ul><p>不同情况，不同处理</p><ul><li>对于门铃：开门取快件</li><li>对于哭声:照顾小孩</li></ul><h3 id="1-3-ARM系统中异常与中断处理流程"><a href="#1-3-ARM系统中异常与中断处理流程" class="headerlink" title="1.3 ARM系统中异常与中断处理流程"></a>1.3 ARM系统中异常与中断处理流程</h3><p>我们将母亲的处理过程抽象化：</p><ul><li>母亲的头脑相当于CPU<ul><li>耳朵听到声音会发送信号给脑袋</li><li>声音来源有很多种<ul><li>有远处的猫叫，门铃声，小孩哭声</li></ul></li><li>这些声音传入耳朵，再由耳朵传给大脑</li><li>除了这些可以中断母亲的看书，还有其他情况，比如：<ul><li>身体不舒服</li><li>有只蜘蛛掉下来</li><li>对于特殊情况无法回避，必须立即处理</li></ul></li></ul></li></ul><p>对于arm系统，异常与中断的硬件框图如下：</p><p><img src="/./../photo/002_exception_on_arm.png"></p><p>所有的中断源(按键、定时器等)，它们发出的中断汇聚到<strong>中断控制器</strong>，<br>再由中断控制器发信号给CPU，告诉它发生了那些紧急情况。</p><p>除了这些中断，还有什么可以打断CPU的运行？</p><ul><li>指令不对</li><li>数据访问有问题</li><li>reset信号</li><li>等等，这些都可以打断断CPU，这些被称为<strong>异常</strong></li><li>中断属于一种异常</li></ul><p>ARM系统中如何处理异常与中断？重点在于<strong>保存现场</strong>以及<strong>恢复现场</strong>，<br>处理过程如下：</p><ul><li>保存现场(各种寄存器)</li><li>处理异常(中断属于一种异常)</li><li>恢复现场</li></ul><p>细化一下，在ARM系统中如何使用异常(中断)？</p><ul><li><p>初始化</p><ul><li>设置中断源，让它可以产生中断</li><li>设置中断控制器(可以屏蔽某个中断，优先级)</li><li>设置CPU总开关，使能中断</li></ul></li><li><p>执行其他程序：正常程序</p></li><li><p>产生中断，举例：按下按键—&gt;中断控制器—&gt;CPU</p></li><li><p>cpu每执行完一条指令都会检查有无中断&#x2F;异常产生</p></li><li><p>发现有中断&#x2F;异常产生，开始处理：</p><ul><li>保存现场</li><li>分辨异常&#x2F;中断，调用对于异常&#x2F;中断的处理函数</li><li>恢复现场</li></ul></li></ul><p>不同的芯片，不同的架构，在这方面的处理稍有差别：</p><ul><li><p>保存&#x2F;恢复现场：cortex M3&#x2F;M4是硬件实现的，cortex A7是软件实现的</p></li><li><p>CPU中止当前执行，跳转去执行处理异常的代码：也有差异</p><ul><li><p>cortex M3&#x2F;M4在向量表上放置的是函数地址</p></li><li><p>cortex A7在向量表上放置的是跳转指令</p></li></ul></li></ul><h2 id="2-ARM架构中异常与中断的处理"><a href="#2-ARM架构中异常与中断的处理" class="headerlink" title="2.ARM架构中异常与中断的处理"></a>2.ARM架构中异常与中断的处理</h2><h3 id="1-1-处理流程是一样的"><a href="#1-1-处理流程是一样的" class="headerlink" title="1.1 处理流程是一样的"></a>1.1 处理流程是一样的</h3><ul><li>每执行完一条指令都会检查有无中断&#x2F;异常产生</li><li>发现有中断&#x2F;异常产生，开始处理：<ul><li>保存现场</li><li>分辨异常&#x2F;中断，调用对应的异常&#x2F;中断处理函数</li><li>恢复现场</li></ul></li></ul><p>不同的芯片，不同的架构，在这方面的处理稍有差别：</p><ul><li><p>CPU中止当前执行，跳转去执行处理异常的代码：也有差异</p><ul><li>cortex M3&#x2F;M4在向量表上放置的是函数地址</li><li>cortex A7在向量表上放置的是跳转指令</li></ul></li><li><p>保存&#x2F;恢复现场：cortex M3&#x2F;M4是硬件实现的，cortex A7是软件实现的</p></li></ul><h3 id="1-2-cortex-M3-M4"><a href="#1-2-cortex-M3-M4" class="headerlink" title="1.2 cortex M3&#x2F;M4"></a>1.2 cortex M3&#x2F;M4</h3><p>参考资料：<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>PM0056.pdf</code></p><p>要想理解这个处理流程，需要从向量表说起。<br>向量，在数学定义里是<strong>有方向的量</strong>，在程序里可以认为向量就是一个数组，里面有多个项。<br>在ARM架构里，对于异常&#x2F;中断，它们的<strong>处理入口</strong>会整齐地排放在一起。</p><h4 id="1-2-1-M3-M4的向量表"><a href="#1-2-1-M3-M4的向量表" class="headerlink" title="1.2.1 M3&#x2F;M4的向量表"></a>1.2.1 M3&#x2F;M4的向量表</h4><p>M3&#x2F;M4的向量表中，放置的是具体异常&#x2F;中断的处理函数的地址。<br>比如发生<code>Reset</code>异常时，CPU就会从向量表里找到第1项，得到Reset_Handler函数的地址，跳转去执行。<br>比如发生<code>EXTI Line 0</code>中断时，CPU就会从向量表里找到第22项，得到EXTI0_IRQHandler函数的地址，跳转去执行。</p><ul><li>跳转之前，硬件会保存现场</li><li>函数执行完毕，返回之后，硬件会恢复现场</li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment">; Vector Table Mapped to Address 0 at Reset</span><br>                AREA    RESET, DATA, READONLY<br>                EXPORT  __Vectors<br>                EXPORT  __Vectors_End<br>                EXPORT  __Vectors_Size<br><br>__Vectors       DCD     __initial_sp               <span class="hljs-comment">; Top of Stack</span><br>                DCD     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><br>                DCD     NMI_Handler                <span class="hljs-comment">; NMI Handler</span><br>                DCD     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                DCD     MemManage_Handler          <span class="hljs-comment">; MPU Fault Handler</span><br>                DCD     <span class="hljs-keyword">BusFault_Handler </span>          <span class="hljs-comment">; Bus Fault Handler</span><br>                DCD     UsageFault_Handler         <span class="hljs-comment">; Usage Fault Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     SVC_Handler                <span class="hljs-comment">; SVCall Handler</span><br>                DCD     DebugMon_Handler           <span class="hljs-comment">; Debug Monitor Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     PendSV_Handler             <span class="hljs-comment">; PendSV Handler</span><br>                DCD     SysTick_Handler            <span class="hljs-comment">; SysTick Handler</span><br><br>                <span class="hljs-comment">; External Interrupts</span><br>                DCD     WWDG_IRQHandler            <span class="hljs-comment">; Window Watchdog</span><br>                DCD     PVD_IRQHandler             <span class="hljs-comment">; PVD through EXTI Line detect</span><br>                DCD     TAMPER_IRQHandler          <span class="hljs-comment">; Tamper</span><br>                DCD     RTC_IRQHandler             <span class="hljs-comment">; RTC</span><br>                DCD     FLASH_IRQHandler           <span class="hljs-comment">; Flash</span><br>                DCD     RCC_IRQHandler             <span class="hljs-comment">; RCC</span><br>                DCD     <span class="hljs-keyword">EXTI0_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 0</span><br>                DCD     <span class="hljs-keyword">EXTI1_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 1</span><br>                DCD     <span class="hljs-keyword">EXTI2_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 2</span><br>                DCD     <span class="hljs-keyword">EXTI3_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 3</span><br>                DCD     <span class="hljs-keyword">EXTI4_IRQHandler </span>          <span class="hljs-comment">; EXTI Line 4</span><br>                DCD     DMA1_Channel1_IRQHandler   <span class="hljs-comment">; DMA1 Channel 1</span><br>                DCD     DMA1_Channel2_IRQHandler   <span class="hljs-comment">; DMA1 Channel 2</span><br>                DCD     DMA1_Channel3_IRQHandler   <span class="hljs-comment">; DMA1 Channel 3</span><br>                DCD     DMA1_Channel4_IRQHandler   <span class="hljs-comment">; DMA1 Channel 4</span><br>                DCD     DMA1_Channel5_IRQHandler   <span class="hljs-comment">; DMA1 Channel 5</span><br>                DCD     DMA1_Channel6_IRQHandler   <span class="hljs-comment">; DMA1 Channel 6</span><br>                DCD     DMA1_Channel7_IRQHandler   <span class="hljs-comment">; DMA1 Channel 7</span><br>                DCD     ADC1_2_IRQHandler          <span class="hljs-comment">; ADC1 &amp; ADC2</span><br>                DCD     USB_HP_CAN1_TX_IRQHandler  <span class="hljs-comment">; USB High Priority or CAN1 TX</span><br>                DCD     USB_LP_CAN1_RX0_IRQHandler <span class="hljs-comment">; USB Low  Priority or CAN1 RX0</span><br>                DCD     CAN1_RX1_IRQHandler        <span class="hljs-comment">; CAN1 RX1</span><br>                DCD     CAN1_SCE_IRQHandler        <span class="hljs-comment">; CAN1 SCE</span><br>                DCD     <span class="hljs-keyword">EXTI9_5_IRQHandler </span>        <span class="hljs-comment">; EXTI Line 9..5</span><br>                DCD     TIM1_BRK_IRQHandler        <span class="hljs-comment">; TIM1 Break</span><br>                DCD     TIM1_UP_IRQHandler         <span class="hljs-comment">; TIM1 Update</span><br>                DCD     TIM1_TRG_COM_IRQHandler    <span class="hljs-comment">; TIM1 Trigger and Commutation</span><br>                DCD     TIM1_CC_IRQHandler         <span class="hljs-comment">; TIM1 Capture Compare</span><br>                DCD     TIM2_IRQHandler            <span class="hljs-comment">; TIM2</span><br>                DCD     TIM3_IRQHandler            <span class="hljs-comment">; TIM3</span><br>                DCD     TIM4_IRQHandler            <span class="hljs-comment">; TIM4</span><br>                DCD     I2C1_EV_IRQHandler         <span class="hljs-comment">; I2C1 Event</span><br>                DCD     I2C1_ER_IRQHandler         <span class="hljs-comment">; I2C1 Error</span><br>                DCD     I2C2_EV_IRQHandler         <span class="hljs-comment">; I2C2 Event</span><br>                DCD     I2C2_ER_IRQHandler         <span class="hljs-comment">; I2C2 Error</span><br>                DCD     SPI1_IRQHandler            <span class="hljs-comment">; SPI1</span><br>                DCD     SPI2_IRQHandler            <span class="hljs-comment">; SPI2</span><br>                DCD     USART1_IRQHandler          <span class="hljs-comment">; USART1</span><br>                DCD     USART2_IRQHandler          <span class="hljs-comment">; USART2</span><br>                DCD     USART3_IRQHandler          <span class="hljs-comment">; USART3</span><br>                DCD     <span class="hljs-keyword">EXTI15_10_IRQHandler </span>      <span class="hljs-comment">; EXTI Line 15..10</span><br>                DCD     RTCAlarm_IRQHandler        <span class="hljs-comment">; RTC Alarm through EXTI Line</span><br>                DCD     USBWakeUp_IRQHandler       <span class="hljs-comment">; USB Wakeup from suspend</span><br>                DCD     TIM8_BRK_IRQHandler        <span class="hljs-comment">; TIM8 Break</span><br>                DCD     TIM8_UP_IRQHandler         <span class="hljs-comment">; TIM8 Update</span><br>                DCD     TIM8_TRG_COM_IRQHandler    <span class="hljs-comment">; TIM8 Trigger and Commutation</span><br>                DCD     TIM8_CC_IRQHandler         <span class="hljs-comment">; TIM8 Capture Compare</span><br>                DCD     ADC3_IRQHandler            <span class="hljs-comment">; ADC3</span><br>                DCD     FSMC_IRQHandler            <span class="hljs-comment">; FSMC</span><br>                DCD     SDIO_IRQHandler            <span class="hljs-comment">; SDIO</span><br>                DCD     TIM5_IRQHandler            <span class="hljs-comment">; TIM5</span><br>                DCD     SPI3_IRQHandler            <span class="hljs-comment">; SPI3</span><br>                DCD     UART4_IRQHandler           <span class="hljs-comment">; UART4</span><br>                DCD     UART5_IRQHandler           <span class="hljs-comment">; UART5</span><br>                DCD     TIM6_IRQHandler            <span class="hljs-comment">; TIM6</span><br>                DCD     TIM7_IRQHandler            <span class="hljs-comment">; TIM7</span><br>                DCD     DMA2_Channel1_IRQHandler   <span class="hljs-comment">; DMA2 Channel1</span><br>                DCD     DMA2_Channel2_IRQHandler   <span class="hljs-comment">; DMA2 Channel2</span><br>                DCD     DMA2_Channel3_IRQHandler   <span class="hljs-comment">; DMA2 Channel3</span><br>                DCD     DMA2_Channel4_5_IRQHandler <span class="hljs-comment">; DMA2 Channel4 &amp; Channel5</span><br>__Vectors_End<br></code></pre></td></tr></table></figure><h4 id="1-2-2-M3-M4的异常-中断处理流程"><a href="#1-2-2-M3-M4的异常-中断处理流程" class="headerlink" title="1.2.2 M3&#x2F;M4的异常&#x2F;中断处理流程"></a>1.2.2 M3&#x2F;M4的异常&#x2F;中断处理流程</h4><p>发生异常&#x2F;中断时，硬件上实现了这些事情：</p><ul><li><p>保存现场：把被中断瞬间的寄存器的值保存进栈里</p></li><li><p>根据异常&#x2F;中断号，从向量表中得到<strong>函数地址</strong>，跳转过去执行</p></li><li><p>函数执行完后，从栈中恢复现场</p></li></ul><p>保存现场、分辨异常&#x2F;中断、跳转执行，都是硬件实现的。<br>我们只需要在向量表中，把处理函数的地址填进去就可以了。</p><p><strong>硬件</strong>承包了大部分的工作。</p><p>M3&#x2F;M4的向量表中，存放的是<strong>函数地址</strong>。</p><h3 id="1-3-cortex-A7"><a href="#1-3-cortex-A7" class="headerlink" title="1.3 cortex A7"></a>1.3 cortex A7</h3><p>参考资料：<code>ARM ArchitectureReference Manual ARMv7-A and ARMv7-R edition.pdf</code></p><p>实际上，以前的S3C2440属于ARM9处理器，它的异常&#x2F;中断处理流程给cortex A7是一样的。</p><h4 id="1-3-1-A7的向量表"><a href="#1-3-1-A7的向量表" class="headerlink" title="1.3.1 A7的向量表"></a>1.3.1 A7的向量表</h4><p>A7的向量表中，放置的是某类异常的<strong>跳转指令</strong>。<br>比如发生<code>Reset</code>异常时，CPU就会从向量表里找到第0项，得到<code>b reset</code>指令，执行后就跳转到reset函数。<br>比如发生任何的中断时，CPU就会从向量表里找到第6项，得到<code>ldrpc, _irq</code>指令，执行后就跳转到_irq函数。</p><ul><li>跳转之前，硬件只会保存CPSR寄存器</li><li>跳转之后，软件要保存现场</li><li>函数执行完毕，返回之前，软件恢复现场</li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">_start:</span> <br>    <span class="hljs-keyword">b</span>reset<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _undefined_instruction<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _software_interrupt<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _prefetch_abort<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _data_abort<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _not_used<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _irq<br><span class="hljs-keyword">ldr</span><span class="hljs-built_in">pc</span>, _fiq<br></code></pre></td></tr></table></figure><h4 id="1-3-2-A7的异常-中断处理流程"><a href="#1-3-2-A7的异常-中断处理流程" class="headerlink" title="1.3.2 A7的异常&#x2F;中断处理流程"></a>1.3.2 A7的异常&#x2F;中断处理流程</h4><p>发生异常&#x2F;中断时，硬件上实现了这些事情：</p><ul><li><p>CPU切换到对应的异常模式，比如IRQ模式、未定义模式、SVC模式</p></li><li><p>保存被中断时的CPSR到SPSR</p><ul><li>CPSR：current program status register，当前程序状态寄存器</li><li>SRSR：saved program status register，保存的程序状态寄存器</li></ul></li><li><p>跳到这个异常的入口地址去，执行<strong>指令</strong>，这通常是一条跳转指令</p></li></ul><p>软件要做的事情就比较多了：</p><ul><li>保存现场</li><li>分辨异常&#x2F;中断</li><li>调用对应的处理函数</li><li>恢复现场</li></ul><p>A7的向量表中，存放的是<strong>跳转指令</strong>。</p><h2 id="3-异常处理深入分析-保存现场"><a href="#3-异常处理深入分析-保存现场" class="headerlink" title="3.异常处理深入分析_保存现场"></a>3.异常处理深入分析_保存现场</h2><h3 id="1-1-回顾一下处理流程"><a href="#1-1-回顾一下处理流程" class="headerlink" title="1.1 回顾一下处理流程"></a>1.1 回顾一下处理流程</h3><p>CPU每执行完一条指令都会检查有无中断&#x2F;异常产生，发现有中断&#x2F;异常产生，开始处理：</p><ul><li>保存现场</li><li>分辨异常&#x2F;中断，调用对应的异常&#x2F;中断处理函数</li><li>恢复现场</li></ul><p>对于不用的处理器，具体的处理工作有差别：</p><ul><li>保存现场：cortex M3&#x2F;M4里是硬件完成，cortex A7等是软件实现</li><li>分辨异常&#x2F;中断：cortex M3&#x2F;M4里是硬件完成，cortex A7等是软件实现</li><li>调用处理函数：cortex M3&#x2F;M4里是硬件来调用，cortex A7等是软件自己去调用</li><li>恢复现场：cortex M3&#x2F;M4里是软件触发、硬件实现，cortex A7等是软件实现</li></ul><p>不管是硬件还是软件实现，第一步都是<strong>保存现场</strong>。</p><h3 id="1-2-为什么要保存现场"><a href="#1-2-为什么要保存现场" class="headerlink" title="1.2 为什么要保存现场"></a>1.2 为什么要保存现场</h3><p><img src="/./../photo/008_save_register.png"></p><p>任何程序，最终都会转换为机器码，上述C代码可以转换为右边的汇编指令。<br>对于这4条指令，它们可能随时被异常打断，怎么保证异常处理完后，被打断的程序还能正确运行？</p><ul><li><p>这4条指令涉及R0、R1寄存器，程序被打断时、恢复运行时，R0、R1要保持不变</p></li><li><p>执行完第3条指令时，比较结果保存在<strong>程序状态寄存器</strong>里，程序被打断时、恢复运行时，程序状态寄存器保持不变</p></li><li><p>这4条指令，读取a、b内存，程序被打断时、恢复运行时，a、b内存保持不变</p></li></ul><p>内存保持不变，这很容易实现，程序不越界就可以。<br>所以，关键在于R0、R1、程序状态寄存器要保持不变(当然不止这些寄存器)：</p><ul><li>在处理异常前，把这些寄存器保存在栈中，这称为<strong>保存现场</strong></li><li>在处理完异常后，从栈中恢复这些寄存器，这称为<strong>恢复现场</strong></li></ul><h3 id="1-3-保存现场"><a href="#1-3-保存现场" class="headerlink" title="1.3 保存现场"></a>1.3 保存现场</h3><p>ARM处理器中有这些寄存器：<br><img src="/./../photo/003_cpu_register.png"></p><p>在arm中有个ATPCS规则(ARM-THUMB procedure call standard（ARM-Thumb过程调用标准）。<br>约定R0-R15寄存器的用途：</p><ul><li><p>R0-R3</p><p>调用者和被调用者之间传参数</p></li><li><p>R4-R11</p><p>函数可能被使用，所以在函数的入口保存它们，在函数的出口恢复它们。</p></li></ul><p><img src="/./../photo/004_atpcs.png"></p><p>还有一个<strong>程序状态寄存器</strong>，对于M3&#x2F;M4它被称为<strong>XPSR</strong>，对于A7它被称为<strong>CPSR</strong>，我们简称为PSR。<br>R0-R15、PSR，就是所谓的<strong>现场</strong>。<br>发生异常&#x2F;中断后，在处理异常&#x2F;中断前，需要<strong>保存现场</strong>，难道需要保存所有这些寄存器吗？<br>不需要！<br>在C函数中，可以修改R0-R3、R12、R14(LR)以及PSR。如果C函数要用到这些寄存器，就要把它们保存到栈里，在函数结束前在从栈中恢复它们。<br>这些寄存器被拆分成2部分：**调用者保存的寄存器(R0-R3,R12,LR,PSR)<strong>、</strong>被调用者保存的寄存器(R4-R11)**。<br>比如函数A调用函数B，函数A应该知道：</p><ul><li>R0-R3是用来传参数给函数B的</li><li>函数B可以肆意修改R0-R3</li><li>函数A不要指望函数B帮你保存R0-R3</li><li>保存R0-R3，是函数A的事情</li><li>对于LR、PSR也是同样的道理，保存它们是函数A的责任</li></ul><p>对于函数B：</p><ul><li>我用到R4-R11中的某一个，我都会在函数入口保存、在函数返回前恢复</li><li>保证在B函数调用前后，函数A看到的R4-R11保存不变</li></ul><p>假设函数B就是异常&#x2F;中断处理函数，函数B本身能保证R4-R11不变，那么保存现场时，只需要保存这些：</p><ul><li>调用者保存的寄存器(R0-R3,R12,LR,PSR)</li><li>PC</li></ul><h3 id="1-4-对于M3-M4"><a href="#1-4-对于M3-M4" class="headerlink" title="1.4 对于M3&#x2F;M4"></a>1.4 对于M3&#x2F;M4</h3><p>参考资料：<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>PM0056.pdf</code></p><h4 id="1-4-1-硬件保存现场"><a href="#1-4-1-硬件保存现场" class="headerlink" title="1.4.1 硬件保存现场"></a>1.4.1 硬件保存现场</h4><p><img src="/./../photo/005_saved_register_for_exception.png"></p><h4 id="1-4-2-然后调用C函数"><a href="#1-4-2-然后调用C函数" class="headerlink" title="1.4.2 然后调用C函数"></a>1.4.2 然后调用C函数</h4><p>C函数执行完后，它返回LR所指示的位置。<br>难道把LR设置为被中断的程序的地址就行了吗？<br>如果只是返回LR所指示的地方，硬件帮我们保存在栈里的寄存器，怎么恢复？<br>M3&#x2F;M4在调用异常处理函数前，把LR设置为一个特殊的值，转给特殊的值被称为<strong>EXC_RETURN</strong>。<br>当PC寄存器的值等于<strong>EXC_RETURN</strong>时，会触发异常返回机制，简单地说：会从栈里恢复R0-R3,R12,LR,PC,PSR等寄存器。<br><strong>EXC_RETURN</strong>的值，请参考<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>，截图如下：<br><img src="/./../photo/006_exc_return.png"></p><p>补充2个知识点：</p><ul><li><p>操作模式：M3&#x2F;M4有两个操作模式</p><ul><li>处理模式：执行中断服务程序等异常处理时，处于<strong>处理模式</strong></li><li>线程模式：执行普通应用程序代码时，处于<strong>线程模式</strong></li></ul></li><li><p>M3&#x2F;M4有连个SP寄存器：SP_process、SP_main</p><ul><li>有些RTOS在运行用户程序时会使用SP_process，默认使用SP_main。</li></ul></li></ul><h3 id="1-5-对于A7"><a href="#1-5-对于A7" class="headerlink" title="1.5 对于A7"></a>1.5 对于A7</h3><p>它寄存器如下：<br><img src="/./../photo/007_bank_register.png"></p><p>处理器有9中模式：User、Sys、FIQ、IRQ、ABT、SVC、UND、MON、HYP。<br>上图中深色的寄存器，表示该模式下的”Banked”寄存器，比如SPSR寄存器，在很多模式下都有自己的、单独的寄存器。<br>比如IRQ模式下访问SPSR时，访问到的是IRQ模式下自己的SPSR_irq，别的模式下无法访问SPSR_irq。</p><p>比较值得关注的是FIQ模式，名为”快中断”，它有很多”Banked”寄存器：R8-R12,SP,LR。<br>在FIQ模式下，它既然能使用自己的R8-R12,SP,LR，自然不需要去保存被中断的程序的”R8-R12,SP,LR”了。<br>省去保存这几个寄存器的时间，处理中断时自然就快很多，所以被称为”FIQ”。</p><p>从上图也看到，几乎每个模式下都有自己是SP寄存器，意味着这些模式下有自己的栈。</p><p>当发生异常时，以IRQ为例：</p><ul><li>CPU会自动切换进入对应的模式，比如进入IRQ模式</li><li>并且会把被中断是的CPSR保存到SPSR_irq里</li></ul><p>所以发生异常&#x2F;中断时，在保存现场时，只需要保存：</p><ul><li>调用者保存的寄存器(R0-R3,R12,LR)</li><li>PC</li></ul><h2 id="4-实战-未定义指令异常"><a href="#4-实战-未定义指令异常" class="headerlink" title="4.实战_未定义指令异常"></a>4.实战_未定义指令异常</h2><p>参考资料：<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>PM0056.pdf</code></p><h3 id="1-1-M3-M4支持哪些异常"><a href="#1-1-M3-M4支持哪些异常" class="headerlink" title="1.1 M3_M4支持哪些异常"></a>1.1 M3_M4支持哪些异常</h3><p>从向量表可以看出，M3&#x2F;M4支持哪些异常：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">__Vectors       DCD     __initial_sp               <span class="hljs-comment">; Top of Stack</span><br>                DCD     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><br>                DCD     NMI_Handler                <span class="hljs-comment">; NMI Handler</span><br>                DCD     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                DCD     MemManage_Handler          <span class="hljs-comment">; MPU Fault Handler</span><br>                DCD     <span class="hljs-keyword">BusFault_Handler </span>          <span class="hljs-comment">; Bus Fault Handler</span><br>                DCD     UsageFault_Handler         <span class="hljs-comment">; Usage Fault Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     SVC_Handler                <span class="hljs-comment">; SVCall Handler</span><br>                DCD     DebugMon_Handler           <span class="hljs-comment">; Debug Monitor Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     PendSV_Handler             <span class="hljs-comment">; PendSV Handler</span><br>                DCD     SysTick_Handler            <span class="hljs-comment">; SysTick Handler</span><br>                <br>                <span class="hljs-comment">; External Interrupts</span><br>                DCD     WWDG_IRQHandler            <span class="hljs-comment">; Window Watchdog</span><br>                DCD     PVD_IRQHandler             <span class="hljs-comment">; PVD through EXTI Line detect   </span><br></code></pre></td></tr></table></figure><p>前面几个对应各类错误：</p><ul><li>Hard Fault</li><li>MPU Fault</li><li>Bus Fault</li><li>Usage Fault</li></ul><p>这几类错误产生的原因入下图所示，这个图来自<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>:<br><img src="/./../photo/009_m3m4_fault.png"></p><p>以未定义指令为例，它属于”处理器操作相关的错误”，如果没有使能”Usage Fault”，发就会触发”Hard Fault”。</p><h3 id="1-2-什么是未定义指令？"><a href="#1-2-什么是未定义指令？" class="headerlink" title="1.2 什么是未定义指令？"></a>1.2 什么是未定义指令？</h3><p>未定义指令，即使”还没有定义的指令”，也就是CPU不认识的指令。<br>很多时候，我们故意在代码里插入一些伪造的指令，故意让CPU执行到它时触发错误。<br>这在调试时很有用，比如想打断点：怎么实现呢？<br>有很多种方法：硬件监视点(watch point，数量有限)、软件断点(数量无限)。<br>软件断点就是使用<code>未定义指令</code>来实现的，比如想让程序执行到某个地址A时停下来，可以这样做：</p><ul><li>地址A上原来的指令是<code>xxx</code></li><li>我们故意把它改成<code>yyy</code>，改成一条CPU无法识别的指令</li><li>当CPU执行到地址A上的<code>yyy</code>指令时，触发异常</li><li>在异常处理函数里，打印更多调试信息</li><li>调试完毕后，恢复地址A上的指令为<code>xxx</code></li><li>从地址A重新执行程序</li></ul><p>本节教程并不打算制作调试器，这里只是讲述一下未定义指令的作用，使用它来深入理解异常处理流程。</p><h3 id="1-3-在汇编代码里插入未定义指令"><a href="#1-3-在汇编代码里插入未定义指令" class="headerlink" title="1.3 在汇编代码里插入未定义指令"></a>1.3 在汇编代码里插入未定义指令</h3><p>在代码中插入：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">DCD</span>  <span class="hljs-number">0xffffffff</span>；在main函数之前插入<br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">PC</span>,<span class="hljs-symbol">=mymain</span><span class="hljs-comment">;绝对跳转</span><br></code></pre></td></tr></table></figure><h4 id="1-3-1-先不使能”HardFault”、”Usage-Fault”"><a href="#1-3-1-先不使能”HardFault”、”Usage-Fault”" class="headerlink" title="1.3.1 先不使能”HardFault”、”Usage Fault”"></a>1.3.1 先不使能”HardFault”、”Usage Fault”</h4><p> 结果：不会进入main函数</p><h4 id="1-3-2-使能”HardFault”"><a href="#1-3-2-使能”HardFault”" class="headerlink" title="1.3.2 使能”HardFault”"></a>1.3.2 使能”HardFault”</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">__Vectors</span><span class="hljs-meta">DCD</span>(<span class="hljs-number">0X20000000</span>+<span class="hljs-number">0X10000</span>)<span class="hljs-comment">;设置栈大小</span><br><span class="hljs-meta">DCD</span>Reset_Handler<span class="hljs-comment">;Reset_Handler 伪指令,一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化</span><br><span class="hljs-meta">DCD</span>     <span class="hljs-number">0</span>                   <span class="hljs-comment">; NMI Handler</span><br>                <span class="hljs-meta">DCD</span>     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                <br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">HardFault_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;HardFault!\r\n&quot;</span>);<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：只打印异常处理函数HardFault_Handler（）里面实现的 <strong>HardFault!</strong></p><h4 id="1-3-3-使能”Usage-Fault”"><a href="#1-3-3-使能”Usage-Fault”" class="headerlink" title="1.3.3 使能”Usage Fault”"></a>1.3.3 使能”Usage Fault”</h4><ul><li><p>设置SCB寄存器的第18位，才能使能Usage Fault</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs asm">__VectorsDCD(0X20000000+0X10000);设置栈大小<br>DCDReset_Handler;Reset_Handler 伪指令,一般用于为特定的数据分配存储单元，同时可完成已分配存储单元的初始化<br>DCD     0                ; NMI Handler<br>                DCD     HardFault_Handler          ; Hard Fault Handler<br>                DCD     0          ; MPU Fault Handler<br>                DCD     0           ; Bus Fault Handler<br>                DCD     UsageFault_Handler         ; Usage Fault Handler<br></code></pre></td></tr></table></figure></li><li><p>初始化UsageFault，实现对应的异常处理函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">UsageFaultInit</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>SCB_Type * SCB = (SCB_Type *)SCB_BASE_ADDR;<br>SCB-&gt;SHCSR |= (SCB_SHCSR_USGFAULTENA_Msk);  <span class="hljs-comment">//UsageFault Enable</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">UsageFault_Handler</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> * <span class="hljs-built_in">stack</span>)</span><br>&#123;<br>SCB_Type * SCB = (SCB_Type *)SCB_BASE_ADDR;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;UsageFault!\r\n&quot;</span>);<br>SCB-&gt;CFSR = SCB-&gt;CFSR;    <span class="hljs-comment">//1.清除标志位，否则会一直触发</span><br><span class="hljs-built_in">stack</span>[<span class="hljs-number">6</span>] += <span class="hljs-number">4</span>;  <span class="hljs-comment">//2.设置返回地址，指向下一条指令,否则返回之后又会执行这条指令，还是会一直触发</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果：打印异常处理函数UsageFault_Handler（）里面实现的 <strong>UsageFault!<strong>之后，紧接着</strong>进去main函数中去</strong></p></li></ul><h2 id="5-实战-SVC异常"><a href="#5-实战-SVC异常" class="headerlink" title="5.实战_SVC异常"></a>5.实战_SVC异常</h2><p>参考资料：<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>DDI0403E_B_armv7m_arm.pdf</code>、<code>PM0056.pdf</code></p><h3 id="1-1-M3-M4支持哪些异常-1"><a href="#1-1-M3-M4支持哪些异常-1" class="headerlink" title="1.1 M3_M4支持哪些异常"></a>1.1 M3_M4支持哪些异常</h3><p>从向量表可以看出，M3&#x2F;M4支持哪些异常：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">__Vectors       DCD     __initial_sp               <span class="hljs-comment">; Top of Stack</span><br>                DCD     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><br>                DCD     NMI_Handler                <span class="hljs-comment">; NMI Handler</span><br>                DCD     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                DCD     MemManage_Handler          <span class="hljs-comment">; MPU Fault Handler</span><br>                DCD     <span class="hljs-keyword">BusFault_Handler </span>          <span class="hljs-comment">; Bus Fault Handler</span><br>                DCD     UsageFault_Handler         <span class="hljs-comment">; Usage Fault Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     SVC_Handler                <span class="hljs-comment">; SVCall Handler</span><br>                DCD     DebugMon_Handler           <span class="hljs-comment">; Debug Monitor Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     PendSV_Handler             <span class="hljs-comment">; PendSV Handler</span><br>                DCD     SysTick_Handler            <span class="hljs-comment">; SysTick Handler</span><br>                <br>                <span class="hljs-comment">; External Interrupts</span><br>                DCD     WWDG_IRQHandler            <span class="hljs-comment">; Window Watchdog</span><br>                DCD     PVD_IRQHandler             <span class="hljs-comment">; PVD through EXTI Line detect   </span><br></code></pre></td></tr></table></figure><p>在上述代码中，可以看到<code>SVC_Handler</code>，它对应SVC异常，当执行<code>SVC</code>指令时，会导致<code>SVC_Handler</code>被调用。</p><h3 id="1-2-什么是SVC指令？"><a href="#1-2-什么是SVC指令？" class="headerlink" title="1.2 什么是SVC指令？"></a>1.2 什么是SVC指令？</h3><p>在ARM指令中，有一条指令：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SVC</span> <span class="hljs-comment">#VAL</span><br></code></pre></td></tr></table></figure><p>它会触发一个异常。<br>在操作系统中，比如各类RTOS或者Linux，都会使用<code>SVC</code>指令故意触发异常，从而导致内核的异常处理函数被调用，进而去使用内核的服务。<br>比如Linux中，各类文件操作的函数<code>open</code>、<code>read</code>、<code>write</code>，它的实质都是<code>SVC</code>指令。<br>本节课程不讲解<code>SVC</code>在内核中的使用，我们只是看看如何处理<code>SVC</code>触发的异常。</p><h3 id="1-3-在汇编代码里插入SVC指令"><a href="#1-3-在汇编代码里插入SVC指令" class="headerlink" title="1.3 在汇编代码里插入SVC指令"></a>1.3 在汇编代码里插入SVC指令</h3><p>在代码中插入：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">SVC</span> <span class="hljs-comment">#1</span><br></code></pre></td></tr></table></figure><p>看看会发生什么事情。</p><p> 结果：只打印异常处理函数HardFault_Handler（）里面实现的 <strong>HardFault!</strong></p><h4 id="1-3-1-提供SVC异常处理函数"><a href="#1-3-1-提供SVC异常处理函数" class="headerlink" title="1.3.1 提供SVC异常处理函数"></a>1.3.1 提供SVC异常处理函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SVC_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;SVC!\r\n&quot;</span>);  <span class="hljs-comment">//执行完这条指令，会自动执行下一条指令</span><br>&#125;<br></code></pre></td></tr></table></figure><p>结果：只打印异常处理函数SVC_Handler（）里面实现的 <strong>HardFault!<strong>之后，紧接着</strong>进去main函数中去</strong></p><h2 id="6-实战-SysTick异常"><a href="#6-实战-SysTick异常" class="headerlink" title="6.实战_SysTick异常"></a>6.实战_SysTick异常</h2><p>使用CPU自带的SysTick定时器，让它产生周期性的中断，用来操作LED。</p><p>参考资料：<code>ARM Cortex-M3与Cortex-M4权威指南.pdf</code>、<code>PM0056.pdf</code></p><h3 id="1-1-M3-M4支持哪些异常-2"><a href="#1-1-M3-M4支持哪些异常-2" class="headerlink" title="1.1 M3_M4支持哪些异常"></a>1.1 M3_M4支持哪些异常</h3><p>从向量表可以看出，M3&#x2F;M4支持哪些异常：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">__Vectors       DCD     __initial_sp               <span class="hljs-comment">; Top of Stack</span><br>                DCD     Reset_Handler              <span class="hljs-comment">; Reset Handler</span><br>                DCD     NMI_Handler                <span class="hljs-comment">; NMI Handler</span><br>                DCD     HardFault_Handler          <span class="hljs-comment">; Hard Fault Handler</span><br>                DCD     MemManage_Handler          <span class="hljs-comment">; MPU Fault Handler</span><br>                DCD     <span class="hljs-keyword">BusFault_Handler </span>          <span class="hljs-comment">; Bus Fault Handler</span><br>                DCD     UsageFault_Handler         <span class="hljs-comment">; Usage Fault Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     SVC_Handler                <span class="hljs-comment">; SVCall Handler</span><br>                DCD     DebugMon_Handler           <span class="hljs-comment">; Debug Monitor Handler</span><br>                DCD     <span class="hljs-number">0</span>                          <span class="hljs-comment">; Reserved</span><br>                DCD     PendSV_Handler             <span class="hljs-comment">; PendSV Handler</span><br>                DCD     SysTick_Handler            <span class="hljs-comment">; SysTick Handler</span><br>                <br>                <span class="hljs-comment">; External Interrupts</span><br>                DCD     WWDG_IRQHandler            <span class="hljs-comment">; Window Watchdog</span><br>                DCD     PVD_IRQHandler             <span class="hljs-comment">; PVD through EXTI Line detect   </span><br></code></pre></td></tr></table></figure><h3 id="1-2-SysTick操作"><a href="#1-2-SysTick操作" class="headerlink" title="1.2 SysTick操作"></a>1.2 SysTick操作</h3><p>Cortex-M处理器内部集成了一个小型的、名为SysTick的定时器。可以使用它来为操作系统提供系统时钟，也可以把它当做一般的定时器。<br>之所以在处理器内增加这样的定时器，是为了提高软件的可以移植性。<br>它是一个24位的定时器，向下计数。<br>在时钟源的驱动下，计数值到达0时，可以触发异常。<br>它的框图如下：<br><img src="/./../photo/010_systick.png"></p><p>在本程序中，只需要设置这几个寄存器：</p><h4 id="1-2-1-SysTick-CTRL"><a href="#1-2-1-SysTick-CTRL" class="headerlink" title="1.2.1 SysTick-&gt;CTRL"></a>1.2.1 SysTick-&gt;CTRL</h4><p>  <img src="/./../photo/011_stk_ctrl.png"></p><h4 id="1-2-2-SysTick-VAL"><a href="#1-2-2-SysTick-VAL" class="headerlink" title="1.2.2 SysTick-&gt;VAL"></a>1.2.2 SysTick-&gt;VAL</h4><p><img src="/./../photo/012_stk_val.png"></p><h4 id="1-2-3-SysTick-LOAD"><a href="#1-2-3-SysTick-LOAD" class="headerlink" title="1.2.3 SysTick-&gt;LOAD"></a>1.2.3 SysTick-&gt;LOAD</h4><p><img src="/./../photo/013_stk_load.png"></p><h3 id="1-3-清除SysTick异常"><a href="#1-3-清除SysTick异常" class="headerlink" title="1.3 清除SysTick异常"></a>1.3 清除SysTick异常</h3><p><img src="/./../photo/014_clear_systick_pending.png"></p><h1 id="第六章-操作模式和特权等级"><a href="#第六章-操作模式和特权等级" class="headerlink" title="第六章 操作模式和特权等级"></a>第六章 操作模式和特权等级</h1><h2 id="1-CPU模式和状态以及栈寄存器"><a href="#1-CPU模式和状态以及栈寄存器" class="headerlink" title="1.CPU模式和状态以及栈寄存器"></a>1.CPU模式和状态以及栈寄存器</h2><h3 id="1-模式和状态"><a href="#1-模式和状态" class="headerlink" title="1. 模式和状态"></a>1. 模式和状态</h3><h4 id="1-1-状态"><a href="#1-1-状态" class="headerlink" title="1.1 状态"></a>1.1 状态</h4><p>ARM芯片支持Thumb指令集、ARM指令集，处理器运行Thumb指令时处于Thumb状态，运行ARM指令时处于ARM状态。</p><p>CortexM3&#x2F;M4只支持Thumb指令集，所以处理器运行时只有Thumb状态。除此之外，还有一个调试状态：比如通过调试器或触发断点后，处理器就会进入调试状态并停止指令执行。</p><p>本课程不涉及调试状态，所以处理器只处于Thumb状态。</p><h4 id="1-2-模式-访问等级-栈"><a href="#1-2-模式-访问等级-栈" class="headerlink" title="1.2 模式&#x2F;访问等级&#x2F;栈"></a>1.2 模式&#x2F;访问等级&#x2F;栈</h4><p>CortexM3&#x2F;M4处理器有两种模式：</p><ul><li>处理模式：执行中断服务程序等异常处理，在处理模式下，处理器有最大权限(具有特权访问等级)</li><li>线程模式：执行普通程序。这是处理器可以处于特权访问等级，也可以处于非特权访问等级。</li></ul><p>不同模式下，处理权限可能不同，最大的不同就是：栈寄存器可能也不同。</p><p>ARM处理器的通用寄存器有R0、R1、……、R15，其中的R13也被称为SP，即栈寄存器。对于SP，它有两个实体：MSP(Main SP)、PSP(Process SP)。</p><p>在处理模式下，使用MSP，也就是说指令中使用SP时，它对应的物理寄存器是MSP。</p><p>在线程模式下，根据CONTROL寄存器的设置，处理器可能用的是MSP，也可能用的是PSP。</p><p>图示如下：</p><p><img src="/./../photo/06_spsel.png" alt="image-20220326170811105"></p><p>栈寄存器的选择：</p><ul><li>① 启动时，CONTROL寄存器的SPSEL等于0，默认使用MSP。注意：启动时是线程模式，使用的仍然是MSP</li><li>② 程序可以修改CONTROL寄存器让SPSEL等于1，以使用PSP</li><li>③ 发生异常时，异常处理函数中使用的必定是MSP</li><li>④ 异常返回时，可以控制返回之后使用MSP还是PSP</li></ul><p>所谓访问等级，有两种：</p><ul><li>特权访问等级：可以访问所有寄存器、所有存储器。</li><li>非特权访问等级：无法访问某些寄存器，比如无法访问NVIC寄存器(嵌套向量中断控制器)。</li></ul><p>在一般的单片机系统中，RTOS、各类应用之间是无法隔离的：某个应用程序崩溃了，整个系统也就崩溃了。如果能让RTOS、各类应用程序彼此之间隔离开，那么可以增强系统的健壮性。这需要硬件的支持，比如需要有MPU(Memory Protection Unit)。</p><p>没有MPU时，访问等级的用处不大，只能用来限制应用程序无法访问某些寄存器。</p><h4 id="1-3-转换图"><a href="#1-3-转换图" class="headerlink" title="1.3 转换图"></a>1.3 转换图</h4><p>处理器状态和模式转换图如下：</p><p><img src="/./../photo/04_mode_status.png" alt="image-20220326164725625"></p><p>注意：</p><ul><li>① 上电启动时，处理处于线程模式，处于特权访问等级</li><li>② 在特权模式下，它自然可以设置某些寄存器降低自己的等级，进入非特权访问等级</li><li>③ 在非特权模式下，无法自行提升自己的等级</li><li>④ 发生异常时，处理器进入处理模式</li><li>⑤ 在处理模式下永远都是特权访问等级</li><li>⑥ 异常放回时，可以返回到特权访问等级，也可以返回到非特权访问等级</li></ul><h4 id="1-4-CONTROL寄存器"><a href="#1-4-CONTROL寄存器" class="headerlink" title="1.4 CONTROL寄存器"></a>1.4 CONTROL寄存器</h4><p>上图中，第②那里，怎么从特权访问等级降级为非特权访问等级？通过设置CONTROL寄存器。</p><p>CONTROL寄存器定义如下：</p><ul><li>SPSEL：用来选择线程模式使用的是MSP还是PSP</li><li>nPRIV：用来设置线程模式的访问等级(特权&#x2F;非特权)</li></ul><p><img src="/./../photo/07_control_reg.png" alt="image-20220326171250026"></p><p><img src="/./../photo/08_control_reg_bits.png" alt="image-20220326171338515"></p><p>两种等级、两种栈，组合起来就有4种情况：</p><p><img src="/./../photo/13_control_bit_table.png" alt="image-20220326162610884"></p><p>怎么读写CONTROL寄存器？使用如下汇编指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">MRS r0, CONTROL  ; 将CONTROL寄存器的值读入R0<br>MSR CONTROL, r0  ; 将R0写入CONTROL寄存器<br></code></pre></td></tr></table></figure><p><img src="/./../photo/10_process_mode_switch.png" alt="image-20220326180056270"></p><h4 id="1-5-EXC-RETURN"><a href="#1-5-EXC-RETURN" class="headerlink" title="1.5 EXC_RETURN"></a>1.5 EXC_RETURN</h4><p>通过设置CONTROL寄存器，可以选择MSP或PSP，可以把特权访问等级降为非特权访问等级。</p><p>但是无法把非特权等级提升为特权访问等级，为什么？如果可以这样简单地提升等级的话，等级也就失去了意义。</p><p>线程模式下无法自行提升等级，只能借助异常处理来提升等级：</p><ul><li>在异常的处理函数中，LR等于一个特殊的值EXC_RETURN</li><li>EXC_RETURN决定里异常返回后，处理器处于什么模式、使用什么栈</li></ul><p><img src="/./../photo/09_exc_return.png" alt="image-20220326174011909"></p><h3 id="2-编程"><a href="#2-编程" class="headerlink" title="2. 编程"></a>2. 编程</h3><p>调试本节程序时，在Keil自带的模拟器上调试，这样更容易看清楚。</p><p>工程需要如下设置：</p><p><img src="/./../photo/01_use_emulator.png" alt="image-20220326183856624"></p><h2 id="2-提升访问等级"><a href="#2-提升访问等级" class="headerlink" title="2.提升访问等级"></a>2.提升访问等级</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="3-MSP和PSP"><a href="#3-MSP和PSP" class="headerlink" title="3.MSP和PSP"></a>3.MSP和PSP</h2>]]></content>
    
    
    <categories>
      
      <category>架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ARM</tag>
      
      <tag>汇编</tag>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Makefile</title>
    <link href="/2024/06/28/Makefile/"/>
    <url>/2024/06/28/Makefile/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Makefile的引入及规则"><a href="#1-Makefile的引入及规则" class="headerlink" title="1 Makefile的引入及规则"></a>1 Makefile的引入及规则</h1><p>使用keil, mdk,avr等工具开发程序时点击鼠标就可以编译了，它的内部机制是什么？它怎么组织管理程序？怎么决定编译哪一个文件？</p><p>答：实际上windows工具管理程序的内部机制，也是Makefile，我们在linux下来开发裸板程序的时候，使用Makefile组织管理这些程序，本节我们来讲解Makefile最基本的规则。Makefile要做什么事情呢？<br>组织管理程序，组织管理文件，我们写一个程序来实验一下：</p><p>文件a.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-number">02</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">03</span><br><span class="hljs-number">04</span><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>05&#123;<br><span class="hljs-number">06</span>func_b();<br><span class="hljs-number">07</span><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-number">08</span>&#125;<br></code></pre></td></tr></table></figure><p>文件b.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-number">2</span><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><span class="hljs-type">void</span> <span class="hljs-title function_">func_b</span><span class="hljs-params">()</span><br>5&#123;<br><span class="hljs-number">6</span><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is B\n&quot;</span>);<br><span class="hljs-number">7</span>&#125;<br></code></pre></td></tr></table></figure><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -o <span class="hljs-built_in">test</span> a.c b.c<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./test<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">This is B<br></code></pre></td></tr></table></figure><p><strong>gcc -o test a.c b.c</strong>  这条命令虽然简单，但是它完成的功能不简单。</p><p>我们来看看它做了哪些事情，</p><p>我们知道.c程序  &#x3D;&#x3D;》 得到可执行程序它们之间要经过四个步骤：</p><ul><li>1.预处理</li><li>2.编译</li><li>3.汇编</li><li>4.链接</li></ul><p>我们经常把前三个步骤统称为编译了。我们具体分析：gcc -o test a.c b.c这条命令<br>它们要经过下面几个步骤：</p><ul><li>1）对于<strong>a.c</strong>：执行：预处理 编译 汇编 的过程，<strong>a.c &#x3D;&#x3D;&gt;xxx.s &#x3D;&#x3D;&gt;xxx.o</strong> 文件。</li><li>2）对于<strong>b.c</strong>：执行：预处理 编译 汇编 的过程，<strong>b.c &#x3D;&#x3D;&gt;yyy.s &#x3D;&#x3D;&gt;yyy.o</strong> 文件。</li><li>3）最后：<strong>xxx.o</strong>和<strong>yyy.o</strong>链接在一起得到一个<strong>test</strong>应用程序。</li></ul><p>提示：<strong>gcc -o test a.c b.c -v</strong> ：加上一个<strong>‘-v’</strong>选项可以看到它们的处理过程，</p><p>第一次编译 a.c 得到 xxx.o 文件，这是很合乎情理的， 执行完第一次之后，如果修改 a.c 又再次执行：<strong>gcc -o test a.c b.c</strong>，对于 a.c 应该重新生成 xxx.o，但是对于 b.c 又会重新编译一次，这完全没有必要，b.c 根本没有修改，直接使用第一次生成的 yyy.o 文件就可以了。</p><p>缺点：对所有的文件都会再处理一次，即使 b.c 没有经过修改，b.c 也会重新编译一次，当文件比较少时，这没有没有什么问题，当文件非常多的时候，就会带来非常多的效率问题如果文件非常多的时候，我们，只是修改了一个文件，所用的文件就会重新处理一次，编译的时候就会等待很长时间。</p><p>对于这些源文件，我们应该分别处理，执行：预处理 编译 汇编，先分别编译它们，最后再把它们链接在一次，比如：</p><p>编译：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -o a.o a.c<br>gcc -o b.o b.c<br></code></pre></td></tr></table></figure><p>链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -o <span class="hljs-built_in">test</span> a.o b.o<br></code></pre></td></tr></table></figure><p>比如：上面的例子，当我们修改a.c之后,a.c会重现编译然后再把它们链接在一起就可以了。b.c<br>就不需要重新编译。</p><p>那么问题又来了，怎么知道哪些文件被更新了&#x2F;被修改了？</p><p>比较时间：比较 a.o 和 a.c 的时间，如果a.c的时间比 a.o 的时间更加新的话，就表明 a.c 被修改了，同理b.o和b.c也会进行同样的比较。比较test和 a.o,b.o 的时间，如果a.o或者b.o的时间比test更加新的话，就表明应该重新生成test。Makefile<br>就是这样做的。我们现在来写出一个简单的Makefile:</p><p>makefie最基本的语法是规则，规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">目标 : 依赖1 依赖2 ...<br>[TAB]命令<br></code></pre></td></tr></table></figure><p>当“依赖”比“目标”新，执行它们下面的命令。我们要把上面三个命令写成makefile规则，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span> ：a.o b.o  //test是目标，它依赖于a.o b.o文件，一旦a.o或者b.o比<span class="hljs-built_in">test</span>新的时候，<br>就需要执行下面的命令，重新生成<span class="hljs-built_in">test</span>可执行程序。<br>gcc -o <span class="hljs-built_in">test</span> a.o b.o<br>a.o : a.c  //a.o依赖于a.c，当a.c更加新的话，执行下面的命令来生成a.o<br>gcc -c -o a.o a.c<br>b.o : b.c  //b.o依赖于b.c,当b.c更加新的话，执行下面的命令，来生成b.o<br>gcc -c -o b.o b.c<br></code></pre></td></tr></table></figure><p>我们来作一下实验：</p><p>在改目录下我们写一个Makefile文件：</p><p>文件：Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Makefile">1test:a.o b.o<br>2gcc -o test a.o b.o<br>3<br>4a.o : a.c<br>5gcc -c -o a.o a.c<br>6<br>7b.o : b.c<br>8gcc -c -o b.o b.c<br></code></pre></td></tr></table></figure><p>上面是makefile中的三条规则。makefile,就是名字为“makefile”的文件。当我们想编译程序时，直接执行make命令就可以了，一执行make命令它想生成第一个目标test可执行程序,<br>如果发现a.o 或者b.o没有，就要先生成a.o或者b.o，发现a.o依赖a.c，有a.c但是没有a.o,他就会认为a.c比a.o新，就会执行它们下面的命令来生成a.o，同理b.o和b.c的处理关系也是这样的。</p><p>如果修改a.c ，我们再次执行make，它的本意是想生成第一个目标test应用程序,它需要先生成a.o,发现a.o依赖a.c(执行我们修改了a.c)发现a.c比a.o更加新，就会执行gcc -c -o a.o<br>a.c命令来生成a.o文件。b.o依赖b.c，发现b.c并没有修改，就不会执行gcc -c -o b.o<br>b.c来重新生成b.o文件。现在a.o b.o都有了，其中的a.o比test更加新，就会执行 gcc -o<br>test a.ob.o来重新链接得到test可执行程序。所以当执行make命令时候就会执行下面两条执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c -o a.o a.c<br>gcc -o <span class="hljs-built_in">test</span> a.o b.o<br></code></pre></td></tr></table></figure><p>我们第一次执行make的时候，会执行下面三条命令(三条命令都执行)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c -o a.o a.c<br>gcc -c -o b.o b.c<br>gcc -o <span class="hljs-built_in">test</span> a.o b.o<br></code></pre></td></tr></table></figure><p>再次执行make 就会显示下面的提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make: `<span class="hljs-built_in">test</span><span class="hljs-string">&#x27; is up to date.</span><br></code></pre></td></tr></table></figure><p>我们再次执行make就会判断Makefile文件中的依赖，发现依赖没有更新，所以目标文件就不会重现生成，就会有上面的提示。当我们修改a.c后，重新执行make,</p><p>就会执行下面两条指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ash">gcc -c -o a.o a.c<br>gcc -o test a.o b.o<br></code></pre></td></tr></table></figure><p>我们同时修改a.c b.c，执行make就会执行下面三条指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c -o a.o a.c<br>gcc -c -o b.o b.c<br>gcc -o <span class="hljs-built_in">test</span> a.o b.o<br></code></pre></td></tr></table></figure><p>a.c文件修改了，重新编译生成a.o, b.c修改了重新编译生成b.o，a.o,b.o都更新了重新链接生成test可执行程序，makefile的规则其实还是比较简单的。规则是Makefie的核心，</p><p>执行make命令的时候，就会在当前目录下面找到名字为：Makefile的文件，根据里面的内容来执行里面的判断&#x2F;命令。</p><h1 id="2-Makefile的语法"><a href="#2-Makefile的语法" class="headerlink" title="2 Makefile的语法"></a>2 Makefile的语法</h1><p>本节我们只是简单的讲解Makefile的语法，如果想比较深入学习Makefile的话可以：</p><ul><li>a. 百度搜 “gnu make 于凤昌”。</li><li>b. 查看官方文档: <a href="http://www.gnu.org/software/make/manual/">http://www.gnu.org/software/make/manual/</a></li></ul><h2 id="a-通配符"><a href="#a-通配符" class="headerlink" title="a. 通配符"></a>a. 通配符</h2><p>假如一个目标文件所依赖的依赖文件很多，那样岂不是我们要写很多规则，这显然是不合乎常理的</p><p>我们可以使用通配符，来解决这些问题。</p><p>我们对上节程序进行修改代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>: a.o b.o <br>gcc -o <span class="hljs-built_in">test</span> $^<br><br>%.o : %.c<br>gcc -c -o <span class="hljs-variable">$@</span> $&lt;<br></code></pre></td></tr></table></figure><p>%.o：表示所用的.o文件</p><p>%.c：表示所有的.c文件</p><p>$@：表示目标</p><p>$&lt;：表示第1个依赖文件</p><p>$^：表示所有依赖文件</p><p>我们来在该目录下增加一个 c.c 文件，代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#include &lt;stdio.h&gt;</span><br><br>void <span class="hljs-function"><span class="hljs-title">func_c</span></span>()<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is C\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在main函数中调用修改Makefile，修改后的代码如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">test</span>: a.o b.o c.o<br>gcc -o <span class="hljs-built_in">test</span> $^<br><br>%.o : %.c<br>gcc -c -o <span class="hljs-variable">$@</span> $&lt;<br></code></pre></td></tr></table></figure><p>执行： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -c -o a.o a.c<br>gcc -c -o b.o b.c<br>gcc -c -o c.o c.c<br>gcc -o <span class="hljs-built_in">test</span> a.o b.o c.o<br></code></pre></td></tr></table></figure><p>运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./test<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">This is B<br>This is C<br></code></pre></td></tr></table></figure><h2 id="b-假想目标-PHONY"><a href="#b-假想目标-PHONY" class="headerlink" title="b. 假想目标: .PHONY"></a>b. 假想目标: .PHONY</h2><p>1.我们想清除文件，我们在Makefile的结尾添加如下代码就可以了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">clean:<br><span class="hljs-built_in">rm</span> *.o <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>*1）执行 make ：生成第一个可执行文件。<br>*2）执行 make clean : 清除所有文件，即执行： rm *.o test。</p><p>make后面可以带上目标名，也可以不带，如果不带目标名的话它就想生成第一个规则里面的第一个目标。</p><p>2.使用Makefile</p><p>执行：<strong>make [目标]</strong> 也可以不跟目标名，若无目标默认第一个目标。我们直接执行make的时候，会在makefile里面找到第一个目标然后执行下面的指令生成第一个目标。当我们执行 make clean 的时候，就会在 Makefile 里面找到 clean 这个目标，然后执行里面的命令，这个写法有些问题，原因是我们的目录里面没有 clean 这个文件，这个规则执行的条件成立，他就会执行下面的命令来删除文件。</p><p>如果：该目录下面有名为clean文件怎么办呢？</p><p>我们在该目录下创建一个名为 “clean” 的文件，然后重新执行：make然后make<br>clean，结果(会有下面的提示：)：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make: \`clean<span class="hljs-string">&#x27; is up to date.</span><br></code></pre></td></tr></table></figure><p>它根本没有执行我们的删除操作，这是为什么呢？</p><p>我们之前说，一个规则能过执行的条件：</p><p>*1)目标文件不存在<br>*2)依赖文件比目标新</p><p>现在我们的目录里面有名为“clean”的文件，目标文件是有的，并且没有依赖文件，没有办法判断依赖文件的时间。这种写法会导致：有同名的”clean”文件时，就没有办法执行make clean操作。解决办法：我们需要把目标定义为假象目标，用关键子PHONY</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">.PHONY: clean //把clean定义为假象目标。他就不会判断名为“clean”的文件是否存在，<br></code></pre></td></tr></table></figure><p>然后在Makfile结尾添加.PHONY: clean语句，重新执行：make clean，就会执行删除操作。</p><h2 id="C-变量"><a href="#C-变量" class="headerlink" title="C. 变量"></a>C. 变量</h2><p>在makefile中有两种变量：</p><p>1), 简单变量(即使变量)：</p><p>A :&#x3D; xxx    # A的值即刻确定，在定义时即确定</p><p>对于即使变量使用 “:&#x3D;” 表示，它的值在定义的时候已经被确定了</p><p>2）延时变量</p><p>B &#x3D; xxx   # B的值使用到时才确定</p><p>对于延时变量使用“&#x3D;”表示。它只有在使用到的时候才确定，在定义&#x2F;等于时并没有</p><p>确定下来。</p><p>想使用变量的时候使用“$”来引用，如果不想看到命令是，可以在命令的前面加上”@“符号，就不会显示命令本身。当我们执行make命令的时候，make这个指令本身，会把整个Makefile读进去，进行全部分析，然后解析里面的变量。常用的变量的定义如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">:= <span class="hljs-comment"># 即时变量</span><br>= <span class="hljs-comment"># 延时变量</span><br>?= <span class="hljs-comment"># 延时变量, 如果是第1次定义才起效, 如果在前面该变量已定义则忽略这句</span><br>\+= <span class="hljs-comment"># 附加, 它是即时变量还是延时变量取决于前面的定义</span><br>?=: 如果这个变量在前面已经被定义了，这句话就会不会起效果，<br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">A := $(C)<br>B = $(C)<br>C = abc<br><br><span class="hljs-comment">#D = 100ask</span><br>D ?= weidongshan<br><br>all:<br>@<span class="hljs-built_in">echo</span> A = $(A)<br>@<span class="hljs-built_in">echo</span> B = $(B)<br>@<span class="hljs-built_in">echo</span> D = $(D)<br><br>C += 123<br></code></pre></td></tr></table></figure><p>执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">make<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">A =<br>B = abc 123<br>D = weidongshan<br></code></pre></td></tr></table></figure><p>分析：</p><ol><li>A :&#x3D; $(C)：</li></ol><p>A为即使变量，在定义时即确定，由于刚开始C的值为空，所以A的值也为空。</p><ol start="2"><li><p>B &#x3D; $(C)：<br>B为延时变量，只有使用到时它的值才确定，当执行make时，会解析Makefile里面的所用变量，所以先解析C&#x3D; abc,然后解析C +&#x3D; 123，此时，C &#x3D; abc 123，当执行：@echo B &#x3D; $(B) B的值为 abc 123。</p></li><li><p>D ?&#x3D; weidongshan：</p></li></ol><p>D变量在前面没有定义，所以D的值为weidongshan，如果在前面添加D &#x3D; 100ask，最后D的值为100ask。</p><p>我们还可以通过命令行存入变量的值 例如：</p><p>执行：make D&#x3D;123456 里面的 D ?&#x3D; weidongshan 这句话就不起作用了。</p><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">A =<br>B = abc 123<br>D = 123456<br></code></pre></td></tr></table></figure><h1 id="3-Makefile函数"><a href="#3-Makefile函数" class="headerlink" title="3 Makefile函数"></a>3 Makefile函数</h1><p>makefile里面可以包含很多函数，这些函数都是make本身实现的，下面我们来几个常用的函数。引用一个函数用“$”。</p><h2 id="函数foreach"><a href="#函数foreach" class="headerlink" title="函数foreach"></a>函数foreach</h2><p>函数foreach语法如下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$(foreach var,list,text) <br></code></pre></td></tr></table></figure><p>前两个参数，‘var’和‘list’，将首先扩展，注意最后一个参数 ‘text’ 此时不扩展；接着，对每一个 ‘list’ 扩展产生的字，将用来为 ‘var’ 扩展后命名的变量赋值；然后 ‘text’ 引用该变量扩展；因此它每次扩展都不相同。结果是由空格隔开的 ‘text’。在 ‘list’ 中多次扩展的字组成的新的 ‘list’。‘text’ 多次扩展的字串联起来，字与字之间由空格隔开，如此就产生了函数 foreach 的返回值。</p><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">A = a b c<br>B = $(foreach f, &amp;(A), $(f).o)<br><br>all:<br>@<span class="hljs-built_in">echo</span> B = $(B)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">B = a.o b.o c.o<br></code></pre></td></tr></table></figure><h2 id="函数filter-filter-out"><a href="#函数filter-filter-out" class="headerlink" title="函数filter&#x2F;filter-out"></a>函数filter&#x2F;filter-out</h2><p>函数filter&#x2F;filter-out语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$(filter pattern...,text)     <span class="hljs-comment"># 在text中取出符合patten格式的值</span><br>$(filter-out pattern...,text) <span class="hljs-comment"># 在text中取出不符合patten格式的值</span><br></code></pre></td></tr></table></figure><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">C = a b c d/<br><br>D = $(filter %/, $(C))<br>E = $(filter-out %/, $(C))<br><br>all:<br>        @<span class="hljs-built_in">echo</span> D = $(D)<br>        @<span class="hljs-built_in">echo</span> E = $(E)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">D = d/<br>E = a b c<br></code></pre></td></tr></table></figure><h2 id="Wildcard"><a href="#Wildcard" class="headerlink" title="Wildcard"></a>Wildcard</h2><p>函数Wildcard语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$(wildcard pattern) <span class="hljs-comment"># pattern定义了文件名的格式, wildcard取出其中存在的文件。</span><br></code></pre></td></tr></table></figure><p>这个函数 wildcard 会以 pattern 这个格式，去寻找存在的文件，返回存在文件的名字。</p><p>实例：</p><p>在该目录下创建三个文件：a.c b.c c.c</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">files = $(wildcard *.c)<br><br>all:<br>        @<span class="hljs-built_in">echo</span> files = $(files)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">files = a.c b.c c.c<br></code></pre></td></tr></table></figure><p>我们也可以用wildcard函数来判断，真实存在的文件</p><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">files2 = a.c b.c c.c d.c e.c  abc<br>files3 = $(wildcard $(files2))<br><br>all:<br>        @<span class="hljs-built_in">echo</span> files3 = $(files3)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">files3 = a.c b.c c.c<br></code></pre></td></tr></table></figure><h2 id="patsubst函数"><a href="#patsubst函数" class="headerlink" title="patsubst函数"></a>patsubst函数</h2><p>函数 patsubst 语法如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$(patsubst pattern,replacement,\$(var))<br></code></pre></td></tr></table></figure><p>patsubst 函数是从 var 变量里面取出每一个值，如果这个符合 pattern 格式，把它替换成 replacement 格式，</p><p>实例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">files2  = a.c b.c c.c d.c e.c abc<br><br>dep_files = $(patsubst %.c,%.d,$(files2))<br><br>all:<br>        @<span class="hljs-built_in">echo</span> dep_files = $(dep_files)<br><br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">dep_files = a.d b.d c.d d.d e.d abc<br></code></pre></td></tr></table></figure><h1 id="4-Makefile实例"><a href="#4-Makefile实例" class="headerlink" title="4 Makefile实例"></a>4 Makefile实例</h1><p>前面讲了那么多Makefile的知识，现在开始做一个实例。<br>在<code>c.c</code>里面，包含一个头文件<code>c.h</code>，在<code>c.h</code>里面定义一个宏，把这个宏打印出来。<br>c.c:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;c.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func_c</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This is C = %d\n&quot;</span>, C);<br>&#125;<br></code></pre></td></tr></table></figure><p>c.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> C 1</span><br></code></pre></td></tr></table></figure><p>然后上传编译，执行<code>./test</code>,打印出：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">This <span class="hljs-keyword">is</span> B<br>This <span class="hljs-keyword">is</span> C =<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>测试没有问题，然后修改<code>c.h</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> C 2</span><br></code></pre></td></tr></table></figure><p>重新编译，发现没有更新程序，运行，结果不变，说明现在的Makefile存在问题。</p><p>为什么会出现这个问题呢， 首先我们test依赖c.o，c.o依赖c.c，如果我们更新c.c，会重新更新整个程序。<br>但c.o也依赖c.h，我们更新了c.h，并没有在Makefile上体现出来，导致c.h的更新，Makefile无法检测到。<br>因此需要添加:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs llvm"><span class="hljs-keyword">c</span>.o : <span class="hljs-keyword">c</span>.<span class="hljs-keyword">c</span> <span class="hljs-keyword">c</span>.h<br></code></pre></td></tr></table></figure><p>现在每次修改c.h，Makefile都能识别到更新操作，从而更新最后输出文件。</p><p>这样又冒出了一个新的问题，我们怎么为每个.c文件添加.h文件呢？对于内核，有几万个文件，不可能为每个文件依次写出其头文件。<br>因此需要做出改进，让其自动生成头文件依赖，可以参考这篇文章：<a href="http://blog.csdn.net/qq1452008/article/details/50855810">http://blog.csdn.net/qq1452008/article/details/50855810</a></p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">gcc -M c<span class="hljs-selector-class">.c</span> <span class="hljs-comment">// 打印出依赖</span><br><br>gcc -M -MF c<span class="hljs-selector-class">.d</span> c<span class="hljs-selector-class">.c</span>  <span class="hljs-comment">// 把依赖写入文件c.d</span><br><br>gcc -c -o c<span class="hljs-selector-class">.o</span> c<span class="hljs-selector-class">.c</span> -MD -MF c<span class="hljs-selector-class">.d</span>  <span class="hljs-comment">// 编译c.o, 把依赖写入文件c.d</span><br></code></pre></td></tr></table></figure><p>修改Makefile如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs makefile">objs = a.o b.o c.o<br><br>dep_files := <span class="hljs-variable">$(<span class="hljs-built_in">patsubst</span> %,.%.d, <span class="hljs-variable">$(objs)</span>)</span><br>dep_files := <span class="hljs-variable">$(<span class="hljs-built_in">wildcard</span> <span class="hljs-variable">$(dep_files)</span>)</span><br><br><span class="hljs-section">test: <span class="hljs-variable">$(objs)</span></span><br>gcc -o test <span class="hljs-variable">$^</span><br><br><span class="hljs-keyword">ifneq</span> (<span class="hljs-variable">$(dep_files)</span>,)<br><span class="hljs-keyword">include</span> <span class="hljs-variable">$(dep_files)</span><br><span class="hljs-keyword">endif</span><br><br>%.o : %.c<br>gcc -c -o <span class="hljs-variable">$@</span> <span class="hljs-variable">$&lt;</span> -MD -MF .<span class="hljs-variable">$@</span>.d<br><br><span class="hljs-section">clean:</span><br>rm *.o test<br><br><span class="hljs-section">distclean:</span><br>rm <span class="hljs-variable">$(dep_files)</span><br><br><span class="hljs-meta"><span class="hljs-keyword">.PHONY</span>: clean</span><br></code></pre></td></tr></table></figure><p>首先用obj变量将.o文件放在一块。<br>利用前面讲到的函数，把obj里所有文件都变为.%.d格式，并用变量dep_files表示。<br>利用前面介绍的wildcard函数，判断dep_files是否存在。<br>然后是目标文件test依赖所有的.o文件。<br>如果dep_files变量不为空，就将其包含进来。<br>然后就是所有的.o文件都依赖.c文件，且通过-MD -MF生成.d依赖文件。<br>清理所有的.o文件和目标文件<br>清理依赖.d文件。</p><p>现在我门修改了任何.h文件，最终都会影响最后生成的文件，也没任何手工添加.h、.c、.o文件，完成了支持头文件依赖。</p><p>下面再添加CFLAGS，即编译参数。比如加上编译参数-Werror，把所有的警告当成错误。</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mel">CFLAGS = -Werror -Iinclude<br><br>…………<br><br><br>%.o : %.c<br>gcc $(CFLAGS) -c -o $@ $&lt; -MD -MF .$@.d<br></code></pre></td></tr></table></figure><p>现在重新make，发现以前的警告就变成了错误，必须要解决这些错误编译才能进行。在<code>a.c</code>里面声明一下函数：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func_b</span>()</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">func_c</span>()</span>;<br></code></pre></td></tr></table></figure><p>重新make，错误就没有了。</p><p>除了编译参数-Werror，还可以加上-I参数，指定头文件路径，-Iinclude表示当前的inclue文件夹下。<br>此时就可以把c.c文件里的<code>#include &quot;.h&quot;</code>改为<code>#include &lt;c.h&gt;</code>，前者表示当前目录，后者表示编译器指定的路径和GCC路径。</p>]]></content>
    
    
    <categories>
      
      <category>makefile知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>驱动</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>rttread移植</title>
    <link href="/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/"/>
    <url>/2023/12/10/rttread%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1、rtthread介绍"><a href="#1、rtthread介绍" class="headerlink" title="1、rtthread介绍"></a>1、rtthread介绍</h1><ul><li>RT-Thread 是一款完全由国内团队开发维护的嵌入式实时操作系统（RTOS），具有完全的自主知识产权。经过 16 个年头的沉淀，伴随着物联网的兴起，它正演变成一个功能强大、组件丰富的物联网操作系统。</li><li>rtthread官网提供了很多个版本，针对于不同的应用情况：标准版、nano版、smart版本。我们移植的是nano版本，是一个去除了很多第三方组件的只保留操作系统的内核基本功能：线程管理、线程间通信、时钟管理、中断管理、内存管理。</li><li>支持的CPU架构有：ARM架构下的Cortex M0&#x2F; M3&#x2F; M4&#x2F; M7 等；RISC-V架构及其他。</li><li>nano版本源码也可以保留了finsh组件，让rtthread也可以像linux那样有终端界面，通过命令行来进行相应的命令操作。</li></ul><h1 id="2、rtthread源码"><a href="#2、rtthread源码" class="headerlink" title="2、rtthread源码"></a>2、rtthread源码</h1><h2 id="2-1nano版本的源码获取"><a href="#2-1nano版本的源码获取" class="headerlink" title="2&#x2F;1nano版本的源码获取"></a>2&#x2F;1nano版本的源码获取</h2><ul><li>进入官网下载界面选择nano版本下载;<a href="https://www.rt-thread.org/download.html#download-rt-thread-nano">rt-thread.org&#x2F;download.html#download-rt-thread-nano</a></li></ul><h2 id="2-2源码目录及文件分析"><a href="#2-2源码目录及文件分析" class="headerlink" title="2&#x2F;2源码目录及文件分析"></a>2&#x2F;2源码目录及文件分析</h2><ul><li>源码目录</li></ul><p><img src="/./../photo/rtt%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95.png"></p><ul><li>重点rtt内核相关文件</li></ul><p><img src="/./../photo/rttsrc%E7%9B%AE%E5%BD%95.png"></p><ul><li><p>需要移植的文件</p><ul><li><p><strong>板级支持包和rtt配置文件：bsp文件夹下面的board.c和rtconfig.h</strong></p></li><li><p><strong>可选的第三方组件；components文件夹下面的finsh组件和device驱动框架</strong></p></li><li><p><strong>include文件夹所有内容</strong></p></li><li><p><strong>libcpu文件下对应的架构文件；这里使用的是stm32h743vit6所以要移植该文件夹下的arm-&gt;cortex-m7文件夹下面的所有内容</strong></p></li><li><p><strong>src文件夹下所有内核源码</strong></p></li></ul></li></ul><h1 id="3、具体移植细节"><a href="#3、具体移植细节" class="headerlink" title="3、具体移植细节"></a>3、具体移植细节</h1><h2 id="3-1基于gcc工程的移植"><a href="#3-1基于gcc工程的移植" class="headerlink" title="3&#x2F;1基于gcc工程的移植"></a>3&#x2F;1基于gcc工程的移植</h2><ul><li>按照如下cubemx配置一个简单的gcc工程，参考另外一篇cubemx搭建工程文章。这里主要配置一些led引脚和串口1。串口1来作为finsh组件终端通信。另外这里使用的是stm32h7系列的，我们开启数据cache和指令cache</li></ul><p><img src="/./../photo/h743cache.png"></p><ul><li>stm32h743有2M的flash和1M的RAM所以堆栈可以设置大些。然后生成Makefile工程</li></ul><p><img src="/./../photo/743%E5%A0%86%E6%A0%88%E8%AE%BE%E7%BD%AE.png"></p><ul><li>创建好的工程目录如下。</li></ul><p><img src="/./../photo/743rtt-gcc.png"></p><ul><li>在目录中创建一个rtthread目录，然后将下载的nano源码全都拷贝过来，并且删除一些不必要的文件。</li></ul><p><img src="/./../photo/rtt%E5%88%A0%E9%99%A41.png"></p><p><img src="/./../photo/rtt%E5%88%A0%E9%99%A42.png"></p><p><img src="/./../photo/rtt%E5%88%A0%E9%99%A43.png"></p><p><img src="/./../photo/rtt%E5%88%A0%E9%99%A44.png"></p><ul><li>到上面，需要的文件都已经移植好了，然后修改工程里面的Makefile文件，将刚刚添加进来的c文件和h文件包含到编译依赖里面；用vscode打开刚刚新建的工程。修改Makefile文件内容。</li></ul><p><img src="/./../photo/rttmk1.png"></p><p><img src="/./../photo/rttmk2.png"></p><p><img src="/./../photo/rttmk3.png"></p><p><img src="/./../photo/rttmk4.png"></p><ul><li>然后屏蔽掉芯片原厂提供的中断文件中的三个中断。void HardFault_Handler(void)；void PendSV_Handler(void)；void SysTick_Handler(void)；因为rtthread内核实现了这三个函数。这三个函数一般在it.c文件里面定义的。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">if</span> 0</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief This function handles Hard fault interrupt.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">HardFault_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  <span class="hljs-comment">/* USER CODE BEGIN HardFault_IRQn 0 */</span><br><br>  <span class="hljs-comment">/* USER CODE END HardFault_IRQn 0 */</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>  &#123;<br>    <span class="hljs-comment">/* USER CODE BEGIN W1_HardFault_IRQn 0 */</span><br>    <span class="hljs-comment">/* USER CODE END W1_HardFault_IRQn 0 */</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief This function handles Pendable request for system service.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">PendSV_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * @brief This function handles System tick timer.</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">SysTick_Handler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><br>  HAL_IncTick();<br><br>&#125;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><ul><li>gcc编译的话还要修改启动文件的入口函数，为什么要修改呢？修改启动文件；</li></ul><p><img src="/./../photo/rttgcc%E5%85%A5%E5%8F%A3.png"></p><p><img src="/./../photo/rttgcc%E5%90%AF%E5%8A%A8.png"></p><ul><li>rtthread启动流程</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C">entry()-&gt;rtthread_startup()-&gt;<br>&#123;<br>    rt_hw_interrupt_disable();<br><br>    <span class="hljs-comment">/* board level initialization</span><br><span class="hljs-comment">     * <span class="hljs-doctag">NOTE:</span> please initialize heap inside board initialization.</span><br><span class="hljs-comment">     */</span><br>    rt_hw_board_init();-&gt;板级初始化<br><br>    <span class="hljs-comment">/* show RT-Thread version */</span><br>    rt_show_version();-&gt;这里的先实现串口打印功能<br><br>    <span class="hljs-comment">/* timer system initialization */</span><br>    rt_system_timer_init();<br><br>    <span class="hljs-comment">/* scheduler system initialization */</span><br>    rt_system_scheduler_init();<br><br>    <span class="hljs-comment">/* create init_thread */</span><br>    rt_application_init();-&gt;这个里面创建了一个线程；而这个线程的线程函数会调用main函数<br><br>    <span class="hljs-comment">/* timer thread initialization */</span><br>    rt_system_timer_thread_init();<br><br>    <span class="hljs-comment">/* idle thread initialization */</span><br>    rt_thread_idle_init();<br><br>    <span class="hljs-comment">/* start scheduler */</span><br>    rt_system_scheduler_start();-&gt;这里启动了调度器后，就会进入刚刚创建这个线程函数<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>至此rtthread的nano版本已经移植完了，可以在main函数里面创建不同的线程了；</li></ul><h2 id="3-2移植第三方finsh组件，来实现命令行交互"><a href="#3-2移植第三方finsh组件，来实现命令行交互" class="headerlink" title="3&#x2F;2移植第三方finsh组件，来实现命令行交互"></a>3&#x2F;2移植第三方finsh组件，来实现命令行交互</h2><ul><li><p>修改makefile，将rtthread&#x2F;components&#x2F;finsh里面的c文件和h文件都添加进编译文件里面。具体看上面怎么添加的，同理添加。</p></li><li><p>修改链接文件ld，在text段里面添加虚线之内的代码</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs ld">.text :<br>  &#123;<br>    . = ALIGN(4);<br>    *(.text)           /* .text sections (code) */<br>    *(.text*)          /* .text* sections (code) */<br>    *(.glue_7)         /* glue arm to thumb code */<br>    *(.glue_7t)        /* glue thumb to arm code */<br>    *(.eh_frame)<br><br>    KEEP (*(.init))<br>    KEEP (*(.fini))<br><br>    /*RT-thread GCC Add start---------------------------------*/    <br>    /* section information for finsh shell */<br>    . = ALIGN(4);<br>    __fsymtab_start = .;<br>    KEEP(*(FSymTab))<br>    __fsymtab_end = .;<br>    . = ALIGN(4);<br>    __vsymtab_start = .;<br>    KEEP(*(VSymTab))<br>    __vsymtab_end = .;<br>    . = ALIGN(4);<br><br>    /* section information for initial. */<br>    . = ALIGN(4);<br>    __rt_init_start = .;<br>    KEEP(*(SORT(.rti_fn*)))<br>    __rt_init_end = .;<br>    . = ALIGN(4);<br>    /* RT-thread GCC Add end ------------------------------------*/<br><br>    . = ALIGN(4);<br>    _etext = .;        /* define a global symbols at end of code */<br>  &#125; &gt;FLASH<br></code></pre></td></tr></table></figure><ul><li>实现两个函数，这两个函数都是弱定义的，即rtthread里面终端接收和发送函数。在finsh_port.c文件里面实现以下两个函数。具体还要包含相应的uart文件，这里使用的是串口1；</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">char</span> <span class="hljs-title function_">rt_hw_console_getchar</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span> ch = <span class="hljs-number">-1</span>;<br><br>    <span class="hljs-keyword">if</span> (__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_RXNE) != RESET)<br>    &#123;<br><br>        ch = huart1.Instance-&gt;RDR &amp; <span class="hljs-number">0xff</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(__HAL_UART_GET_FLAG(&amp;huart1, UART_FLAG_ORE) != RESET)<br>        &#123;<br>            __HAL_UART_CLEAR_OREFLAG(&amp;huart1);<br>        &#125;<br>        rt_thread_mdelay(<span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ch;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">rt_hw_console_output</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str)</span><br>&#123;<br>    <span class="hljs-type">rt_size_t</span> i = <span class="hljs-number">0</span>, size = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">char</span> a = <span class="hljs-string">&#x27;\r&#x27;</span>;<br><br>    __HAL_UNLOCK(&amp;huart1);<br><br>    size = rt_strlen(str);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; size; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (*(str + i) == <span class="hljs-string">&#x27;\n&#x27;</span>)<br>        &#123;<br>            HAL_UART_Transmit(&amp;huart1, (<span class="hljs-type">uint8_t</span> *)&amp;a, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>        HAL_UART_Transmit(&amp;huart1, (<span class="hljs-type">uint8_t</span> *)(str + i), <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在配置文件rtconfig.h里面添加包含finsh组件的配置文件finsh_config.h;</li></ul><p><img src="/./../photo/rttfinsh1.png"></p><ul><li>屏蔽重复定义的宏，这样防止出现警告。有些在finsh_config.h里面已经宏定义过了。屏蔽掉rtconfig.h里面的相关内容。</li></ul><p><img src="/./../photo/rttfinsh2.png"></p><ul><li>第三方组件也移植好了，在终端make。生成hex文件，下载进cpu内。打开Mobaxterm建立一个串口通信。连接好串口，然后打开终端。复位cpu，可以在终端看到如下，表示移植成功。</li></ul><p><img src="/./../photo/rttfinshxterm.png" alt=""></p><ul><li>finsh常用的内置命令如下</li></ul><p><img src="/./../photo/finshcmd.png" alt=""></p><ul><li>其他kile以及IAR编译道理相同，更加简单，一样只需要添加相应c文件到工程里面，将头文件添加到IDE的搜索路径。</li></ul><h1 id="4、rtthread常用的API"><a href="#4、rtthread常用的API" class="headerlink" title="4、rtthread常用的API"></a>4、rtthread常用的API</h1><ul><li>线程管理函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*线程动态创建函数*/</span><br><span class="hljs-type">rt_thread_t</span> <span class="hljs-title function_">rt_thread_create</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span> * name,<span class="hljs-comment">//线程的名称</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span>(*)(<span class="hljs-type">void</span> *parameter) entry,<span class="hljs-comment">//线程的入口函数</span></span><br><span class="hljs-params">    <span class="hljs-type">void</span> * parameter,<span class="hljs-comment">//入口函数的传入参数</span></span><br><span class="hljs-params">    <span class="hljs-type">rt_uint32_t</span> stack_size,<span class="hljs-comment">//线程堆栈的大小</span></span><br><span class="hljs-params">    <span class="hljs-type">rt_uint8_t</span> priority,<span class="hljs-comment">//线程的优先级</span></span><br><span class="hljs-params">    <span class="hljs-type">rt_uint32_t</span> tick <span class="hljs-comment">//线程的时间片大小。当系统中存在相同优先级线程时，这个参数指定线程一次调度能够运行的最大时间长度。</span></span><br><span class="hljs-params">)</span><br>    <br><span class="hljs-comment">/*线程启动函数函数*/</span>   <br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_startup</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span><span class="hljs-comment">//参数是线程的句柄</span><br><br><span class="hljs-comment">/*线程删除函数*/</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delete</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span><br>    <br><span class="hljs-comment">/*线程挂起函数*/</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_suspend</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span><br><br><span class="hljs-comment">/*线程恢复函数*/</span>   <br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_resume</span><span class="hljs-params">(<span class="hljs-type">rt_thread_t</span> thread)</span>    <br>    <br><span class="hljs-comment">/*线程延时相关函数函数*/</span> <br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_yield</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_sleep</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_delay</span><span class="hljs-params">(<span class="hljs-type">rt_tick_t</span> tick)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_thread_mdelay</span><span class="hljs-params">(<span class="hljs-type">rt_int32_t</span> ms)</span><br></code></pre></td></tr></table></figure><ul><li>软件定时器相关函数</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*动态创建软件定时器*/</span><br><br><span class="hljs-type">rt_timer_t</span> <span class="hljs-title function_">rt_timer_create</span><span class="hljs-params">(</span><br><span class="hljs-params"><span class="hljs-type">const</span> <span class="hljs-type">char</span> * name,<span class="hljs-comment">//定时器名称</span></span><br><span class="hljs-params"><span class="hljs-type">void</span>(*)(<span class="hljs-type">void</span> *parameter) timeout,<span class="hljs-comment">//超时回调函数</span></span><br><span class="hljs-params"><span class="hljs-type">void</span> * parameter,<span class="hljs-comment">//超时回调函数的传入参数</span></span><br><span class="hljs-params"><span class="hljs-type">rt_tick_t</span> time,<span class="hljs-comment">//定时超时时间</span></span><br><span class="hljs-params"><span class="hljs-type">rt_uint8_t</span> flag <span class="hljs-comment">//定时器的标志位</span></span><br><span class="hljs-params">)</span><br><br><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_delete</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_start</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span><br><span class="hljs-type">rt_err_t</span> <span class="hljs-title function_">rt_timer_stop</span><span class="hljs-params">(<span class="hljs-type">rt_timer_t</span> timer)</span><br></code></pre></td></tr></table></figure><ul><li>线程通信函数：这里有信号量、互斥量、事件、邮箱、消息队列等等。可以参考官网编程手册</li></ul>]]></content>
    
    
    <categories>
      
      <category>OS移植</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基于FreeRtos+STM32智能车载终端系统</title>
    <link href="/2023/12/05/%E5%9F%BA%E4%BA%8EFreeRtos-STM32%E6%99%BA%E8%83%BD%E8%BD%A6%E8%BD%BD%E7%BB%88%E7%AB%AF%E7%B3%BB%E7%BB%9F/"/>
    <url>/2023/12/05/%E5%9F%BA%E4%BA%8EFreeRtos-STM32%E6%99%BA%E8%83%BD%E8%BD%A6%E8%BD%BD%E7%BB%88%E7%AB%AF%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="1、项目概述"><a href="#1、项目概述" class="headerlink" title="1、项目概述"></a>1、项目概述</h1><p>​基于freertos实时操作系统加stm32完成一个智能车载终端系统。主要实现功能：车载娱乐播放、车内温湿度记录、模拟汽车启动，加速，减速；语音控制、黑匣子以及录音功能、实现人机交互，移动互联进行车内数据上云，界面设计。</p><h1 id="2、硬件目录和功能"><a href="#2、硬件目录和功能" class="headerlink" title="2、硬件目录和功能"></a>2、硬件目录和功能</h1><table><thead><tr><th align="center">器件</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">stm32f103zet6</td><td align="center">主控CPU</td></tr><tr><td align="center">VS1053模块</td><td align="center">音频解码以及录音</td></tr><tr><td align="center">DS18B20模块</td><td align="center">测量车内温度</td></tr><tr><td align="center">对射光电传感器</td><td align="center">测量车速</td></tr><tr><td align="center">AT24C64模块</td><td align="center">黑匣子存储功能</td></tr><tr><td align="center">esp8266</td><td align="center">wifi互联功能</td></tr><tr><td align="center">LD3320模块</td><td align="center">语音识别</td></tr><tr><td align="center">TFT串口屏幕</td><td align="center">车载终端界面</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>大端与小端</title>
    <link href="/2023/11/03/%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/"/>
    <url>/2023/11/03/%E5%A4%A7%E7%AB%AF%E4%B8%8E%E5%B0%8F%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="1-嵌入式编程中，什么是大端？什么是小端？"><a href="#1-嵌入式编程中，什么是大端？什么是小端？" class="headerlink" title="1.嵌入式编程中，什么是大端？什么是小端？"></a>1.嵌入式编程中，什么是大端？什么是小端？</h1><ul><li>大端模式：低位字节存在高地址上，高位字节存在低地址上</li><li>小端模式：低位字节存在低地址上，高位字节存在高地址上</li></ul><p><img src="/./../photo/image-20231103144235652.png" alt="image-20231103144235652"></p><p>​釆用小端模式的CPU对操作数的存放方式是从低字节到高字节，而大端模式对操作数的存放方式是从高 字节到低字节。例如，16位宽的数0x1234在小端模式CPU内存中的存放方式（假设从地址0x4000开始 存放）见表1，而在大端模式CPU内存中的存放方式见表2。</p><p>​表1 0x1234在小端CPU内存中的存放方式</p><p><img src="/./../photo/image-20231103144428620.png" alt="image-20231103144428620"></p><p>​表2 0x1234在大端CPU内存中的存放方式</p><p><img src="/./../photo/image-20231103144514639.png" alt="image-20231103144514639"></p><p>举个例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mybitfields</span></span><br><span class="hljs-class">&#123;</span>   <br> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> a:<span class="hljs-number">4</span>;  <span class="hljs-comment">/* 取低4位 */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> b:<span class="hljs-number">5</span>;  <span class="hljs-comment">/* 取低5位 */</span><br> <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> c:<span class="hljs-number">7</span>;  <span class="hljs-comment">/* 取低7位 */</span><br>&#125;test;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br> <span class="hljs-type">int</span> i;<br> test.a = <span class="hljs-number">2</span>;<span class="hljs-comment">/* 取其低四位是0010 */</span><br> test.b = <span class="hljs-number">3</span>;<span class="hljs-comment">/* 取其低五位是00011 */</span><br> test.c = <span class="hljs-number">0</span>;<span class="hljs-comment">/* 取其低七位是0000000 */</span><br> i =*((<span class="hljs-type">short</span>*)&amp;test);  <span class="hljs-comment">/* 上面的16位内存转换成 short类型进行解释 */</span><br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>,i);<br> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>程序的输出结果为 50。</p><p>如果为小端模式，低位字节在低地址，则 i &#x3D;  0000000  00011   0010，也就是十进制50</p><p>如果为大端模式，低位字节在高地址，则 i &#x3D; 0010  00011   0000000，也就是十进制8576</p><h1 id="2-如何判断处理器是大端模式还是小端模式？"><a href="#2-如何判断处理器是大端模式还是小端模式？" class="headerlink" title="2.如何判断处理器是大端模式还是小端模式？"></a>2.如何判断处理器是大端模式还是小端模式？</h1><h2 id="2-1-使用联合体"><a href="#2-1-使用联合体" class="headerlink" title="2.1 使用联合体"></a>2.1 使用联合体</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">checkCPU</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">union</span> <span class="hljs-title class_">w</span> &#123;<br><span class="hljs-type">int</span> a;  <span class="hljs-comment">/* 占4个字节 */</span><br><span class="hljs-type">char</span> b;<span class="hljs-comment">/* 占1个字节 */</span><br>&#125;c;<br>c.a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span>(c.b == <span class="hljs-number">1</span>); <span class="hljs-comment">/* 判断低字节1存放在高地址还是低地址 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">checkCPU</span>())<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;小端\r\n&quot;</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;大端\r\n&quot;</span>);<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理：联合体变量中的成员是<strong>共用一个首地址，共占同一段内存空间</strong>，所以在任意时刻只能存放其中一个成员的值</p><h2 id="2-1-使用指针"><a href="#2-1-使用指针" class="headerlink" title="2.1 使用指针"></a>2.1 使用指针</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">checkCPU</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> usData = <span class="hljs-number">0x1122</span>;                  <span class="hljs-comment">/* 占两个字节 */</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*pucData = (<span class="hljs-type">unsigned</span> <span class="hljs-type">char</span>*)&amp;usData;<span class="hljs-comment">/* 占一个字节 */</span><br>    <span class="hljs-keyword">return</span> (*pucData == <span class="hljs-number">0x22</span>);  <span class="hljs-comment">/* 判断低位字节0x22是否存放在低地址 */</span><br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>     <span class="hljs-keyword">if</span>(checkCPU())<br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;小端\n&quot;</span>);<br>     <span class="hljs-keyword">else</span><br><br>     <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;大端\n&quot;</span>);<br>     <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-如何进行大小端的转换？"><a href="#3-如何进行大小端的转换？" class="headerlink" title="3.如何进行大小端的转换？"></a>3.如何进行大小端的转换？</h1><h2 id="3-1-int型位变量"><a href="#3-1-int型位变量" class="headerlink" title="3.1 int型位变量"></a>3.1 int型位变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">swapInt32</span><span class="hljs-params">(<span class="hljs-type">int</span> data)</span><br>&#123;<br><span class="hljs-type">int</span> temp;<br>temp = ((data &amp; <span class="hljs-number">0x000000FF</span>) &lt;&lt; <span class="hljs-number">24</span>) | ((data &amp; <span class="hljs-number">0x0000FF00</span>) &lt;&lt; <span class="hljs-number">8</span>) | <br>           ((data &amp; <span class="hljs-number">0x00FF0000</span>) &gt;&gt; <span class="hljs-number">8</span>) |  ((data &amp; <span class="hljs-number">0xFF000000</span>) &gt;&gt; <span class="hljs-number">24</span>);<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">int</span> a = <span class="hljs-number">0x11223344</span>;<br><span class="hljs-type">int</span> b;<br><br>b = swapInt32(a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>,b); <span class="hljs-comment">/* 44332211 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-1-short型位变量"><a href="#3-1-short型位变量" class="headerlink" title="3.1 short型位变量"></a>3.1 short型位变量</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">short</span> <span class="hljs-title function_">swapShort16</span><span class="hljs-params">(<span class="hljs-type">short</span> data)</span><br>&#123;<br><span class="hljs-type">int</span> temp;<br>temp = ((data &amp; <span class="hljs-number">0x00FF</span>) &lt;&lt; <span class="hljs-number">8</span>) | ((data &amp; <span class="hljs-number">0xFF00</span>) &gt;&gt; <span class="hljs-number">8</span>);<br><span class="hljs-keyword">return</span> temp;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br><span class="hljs-type">short</span> a = <span class="hljs-number">0x1122</span>;<br><span class="hljs-type">short</span> b;<br><br>b = swapShort16(a);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%x&quot;</span>,b); <span class="hljs-comment">/* 2211 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-对常量的处理"><a href="#4-对常量的处理" class="headerlink" title="4.对常量的处理"></a>4.对常量的处理</h1><h2 id="4-1-对0x100000赋值"><a href="#4-1-对0x100000赋值" class="headerlink" title="4.1 对0x100000赋值"></a>4.1 对0x100000赋值</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">*(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>*)<span class="hljs-number">0x100000</span> = <span class="hljs-number">1234</span>;<br><br><span class="hljs-comment">/* 可以看成3步 */</span><br><span class="hljs-type">int</span> *pAddr;               <span class="hljs-comment">/* 定义一个指针变量 */</span><br>pAddr = (<span class="hljs-type">int</span> *)<span class="hljs-number">0x100000</span>;  <span class="hljs-comment">/* 指向0x100000这个地址 */</span><br>*pAddr = <span class="hljs-number">1234</span>;  <span class="hljs-comment">/* 往这个地址里面赋值 */</span><br></code></pre></td></tr></table></figure><h2 id="4-2-让程序跳转到绝对地址是0x100000去执行"><a href="#4-2-让程序跳转到绝对地址是0x100000去执行" class="headerlink" title="4.2 让程序跳转到绝对地址是0x100000去执行"></a>4.2 让程序跳转到绝对地址是0x100000去执行</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">*((<span class="hljs-type">void</span> (*)( ))<span class="hljs-number">0x100000</span> ) ( );<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*Func)</span><span class="hljs-params">()</span>;         <span class="hljs-comment">/* 定义函数类型 Func == void (*)() */</span><br>Func f;<span class="hljs-comment">/* 定义一个函数指针f */</span><br>f = (Func)<span class="hljs-number">0x100000</span><span class="hljs-comment">/* 将0x100000强制转换成函数指针,f指向他 */</span><br>*(f)();                         <span class="hljs-comment">/* 调用函数f,这里加不加*都可以 */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>嵌入式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>链表</title>
    <link href="/2023/10/27/%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/10/27/%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-链表的概念"><a href="#1-链表的概念" class="headerlink" title="1.链表的概念"></a>1.链表的概念</h2><p>链表是一种常见的基础数据结构，结构体指针在这里得到了充分的利用。链表可以动态的进行存储分配，也就是说，链表是一个功能极为强大的数组，它可以在节点中定义多种数据类型，还可以根据需要随意增添，删除，插入节点。</p><p>链表都有一个头指针，一般以head来表示，存放的是一个地址。链表中的节点分为两类，头结点和一般节点，头结点是没有数据域的。链表中每个节点都分为两部分，一个数据域，一个是指针域。说到这里你应该就明白了，链表就如同车链子一样，head指向第一个元素：第一个元素又指向第二个元素；……，直到最后一个元素，该元素不再指向其它元素，它称为“表尾”，它的地址部分放个“NULL”（表示“空地址”），链表到此结束</p><h2 id="1-链表操作的难点-指针"><a href="#1-链表操作的难点-指针" class="headerlink" title="1. 链表操作的难点:指针"></a>1. 链表操作的难点:指针</h2><p>理解了指针，对于链表就容易理解了。</p><p>2个口诀：</p><ul><li>变量变量，能变，就是能读能写，必定在内存里</li><li>指针指针，保存的是地址，32位处理器中地址都是32位的，无论是什么类型的指针变量，都是4字节</li></ul><h2 id="2-链表类型"><a href="#2-链表类型" class="headerlink" title="2. 链表类型"></a>2. 链表类型</h2><p><img src="/./../photo/01_link_type.png" alt="image-20220313120114693"></p><h2 id="3-普通的链表插入删除排序操作"><a href="#3-普通的链表插入删除排序操作" class="headerlink" title="3. 普通的链表插入删除排序操作"></a>3. 普通的链表插入删除排序操作</h2><h3 id="3-1-创建链表"><a href="#3-1-创建链表" class="headerlink" title="3.1 创建链表"></a>3.1 创建链表</h3><ul><li>创建两个结构体，一个表示链表的头部，一个表示链表项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> &#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br><span class="hljs-type">char</span> *name; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-2-初始化链表"><a href="#3-2-初始化链表" class="headerlink" title="3.2 初始化链表"></a>3.2 初始化链表</h3><ul><li>让链表的头部指向为NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *pList, <span class="hljs-type">char</span> *name)</span><br>&#123;<br>pList-&gt;name = name;<br>pList-&gt;next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-插入链表"><a href="#3-3-插入链表" class="headerlink" title="3.3 插入链表"></a>3.3 插入链表</h3><ul><li><p>往链表的最后一项插入，最后一项指向为NULL</p><p><img src="/./../photo/image-20231027182219023.png" alt="image-20231027182219023"></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">AddItemToList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *pList, <span class="hljs-keyword">struct</span> person *new_persion)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">last</span>;</span><br><br><span class="hljs-comment">/* 如果是空链表 */</span><br><span class="hljs-keyword">if</span> (pList-&gt;next == <span class="hljs-literal">NULL</span>)<br>&#123;<br>pList-&gt;next = new_persion;<br>new_persion-&gt;next =<span class="hljs-literal">NULL</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br>    <span class="hljs-comment">/* 找出链表的最后一项 */</span><br>last = pList-&gt;next;<br><span class="hljs-keyword">while</span> (last-&gt;next)<br>&#123;<br>last = last-&gt;next;<br>&#125;<br><br><span class="hljs-comment">/* last-&gt;next == NULL */</span><br>last-&gt;next = new_persion;<br>new_persion-&gt;next =<span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-链表中删除项"><a href="#3-4-链表中删除项" class="headerlink" title="3.4 链表中删除项"></a>3.4 链表中删除项</h3><p>分为两种情况：</p><ul><li><p>删除的是第一项</p><p><img src="/./../photo/image-20231027181925007.png" alt="image-20231027181925007"></p></li><li><p>删除的是其他项</p><p><img src="/./../photo/image-20231027182349405.png" alt="image-20231027182349405"></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DelItemFromList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *pList, <span class="hljs-keyword">struct</span> person *person)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">p</span> =</span> pList-&gt;next;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">pre</span> =</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/* 找到person */</span><br><span class="hljs-keyword">while</span> (p != <span class="hljs-literal">NULL</span> &amp;&amp; p != person)<br>&#123;<br><span class="hljs-comment">/* 后面还有人, 移动到下一个 */</span><br>pre = p;<br>p = p-&gt;next;<br>&#125;<br><br><span class="hljs-comment">/* 退出的条件: p==NULL, p == person */</span><br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can not find the person to del\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">/* 前面无人, 表示要删除的是第1项 */</span><br>&#123;<br>pList-&gt;next = p-&gt;next;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>pre-&gt;next = p-&gt;next;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-链表排序"><a href="#3-5-链表排序" class="headerlink" title="3.5 链表排序"></a>3.5 链表排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SortList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *pList)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">pre</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">next</span>;</span><br><br><span class="hljs-type">char</span> *tmp_name;<br><span class="hljs-type">int</span> tmp_age;<br><br>pre = pList-&gt;next;<br><span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">while</span> (pre)<br>&#123;<br>next = pre-&gt;next;<br><span class="hljs-keyword">while</span> (next)<br>&#123;<br><span class="hljs-keyword">if</span> (pre-&gt;age &gt; next-&gt;age)<br>&#123;<br><span class="hljs-comment">/* 交换值 */</span><br>tmp_name = pre-&gt;name;<br>pre-&gt;name = next-&gt;name;<br>next-&gt;name = tmp_name;<br><br>tmp_age = pre-&gt;age;<br>pre-&gt;age = next-&gt;age;<br>next-&gt;age = tmp_age;<br>&#125;<br><br>next = next-&gt;next;<br>&#125;<br><br>pre = pre-&gt;next;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-普通的链表改进"><a href="#3-普通的链表改进" class="headerlink" title="3. 普通的链表改进"></a>3. 普通的链表改进</h2><p>主要是因为刚才的链表头部与链表项的操作不同一</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c">pList-&gt;next<br>person-&gt;next<br></code></pre></td></tr></table></figure><h3 id="3-1-创建链表-1"><a href="#3-1-创建链表-1" class="headerlink" title="3.1 创建链表"></a>3.1 创建链表</h3><ul><li>创建两个结构体，一个表示链表的头部，一个表示链表项</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> &#123;</span><br>    <span class="hljs-type">char</span> *name;<br>    <span class="hljs-type">int</span> age;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">next</span>;</span><br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list</span> &#123;</span><br><span class="hljs-type">char</span> *name; <br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> <span class="hljs-title">head</span>;</span>  <span class="hljs-comment">/* 这里不再使用指针，而是使用结构体来表示头部 */</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-2-初始化链表-1"><a href="#3-2-初始化链表-1" class="headerlink" title="3.2 初始化链表"></a>3.2 初始化链表</h3><ul><li>让链表的头部指向为NULL</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InitList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *pList, <span class="hljs-type">char</span> *name)</span><br>&#123;<br>pList-&gt;name = name;<br>pList-&gt;head.next = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-插入链表-1"><a href="#3-3-插入链表-1" class="headerlink" title="3.3 插入链表"></a>3.3 插入链表</h3><ul><li><p>往链表的最后一项插入，最后一项指向为NULL</p><p><img src="/./../photo/image-20231027182219023.png" alt="image-20231027182219023"></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">AddItemToList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *pList, <span class="hljs-keyword">struct</span> person *new_persion)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">last</span> =</span> &amp;pList-&gt;head;;<br><br>    <span class="hljs-comment">/* 找出链表的最后一项 */</span><br><span class="hljs-keyword">while</span> (last-&gt;next)<br>&#123;<br>last = last-&gt;next;<br>&#125;<br><br><span class="hljs-comment">/* last-&gt;next == NULL */</span><br>last-&gt;next = new_persion;<br>new_persion-&gt;next =<span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-链表中删除项-1"><a href="#3-4-链表中删除项-1" class="headerlink" title="3.4 链表中删除项"></a>3.4 链表中删除项</h3><p>分为两种情况：</p><ul><li><p>删除的是第一项</p><p><img src="/./../photo/image-20231027181925007.png" alt="image-20231027181925007"></p></li><li><p>删除的是其他项</p><p><img src="/./../photo/image-20231027182349405.png" alt="image-20231027182349405"></p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DelItemFromList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *pList, <span class="hljs-keyword">struct</span> person *person)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">pre</span> =</span> &amp;pList-&gt;head;<br><br><span class="hljs-comment">/* 找到person */</span><br><span class="hljs-keyword">while</span> (pre != <span class="hljs-literal">NULL</span> &amp;&amp; pre-&gt;next != person)<br>&#123;<br>pre = pre-&gt;next;<br>&#125;<br><br><span class="hljs-comment">/* 没找到 */</span><br><span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span>;<br><span class="hljs-keyword">else</span><br>pre-&gt;next = person-&gt;next;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-链表排序-1"><a href="#3-5-链表排序-1" class="headerlink" title="3.5 链表排序"></a>3.5 链表排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">SortList</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> <span class="hljs-built_in">list</span> *pList)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">pre</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">person</span> *<span class="hljs-title">next</span>;</span><br><br><span class="hljs-type">char</span> *tmp_name;<br><span class="hljs-type">int</span> tmp_age;<br><br>pre = pList-&gt;next;<br><span class="hljs-keyword">if</span> (pre == <span class="hljs-literal">NULL</span>)<br><span class="hljs-keyword">return</span>;<br><br><span class="hljs-keyword">while</span> (pre)<br>&#123;<br>next = pre-&gt;next;<br><span class="hljs-keyword">while</span> (next)<br>&#123;<br><span class="hljs-keyword">if</span> (pre-&gt;age &gt; next-&gt;age)<br>&#123;<br><span class="hljs-comment">/* 交换值 */</span><br>tmp_name = pre-&gt;name;<br>pre-&gt;name = next-&gt;name;<br>next-&gt;name = tmp_name;<br><br>tmp_age = pre-&gt;age;<br>pre-&gt;age = next-&gt;age;<br>next-&gt;age = tmp_age;<br>&#125;<br><br>next = next-&gt;next;<br>&#125;<br><br>pre = pre-&gt;next;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-通用链表"><a href="#4-通用链表" class="headerlink" title="4. 通用链表"></a>4. 通用链表</h2><h2 id="5-双向链表"><a href="#5-双向链表" class="headerlink" title="5. 双向链表"></a>5. 双向链表</h2>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>代码重定位</title>
    <link href="/2023/10/23/%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/"/>
    <url>/2023/10/23/%E4%BB%A3%E7%A0%81%E9%87%8D%E5%AE%9A%E4%BD%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="一、段的概念"><a href="#一、段的概念" class="headerlink" title="一、段的概念"></a>一、段的概念</h1><p>代码段、只读数据段、可读可写的数据段、BSS段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> g_Char = <span class="hljs-string">&#x27;A&#x27;</span>;           <span class="hljs-comment">// 可读可写，不能放在ROM上，应该放在RAM里</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> g_Char2 = <span class="hljs-string">&#x27;B&#x27;</span>;    <span class="hljs-comment">// 只读变量，可以放在ROM上</span><br><span class="hljs-type">int</span> g_A = <span class="hljs-number">0</span>;   <span class="hljs-comment">// 初始值为0，干嘛浪费空间保存在ROM上？没必要</span><br><span class="hljs-type">int</span> g_B;       <span class="hljs-comment">// 没有初始化，干嘛浪费空间保存在ROM上？没必要</span><br></code></pre></td></tr></table></figure><p>所以，程序分为这几个段：</p><ul><li>代码段(RO-CODE)：就是程序本身，不会被修改</li><li>可读可写的数据段(RW-DATA)：有初始值的全局变量、静态变量，<strong>需要从ROM上复制到内存</strong></li><li>只读的数据段(RO-DATA)：可以放在ROM上，不需要复制到内存</li><li>BSS段或ZI段：<ul><li>初始值为0的全局变量或静态变量，没必要放在ROM上，使用之前清零就可以</li><li>未初始化的全局变量或静态变量，没必要放在ROM上，使用之前清零就可以</li></ul></li><li>局部变量：保存在栈中，运行时生成</li><li>堆：一块空闲空间，使用malloc函数来管理它，malloc函数可以自己写</li></ul><h1 id="二、重定位要做的事"><a href="#二、重定位要做的事" class="headerlink" title="二、重定位要做的事"></a>二、重定位要做的事</h1><h2 id="1-程序中含有什么？"><a href="#1-程序中含有什么？" class="headerlink" title="1. 程序中含有什么？"></a>1. 程序中含有什么？</h2><ul><li>代码段：如果它不在链接地址上，就需要重定位</li><li>只读数据段：如果它不在链接地址上，就需要重定位</li><li>可读可写的数据段：如果它不在链接地址上，就需要重定位</li><li>BSS段：不需要重定位，因为程序里根本不保存BSS段，使用前把BSS段对应的空间清零即可</li></ul><h2 id="2-谁来做重定位？"><a href="#2-谁来做重定位？" class="headerlink" title="2. 谁来做重定位？"></a>2. 谁来做重定位？</h2><ul><li>程序本身：它把自己复制到链接地址去</li><li>一开始，程序可能并不位于它的链接地址上，为什么它可以执行重定位的操作？<ul><li>因为重定位的代码是使用<strong>“位置无关码”</strong>写的</li></ul></li><li>什么叫位置无关码：这段代码扔在任何位置都可以运行，跟它所在的位置无关</li><li>怎么写出<strong>位置无关码：</strong><ul><li>跳转：使用相对跳转指令，不能使用绝对跳转指令<ul><li>只能使用branch指令(比如<code>bl main</code>)，不能给PC直接复制，比如<code>ldr pc, =main</code></li></ul></li><li>不要访问全局变量、静态变量</li><li>不使用字符串</li></ul></li></ul><h2 id="3-怎么做重定位和清除BSS段？"><a href="#3-怎么做重定位和清除BSS段？" class="headerlink" title="3. 怎么做重定位和清除BSS段？"></a>3. 怎么做重定位和清除BSS段？</h2><ul><li>核心：复制</li><li>复制的三要素：源、目的、长度<ul><li>怎么知道代码段&#x2F;数据段保存在哪？(加载地址)</li><li>怎么知道代码段&#x2F;数据段要被复制到哪？(链接地址)</li><li>怎么知道代码段&#x2F;数据段的长度？</li></ul></li><li>怎么知道BSS段的地址范围：起始地址、长度？</li><li>这一切<ul><li>在keil中使用散列文件(Scatter File)来描述</li><li>在GCC中使用链接脚本(Link Script)来描述</li></ul></li></ul><h2 id="4-加载地址和链接地址的区别"><a href="#4-加载地址和链接地址的区别" class="headerlink" title="4. 加载地址和链接地址的区别"></a>4. 加载地址和链接地址的区别</h2><p>程序运行时，<strong>应该</strong>位于它的链接地址处，因为：</p><ul><li>使用函数地址时用的是”函数的链接地址”，所以代码段<strong>应该</strong>位于链接地址处</li><li>去访问全局变量、静态变量时，用的是”变量的链接地址”，所以数据段<strong>应该</strong>位于链接地址处</li></ul><p>但是： 程序一开始时可能并没有位于它的”链接地址”：</p><ul><li>比如对于STM32F103，程序被烧录器烧写在Flash上，这个地址称为”加载地址”</li><li>比如对于IMX6ULL&#x2F;STM32MP157，片内ROM根据头部信息把程序读入内存，这个地址称为“加载地址”</li></ul><p>当<strong>加载地址 ！&#x3D; 链接地址</strong>时，就需要重定位。</p><h1 id="四、散列文件使用与分析"><a href="#四、散列文件使用与分析" class="headerlink" title="四、散列文件使用与分析"></a>四、散列文件使用与分析</h1><h2 id="1-重定位的实质-移动数据"><a href="#1-重定位的实质-移动数据" class="headerlink" title="1. 重定位的实质: 移动数据"></a>1. 重定位的实质: 移动数据</h2><p>把代码段、只读数据段、数据段，移动到它的链接地址处。<br>也就是<strong>复制</strong>！<br>数据复制的三要素：源、目的、长度。</p><ul><li><p>数据保存在哪里？加载地址</p></li><li><p>数据要复制到哪里？链接地址</p></li><li><p>长度</p></li></ul><p>这3要素怎么得到？<br>在keil中，使用散列文件来描述。<br>散列？分散排列？<br>是的，在STM32F103这类资源紧缺的单片机芯片中，</p><ul><li>代码段保存在Flash上，直接在Flash上运行(当然也可以重定位到内存里)</li><li>数据段保存在Flash上，使用前被复制到内存里</li></ul><h2 id="2-散列文件示例"><a href="#2-散列文件示例" class="headerlink" title="2. 散列文件示例"></a>2. 散列文件示例</h2><h3 id="2-1-示例代码"><a href="#2-1-示例代码" class="headerlink" title="2.1 示例代码"></a>2.1 示例代码</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs markdown">; <span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br>; <span class="hljs-strong">*** Scatter-Loading Description File generated by uVision **</span>*<br>; <span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span><span class="hljs-strong">****</span>*<br><br>LR<span class="hljs-emphasis">_IROM1 0x08000000 0x00080000  &#123;    ; load region size_</span>region<br>  ER<span class="hljs-emphasis">_IROM1 0x08000000 0x00080000  &#123;  ; load address = execution address</span><br><span class="hljs-emphasis">   *.o (RESET, +First)</span><br><span class="hljs-emphasis">   .ANY (+RO)</span><br><span class="hljs-emphasis">   .ANY (+XO)</span><br><span class="hljs-emphasis">  &#125;</span><br><span class="hljs-emphasis">  RW_</span>IRAM1 0x20000000 0x00010000  &#123;  ; RW data<br>   .ANY (+RW +ZI)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-散列文件语法"><a href="#2-2-散列文件语法" class="headerlink" title="2.2 散列文件语法"></a>2.2 散列文件语法</h3><p>一个散列文件由一个或多个<code>Load region</code>组成：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">load_region_description ::=<br>load_region_name (base_address <span class="hljs-string">| (&quot;</span>+<span class="hljs-string">&quot; offset)) [attribute_list] [max_size]</span><br><span class="hljs-string">&quot;&#123;&quot;</span><br>execution_region_description+<br><span class="hljs-string">&quot;&#125;</span><br></code></pre></td></tr></table></figure><p><code>Load region</code>中含有一个或多个<code>Execution region</code>，<br><code>Execution region</code>语法如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c">execution_region_description ::=<br>exec_region_name (base_address <span class="hljs-string">| &quot;</span>+<span class="hljs-string">&quot; offset) [attribute_list] [max_size | length]</span><br><span class="hljs-string">&quot;&#123;&quot;</span><br>input_section_description*<br><span class="hljs-string">&quot;&#125;</span><br></code></pre></td></tr></table></figure><p><code>Execution region</code>中含有一个或多个<code>Input section</code>，<br><code>Input section</code>语法如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c">input_section_description ::=<br>module_select_pattern [ <span class="hljs-string">&quot;(&quot;</span> input_section_selector ( <span class="hljs-string">&quot;,&quot;</span><br>input_section_selector )* <span class="hljs-string">&quot;)&quot;</span> ]<br>input_section_selector ::=<br><span class="hljs-string">&quot;+&quot;</span> input_section_attr <span class="hljs-string">|</span><br>input_section_pattern <span class="hljs-string">|</span><br>input_section_type <span class="hljs-string">|</span><br>input_symbol_pattern <span class="hljs-string">|</span><br>section_properties<br></code></pre></td></tr></table></figure><h2 id="3-散列文件解析"><a href="#3-散列文件解析" class="headerlink" title="3. 散列文件解析"></a>3. 散列文件解析</h2><p><img src="/./../photo/001_sct_example.png"></p><p><img src="/./../photo/image-20231016192932240.png" alt="image-20231016192932240"></p><p>*.o ：所有objects文件</p><p>*：所有objects文件和库，在一个散列文件中只能使用一个*</p><p>.ANY：等同于*，优先级比*低；在一个散列文件的多个可执行域中可以有多个<code>.ANY</code></p><h2 id="4-怎么获得region的信息"><a href="#4-怎么获得region的信息" class="headerlink" title="4. 怎么获得region的信息"></a>4. 怎么获得region的信息</h2><h3 id="4-1-可执行域的信息"><a href="#4-1-可执行域的信息" class="headerlink" title="4.1 可执行域的信息"></a>4.1 可执行域的信息</h3><p><img src="/./../photo/002_execution_region_symbol.png"></p><h3 id="4-2-加载域的信息"><a href="#4-2-加载域的信息" class="headerlink" title="4.2 加载域的信息"></a>4.2 加载域的信息</h3><p><img src="/./../photo/003_load_region_symbol.png"></p><h3 id="4-3-汇编代码里怎么使用这些信息（数据段重定位）"><a href="#4-3-汇编代码里怎么使用这些信息（数据段重定位）" class="headerlink" title="4.3 汇编代码里怎么使用这些信息（数据段重定位）"></a>4.3 汇编代码里怎么使用这些信息（数据段重定位）</h3><p>示例代码如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gams">IMPORT |Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base|<br>IMPORT |Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length|<br>IMPORT |Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base|<br><br>LDR R0, = |Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base|    ; DEST<br>LDR R1, = |Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base|     ; SORUCE<br>LDR R2, = |Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length|  ; LENGTH<br></code></pre></td></tr></table></figure><h3 id="4-4-C语言里怎么使用这些信息"><a href="#4-4-C语言里怎么使用这些信息" class="headerlink" title="4.4 C语言里怎么使用这些信息"></a>4.4 C语言里怎么使用这些信息</h3><h4 id="4-4-1-方法1"><a href="#4-4-1-方法1" class="headerlink" title="4.4.1 方法1"></a>4.4.1 方法1</h4><p>声明为外部变量。<br>注意：使用时<strong>需要</strong>使用取址符：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">extern int Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base;<br>extern int Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base;<br>extern int Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length;<br><br>memcpy(&amp;Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base, &amp;Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length, &amp;Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base);<br></code></pre></td></tr></table></figure><h4 id="4-4-2-方法2"><a href="#4-4-2-方法2" class="headerlink" title="4.4.2 方法2"></a>4.4.2 方法2</h4><p>声明为外部数组。<br>注意：使用时<strong>不需要</strong>使用取址符：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">extern char Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base[];<br>extern char Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base[];<br>extern int Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length;<br><br>memcpy(Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base, Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length, &amp;Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base);<br></code></pre></td></tr></table></figure><h1 id="五、清除BSS段-ZI段"><a href="#五、清除BSS段-ZI段" class="headerlink" title="五、清除BSS段(ZI段)"></a>五、清除BSS段(ZI段)</h1><h2 id="1-C语言中的BSS段"><a href="#1-C语言中的BSS段" class="headerlink" title="1. C语言中的BSS段"></a>1. C语言中的BSS段</h2><p>程序里的全局变量，如果它的初始值为0，或者没有设置初始值，这些变量被放在BSS段里，也叫ZI段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> g_Char = <span class="hljs-string">&#x27;A&#x27;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> g_Char2 = <span class="hljs-string">&#x27;B&#x27;</span>;<br><span class="hljs-type">int</span> g_A = <span class="hljs-number">0</span>;  <span class="hljs-comment">// 放在BSS段</span><br><span class="hljs-type">int</span> g_B;      <span class="hljs-comment">// 放在BSS段</span><br></code></pre></td></tr></table></figure><p>BSS段并不会放入bin文件中，否则也太浪费空间了。<br>在使用BSS段里的变量之前，把BSS段所占据的内存清零就可以了。</p><ul><li><p>注意：对于keil来说，一个本该放到BSS段的变量，如果它所占据的空间小于等于8字节自己，keil仍然会把它放在data段里。只有当它所占据的空间大于8字节时，才会放到BSS段。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> g_A[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;   <span class="hljs-comment">// 放在BSS段</span><br><span class="hljs-type">char</span> g_B[<span class="hljs-number">9</span>];           <span class="hljs-comment">// 放在BSS段</span><br><br><span class="hljs-type">int</span> g_A[<span class="hljs-number">2</span>] = &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;;   <span class="hljs-comment">// 放在data段</span><br><span class="hljs-type">char</span> g_B[<span class="hljs-number">8</span>];           <span class="hljs-comment">// 放在data段</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-清除BSS段"><a href="#2-清除BSS段" class="headerlink" title="2. 清除BSS段"></a>2. 清除BSS段</h2><h3 id="2-1-BSS段在哪？多大？"><a href="#2-1-BSS段在哪？多大？" class="headerlink" title="2.1 BSS段在哪？多大？"></a>2.1 BSS段在哪？多大？</h3><p>在散列文件中，BSS段(ZI段)在可执行域<code>RW_IRAM1</code>中描述：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dns">LR_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;    <span class="hljs-comment">; load region size_region</span><br>  ER_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;  <span class="hljs-comment">; load address = execution address</span><br>   *.o (RESET, +First)<br>   *(InRoot$$Sections)<br>   .ANY (+RO)<br>   .ANY (+XO)<br>  &#125;<br>  RW_IRAM1 <span class="hljs-number">0x20000000</span> <span class="hljs-number">0x00010000</span>  &#123;  <span class="hljs-comment">; RW data</span><br>   .ANY (+RW +ZI)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BSS段(ZI段)的链接地址(基地址)、长度，使用下面的符号获得：<br><img src="/./../photo/004_bss_section_symbol.png"></p><h3 id="2-2-怎么清除BSS段"><a href="#2-2-怎么清除BSS段" class="headerlink" title="2.2  怎么清除BSS段"></a>2.2  怎么清除BSS段</h3><h4 id="2-2-1-汇编码"><a href="#2-2-1-汇编码" class="headerlink" title="2.2.1 汇编码"></a>2.2.1 汇编码</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">IMPORT |Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ZI<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base|<br>IMPORT |Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ZI<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length|<br><br>LDR R0, = |Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ZI<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base|       ; DEST<br>LDR R1, = |Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>RW_IRAM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ZI<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length|     ; Length<br>BL memset<br></code></pre></td></tr></table></figure><h4 id="2-2-2-C语言"><a href="#2-2-2-C语言" class="headerlink" title="2.2.2 C语言"></a>2.2.2 C语言</h4><ul><li>方法1<br>声明为外部变量，使用时<strong>需要</strong>使用取址符：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> Image$$RW_IRAM1$$ZI$$Base;<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> Image$$RW_IRAM1$$ZI$$Length;<br><br><span class="hljs-built_in">memset</span>(&amp;Image$$RW_IRAM1$$ZI$$Base, <span class="hljs-number">0</span>, &amp;Image$$RW_IRAM1$$ZI$$Length);<br></code></pre></td></tr></table></figure><ul><li>方法2<br>声明为外部数组，使用时<strong>不需要</strong>使用取址符：</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> Image$$RW_IRAM1$$ZI$$Base[];<br><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> Image$$RW_IRAM1$$ZI$$Length[];<br><br><span class="hljs-built_in">memset</span>(Image$$RW_IRAM1$$ZI$$Base[], <span class="hljs-number">0</span>, Image$$RW_IRAM1$$ZI$$Length);<br></code></pre></td></tr></table></figure><h1 id="六、代码段重定位"><a href="#六、代码段重定位" class="headerlink" title="六、代码段重定位"></a>六、代码段重定位</h1><h2 id="1-加载地址等于链接地址"><a href="#1-加载地址等于链接地址" class="headerlink" title="1. 加载地址等于链接地址"></a>1. 加载地址等于链接地址</h2><p>在默认散列文件中，代码段的<code>load address = execution address</code>，<br>也就是加载地址和执行地址(链接地址)一致，所以无需重定位：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dns">LR_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;    <span class="hljs-comment">; load region size_region</span><br>  ER_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;  <span class="hljs-comment">; load address = execution address</span><br>   *.o (RESET, +First)<br>   *(InRoot$$Sections)<br>   .ANY (+RO)<br>   .ANY (+XO)<br>  &#125;<br>  RW_IRAM1 <span class="hljs-number">0x20000000</span> <span class="hljs-number">0x00010000</span>  &#123;  <span class="hljs-comment">; RW data</span><br>   .ANY (+RW +ZI)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-加载地址不等于链接地址"><a href="#2-加载地址不等于链接地址" class="headerlink" title="2.加载地址不等于链接地址"></a>2.加载地址不等于链接地址</h2><p>有时候，我们需要把程序复制到内存里运行，比如：</p><ul><li>想让程序执行得更快：需要把代码段复制到内存里</li><li>程序很大，保存在片外SPI Flash中，SPI Flash上的代码无法直接执行，需要复制到内存里</li></ul><p>这时候，需要修改散列文件，把代码段的可执行域放在内存里。<br>那么程序运行时，需要尽快把代码段重定位到内存。<br>散列文件示例：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">LR_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;    ; <span class="hljs-keyword">load</span> region size_region<br>  ER_IROM1 <span class="hljs-number">0x20000000</span>   &#123;  ; <span class="hljs-keyword">load</span> address != execution address<br>   *.o (<span class="hljs-keyword">RESET</span>, +First)<br>   .<span class="hljs-keyword">ANY</span> (+RO)<br>   .<span class="hljs-keyword">ANY</span> (+XO)<br>  &#125;<br>  RW_IRAM1 +<span class="hljs-number">0</span>   &#123;  ; RW data<br>   .<span class="hljs-keyword">ANY</span> (+RW +ZI)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>改完之后出现报错（6个error）：</p><p>1.删除*(InRoot$$Sections)</p><p>2.将启动文件中的main改成mymain</p><p>不能打印：</p><p>将最开始执行的第二条指令改成 0x08000009</p></blockquote><p>上面的散列文件中：</p><ul><li>可执行域ER_IROM1<ul><li>加载地址为0x08000000，可执行地址为0x20000000，两者不相等</li><li>板子上电后，从0x08000000处开始运行，需要尽快把代码段复制到0x20000000</li></ul></li><li>可执行域RW_IRAM1<ul><li>加载地址：紧跟着ER_IROM1的加载地址</li><li>可执行地址：紧跟着ER_IROM1的可执行地址</li><li>需要尽快把数据段复制到可执行地址处</li></ul></li></ul><p>数据段的重定位我们做过实验，<br>如果代码段不重定位的话，会发生什么事？</p><h2 id="3-代码段不重定位的后果"><a href="#3-代码段不重定位的后果" class="headerlink" title="3. 代码段不重定位的后果"></a>3. 代码段不重定位的后果</h2><p>不能使用链接地址来调用函数</p><ul><li><p>汇编中</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">ldr</span>  <span class="hljs-built_in">pc</span>, <span class="hljs-symbol">=main</span>   <span class="hljs-comment">; 这样调用函数时，用到main函数的链接地址，如果代码段没有重定位，则跳转失败</span><br></code></pre></td></tr></table></figure></li><li><p>C语言中</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> (*funcptr)(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *s, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> val);<br>funcptr = put_s_hex;<br>funcptr(<span class="hljs-string">&quot;hello, test function ptr&quot;</span>, <span class="hljs-number">123</span>);<br></code></pre></td></tr></table></figure></li></ul><h2 id="4-代码段重定位"><a href="#4-代码段重定位" class="headerlink" title="4. 代码段重定位"></a>4. 代码段重定位</h2><h3 id="4-1-代码段在哪？多大？"><a href="#4-1-代码段在哪？多大？" class="headerlink" title="4.1 代码段在哪？多大？"></a>4.1 代码段在哪？多大？</h3><p>在散列文件中，代码段在可执行域<code>ER_IROM1</code>中描述：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dns">LR_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;    <span class="hljs-comment">; load region size_region</span><br>  ER_IROM1 <span class="hljs-number">0x08000000</span> <span class="hljs-number">0x00080000</span>  &#123;  <span class="hljs-comment">; load address = execution address</span><br>   *.o (RESET, +First)<br>   *(InRoot$$Sections)<br>   .ANY (+RO)<br>   .ANY (+XO)<br>  &#125;<br>  RW_IRAM1 <span class="hljs-number">0x20000000</span> <span class="hljs-number">0x00010000</span>  &#123;  <span class="hljs-comment">; RW data</span><br>   .ANY (+RW +ZI)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码段的链接地址(基地址)、长度，使用下面的符号获得：</p><p>005_text_section_execution_symbol.png)</p><p>代码段的加载地址，使用下面的符号获得：</p><p><img src="/./../photo/006_text_section_load_symbol.png"></p><h3 id="4-2-怎么重定位"><a href="#4-2-怎么重定位" class="headerlink" title="4.2 怎么重定位"></a>4.2 怎么重定位</h3><h4 id="4-2-1-汇编代码"><a href="#4-2-1-汇编代码" class="headerlink" title="4.2.1 汇编代码"></a>4.2.1 汇编代码</h4><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams">IMPORT |Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base|<br>IMPORT |Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length|<br>IMPORT |Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base|<br><br>LDR R0, = |Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base|    ; DEST<br>LDR R1, = |Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base|     ; SORUCE<br>LDR R2, = |Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length|  ; LENGTH<br>BL memcpy<br></code></pre></td></tr></table></figure><h4 id="4-2-2-C语言代码"><a href="#4-2-2-C语言代码" class="headerlink" title="4.2.2 C语言代码"></a>4.2.2 C语言代码</h4><ul><li>方法1</li></ul><p>声明为外部变量，使用时<strong>需要</strong>使用取址符：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">extern int Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base;<br>extern int Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base;<br>extern int Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length;<br><br>memcpy(&amp;Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base, &amp;Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length, &amp;Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base);<br></code></pre></td></tr></table></figure><ul><li>方法2</li></ul><p>声明为外部数组，使用时<strong>不需要</strong>使用取址符：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">extern char Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base[];<br>extern char Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base[];<br>extern int Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length;<br><br>memcpy(Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base, Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length, &amp;Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base);<br></code></pre></td></tr></table></figure><h2 id="5-为什么重定位之前的代码也可以正常运行？"><a href="#5-为什么重定位之前的代码也可以正常运行？" class="headerlink" title="5. 为什么重定位之前的代码也可以正常运行？"></a>5. 为什么重定位之前的代码也可以正常运行？</h2><p>因为重定位之前的代码是使用<strong>位置无关码</strong>写的：</p><ul><li><p>只使用相对跳转指令：B、BL</p></li><li><p>不只用绝对跳转指令：</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-symbol">=main</span><br><span class="hljs-keyword">BLX</span> <span class="hljs-built_in">R0</span><br></code></pre></td></tr></table></figure></li><li><p>不访问全局变量、静态变量、字符串、数组</p></li><li><p>重定位完后，使用绝对跳转指令跳转到XXX函数的链接地址去</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">BL</span> main         <span class="hljs-comment">; bl相对跳转，程序仍在Flash上运行</span><br><br><span class="hljs-keyword">LDR</span> <span class="hljs-built_in">R0</span>, <span class="hljs-symbol">=main</span>   <span class="hljs-comment">; 绝对跳转，跳到链接地址去，就是跳去内存里执行</span><br><span class="hljs-keyword">BLX</span> <span class="hljs-built_in">R0</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="七、重定位的纯C函数实现"><a href="#七、重定位的纯C函数实现" class="headerlink" title="七、重定位的纯C函数实现"></a>七、重定位的纯C函数实现</h1><h2 id="1-难点"><a href="#1-难点" class="headerlink" title="1. 难点"></a>1. 难点</h2><p>难点在于，怎么得到各个域的加载地址、链接地址、长度。</p><ul><li>方法1</li></ul><p>声明为外部变量，使用时<strong>需要</strong>使用取址符：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">extern int Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base;<br>extern int Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base;<br>extern int Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length;<br><br>memcpy(&amp;Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base, &amp;Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length, &amp;Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base);<br></code></pre></td></tr></table></figure><ul><li>方法2</li></ul><p>声明为外部数组，使用时<strong>不需要</strong>使用取址符：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams">extern char Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base[];<br>extern char Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base[];<br>extern int Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length;<br><br>memcpy(Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base, Image<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Length, &amp;Load<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>ER_IROM1<span class="hljs-symbol">$</span><span class="hljs-symbol">$</span>Base);<br></code></pre></td></tr></table></figure><h2 id="2-怎么理解上述代码"><a href="#2-怎么理解上述代码" class="headerlink" title="2. 怎么理解上述代码"></a>2. 怎么理解上述代码</h2><p> 对于这样的C变量：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> g_a;<br></code></pre></td></tr></table></figure><p>编译的时候会有一个符号表(symbol table)，如下：</p><table><thead><tr><th>Name</th><th>Address</th></tr></thead><tbody><tr><td>g_a</td><td>xxxxxxxx</td></tr></tbody></table><p>对于散列文件中的各类Symbol，有2中声明方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">extern</span> <span class="hljs-type">int</span> Image$$ER_IROM1$$Base;     <span class="hljs-comment">// 声明为一般变量</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> Image$$ER_IROM1$$Base[];  <span class="hljs-comment">// 声明为数组</span><br></code></pre></td></tr></table></figure><p>不管是哪种方式，它们都会保存在符号表里，比如：</p><table><thead><tr><th>Name</th><th>Address</th></tr></thead><tbody><tr><td>g_a</td><td>xxxxxxxx</td></tr><tr><td>Image$$ER_IROM1$$Base</td><td>yyyyyyyy</td></tr></tbody></table><ul><li>对于<code>int g_a</code>变量<ul><li>使用<code>&amp;g_a</code>得到符号表里的地址。</li></ul></li><li>对于<code>extern int Image$$ER_IROM1$$Base</code>变量<ul><li>要得到符号表中的地址，也是使用<code>&amp;Image$$ER_IROM1$$Base</code>。</li></ul></li><li>对于<code>extern char Image$$ER_IROM1$$Base[]</code>变量<ul><li>要得到符号表中的地址，直接使用<code>Image$$ER_IROM1$$Base</code>，不需要加<code>&amp;</code></li><li>为什么？mage$$ER_IROM1$$Base本身就表示地址啊</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>STM32</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>架构</tag>
      
      <tag>STM32</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>stm32mp157启动及移植</title>
    <link href="/2023/06/16/stm32mp157%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%A7%BB%E6%A4%8D/"/>
    <url>/2023/06/16/stm32mp157%E5%90%AF%E5%8A%A8%E5%8F%8A%E7%A7%BB%E6%A4%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1、stm32mp157启动方式"><a href="#1、stm32mp157启动方式" class="headerlink" title="1、stm32mp157启动方式"></a>1、stm32mp157启动方式</h1><ul><li><p>相对于MCU的启动方式，MPU的启动要复杂很多。对于MPU的芯片来说，启动方式都是大差不差，大致如下进行；看似先从启动bootloader，但是实际这个bootloader也需要运行的地方。所以大部分的芯片内部都有一小段存放厂商写好的一个裸机程序放在ROM里面，这里的ROM不是指的flash之类的。而是芯片内部的ROM，然后还有一个内部的RAM，这个不是DDR。</p></li><li><p>stm32mp1的启动方式有以下几种，根据芯片的BOOT0和BOOT1和BOOT2引脚来设置。</p><p><img src="/./../photo/157%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F.png"></p></li><li><p>我们的代码存在EMMC上面，也就是NAND Flash上面，他是非XIP设备，不能直接运行程序。因此需要把上面的代码搬运到DDR上面来运行，可是DDR不像SRAM，不用初始化就可以使用。使用前需要初始化DDR才能使用。stm32mp157里面有128K的内部ROM地址为0x00000000<del>0x00020000和256KB的内部RAM地址为0x2FFC0000</del>0x2FFFFFFF。内部的ROM存储的代码针对不同启动方式有实现不同的功能。</p><p><img src="/./../photo/157%E5%86%85%E9%83%A8ROM.png"></p><p><img src="/./../photo/157%E5%86%85%E9%83%A8RAM.png"></p></li><li><p>我们选择外部FLASH启动时候，内部ROM的功能就会执行安全启动（secure boot）；安全启动很复杂，只要CPU正常运行，就会进入冷启动，然后就从flash中加载系统，并且进行鉴权，鉴权成功才会加载内核系统。</p></li><li><p>bootloader启动分成两个阶段第一阶段启动阶段FSBL和第二启动阶段SSBL阶段。上电后内部ROM在安全启动方式下。ROM代码从选定的flash里面加载的第一段代码就是FSBL镜像，这个镜像有个要求在可执行二进制文件加一段头部信息代码。ROM读取了带头部信息的FSBL镜像后，把带头部信息的镜像拷贝到内部RAM里面运行，先对头部信息进行鉴权，鉴权成功后，头部信息保存着FSBL镜像的入口地址0x2FFC2500，头部信息大小为0x100。因此带头信息的FSBL镜像会被加载到0x2FFC2400这个地址上执行。我们可以在任意裸机程序加上头部信息就可以作为FSBL镜像了。</p></li><li><p>st公司专门做了一个添加头部信息的软件，来给二进制文件加头部，让内部代码可以鉴权成功。工具叫stm32image。可以从github下载：<a href="https://github.com/ARM-software/arm-trusted-firmware/tree/master/tools/stm32image">arm-trusted-firmware&#x2F;tools&#x2F;stm32image at master · ARM-software&#x2F;arm-trusted-firmware · GitHub</a>；下载后是一个c代码，我们需要编译一下。注意这里不是使用交叉编译工具链，是使用ubunt自带的gcc工具链</p><p><img src="/./../photo/157image.png"></p></li><li><p>在stm32mp157中启动流程是bootROM-&gt;TFA可信固件(FSBL)-&gt;uboot(SSBL)-&gt;linux-&gt;rootfs这里多出来一个TFA可信固件，主要是ARM为了针对CPU安全提出来的一种隔离方式启动，如果内部ROM鉴权失败，是不会启动后面的uboot一系列操作。</p></li><li><p>TFA源码介绍</p></li></ul><h1 id="2、SD卡移植"><a href="#2、SD卡移植" class="headerlink" title="2、SD卡移植"></a>2、SD卡移植</h1>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FreeRTOS总结</title>
    <link href="/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/"/>
    <url>/2023/02/11/FreeRTOS%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1、FreeRTOS简介"><a href="#1、FreeRTOS简介" class="headerlink" title="1、FreeRTOS简介"></a>1、FreeRTOS简介</h1><h2 id="1-1嵌入式操作系统简介"><a href="#1-1嵌入式操作系统简介" class="headerlink" title="1&#x2F;1嵌入式操作系统简介"></a>1&#x2F;1嵌入式操作系统简介</h2><ul><li>操作系统是允许多个任务“同时运行”的，操作系统的这个特性被称为多任务。然而实际 上，一个 CPU 核心在某一时刻只能运行一个任务，而操作系统中任务调度器的责任就是决定在 某一时刻 CPU 究竟要运行哪一个任务，任务调度器使得 CPU 在各个任务之间来回切换并处理 任务，由于切换处理任务的速度非常快，因此就给人造成了一种同一时刻有多个任务同时运行 的错觉。</li></ul><h2 id="1-2为什么要引入FreeRTOS"><a href="#1-2为什么要引入FreeRTOS" class="headerlink" title="1&#x2F;2为什么要引入FreeRTOS"></a>1&#x2F;2为什么要引入FreeRTOS</h2><ul><li>FreeRTOS是嵌入式实时操作系统的一种，但是它具备的优点：可移植性强、可裁剪、支持多种任务通讯、同步机制、高效的软件定时器、任务数量、优先级数量不限、运行效率高、支持抢占式、合作式调度、开源、免费、可商用。功能强大，技术成熟的实时操作系统。引入实时操作系统后，可以同步处理多个任务，让CPU执行效率更高。不像裸机结构，针对某个任务需要不断查询，造成CPU资源浪费。</li></ul><h2 id="1-3如何获取FreeRTOS"><a href="#1-3如何获取FreeRTOS" class="headerlink" title="1&#x2F;3如何获取FreeRTOS"></a>1&#x2F;3如何获取FreeRTOS</h2><ul><li>FreeRTOS是用C语言编写的一个操作系统，可以在官网获取到源码。<a href="https://www.freertos.org/zh-cn-cmn-s/">FreeRTOS官网链接</a></li></ul><p>进入官网后点击下载，即可获取最新的FreeRTOS的源码，如图所示：</p><p><img src="/./../photo/%E5%AE%98%E7%BD%91%E5%9B%BE.png"></p><h2 id="1-2FreeRTOS源码目录及其介绍"><a href="#1-2FreeRTOS源码目录及其介绍" class="headerlink" title="1&#x2F;2FreeRTOS源码目录及其介绍"></a>1&#x2F;2FreeRTOS源码目录及其介绍</h2><ul><li>下载解压后，如图所示 ：</li></ul><p><img src="/./../photo/%E6%BA%90%E7%A0%81.png"></p><ul><li><p>源码目录内容介绍：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs DTS">├─FreeRTOS<br>│  ├─Demo<span class="hljs-comment">// 各种开发工具的完整Demo，开发者可以方便的以此搭建出自己的项目，甚至直接使用</span><br>│  │  ├─Common<span class="hljs-comment">// 所有例程都可以使用的演示例程文件</span><br>│  │  └─其他<span class="hljs-comment">// 对应平台和开发工具的项目例程（命名：平台_开发工具，例如：CORTEX_M4F_M0_LPC43xx_Keil）</span><br>│  ├─License<span class="hljs-comment">// 使用修改过的 GPL</span><br>│  └─Source<span class="hljs-comment">// FreeRTOS的源码</span><br>│      ├─include<span class="hljs-comment">// 源码对应的头文件</span><br>│      └─portable<span class="hljs-comment">// 每个支持的处理器架构需要一小段与处理器架构相关的RTOS代码。该目录下即为和开发平台相关的代码</span><br>│            ├─MemMang<span class="hljs-comment">// FreeRTOS内存管理方案（一般要根据平台来选择以下5个之一）</span><br>│            │     heap_1.c<br>│            │     heap_2.c<br>│            │     heap_3.c<br>│            │     heap_4.c<br>│            │     heap_5.c<br>│            └─其他<span class="hljs-comment">// 其他开发工具相关的代码，需要根据自己的开发工具进行选择</span><br>│      croutine.c<span class="hljs-comment">// 协线程（协程）文件，和任务类似，在系统资源比较缺乏下使用</span><br>│      event_groups.c<span class="hljs-comment">// 事件标志组</span><br>│      list.c<span class="hljs-comment">// 列表结构描述，在内核整体控制上都使用了列表格式数据处理,一切数据结构的基础</span><br>│      queue.c<span class="hljs-comment">// 队列，任务和任务之间的通讯处理</span><br>│      tasks.c<span class="hljs-comment">// 所有任务相关函数</span><br>│      timers.c<span class="hljs-comment">// 软件定时器，以任务形式存在</span><br>|      stream_buffer.c<span class="hljs-comment">// 10.0.0 新增</span><br>└─FreeRTOS-Plus<span class="hljs-comment">// FreeRTOS+组件和演示例程</span><br></code></pre></td></tr></table></figure></li></ul><h1 id="2、FreeRTOS移植"><a href="#2、FreeRTOS移植" class="headerlink" title="2、FreeRTOS移植"></a>2、FreeRTOS移植</h1><h2 id="2-1源码具体分类"><a href="#2-1源码具体分类" class="headerlink" title="2&#x2F;1源码具体分类"></a>2&#x2F;1源码具体分类</h2><ul><li><p><strong>操作系统内核核心文件</strong>：内核的核心文件，包括任务管理、调度算法、消息通知…等等重要文件</p><ul><li><img src="/./../photo/freertos%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></li></ul></li><li><p><strong>硬件架构相关的文件</strong>：这个里面的内容都是与具体处理器架构相关的文件，根据不同的架构选择不同的文件，如图所示，这个里面的文件是操作系统跟硬件架构相适配，保证系统正常运行</p><ul><li><p>例如ARM架构下的cortex-m3和cortex-m4架构的文件如图</p><p><img src="/./../photo/freertos%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></p></li></ul></li><li><p><strong>内存管理算法文件，以及配置文件</strong>；FreeRTOS提供了5种内存管理算法。为了方便裁剪系统，官方DEMO文件中定义了一个FreeRTOSConfig.h的头文件，里面都是一些宏开关，可以根据需求，来裁剪系统，使不需要的配置不被编译进目标文件。</p><ul><li><p>内存管理文件如图</p><p><img src="/./../photo/freertos%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></p></li><li><p>配置文件模板：这个配置文件，没有固定的文件，官方只是在示例中给出一些模板，用户可以根据这个模板来自己修改内容，另外可以模仿直接从写一份；如图所示</p><p><img src="/./../photo/freertos%E9%85%8D%E7%BD%AE%E7%9B%B8%E5%85%B3%E6%96%87%E4%BB%B6.png"></p></li></ul></li></ul><h2 id="2-2基于CORTEX-M3-M4系列的移植"><a href="#2-2基于CORTEX-M3-M4系列的移植" class="headerlink" title="2&#x2F;2基于CORTEX-M3&#x2F;M4系列的移植"></a>2&#x2F;2基于CORTEX-M3&#x2F;M4系列的移植</h2><ul><li><p>移植前需要稍微了解一下这两个架构异常和中断类型；</p><ul><li><p>如图就是cm3的异常表</p><p><img src="/./../photo/cm4%E5%BC%82%E5%B8%B8%E8%A1%A8.png"></p></li><li><p>这里我们主要关注这三个异常</p><ul><li><p>SYSTICK异常：cortex-m系列的产品里面的系统滴答定时器产生的异常，在freertos中使用滴答定时器作为系统的心跳，以此来实现时间片轮转的调度功能；每当时间片（就是滴答定时器计数到了）到了，调用相应的中断服务函数来检查是否需要切换任务。在freertos的port.c中定义了相应的中断服务函数，如图；</p><p><img src="/./../photo/systick%E5%87%BD%E6%95%B0.png"></p></li><li><p>PendSV异常：根据上述，SYSTICK这个异常只是检查是否要进行任务切换，真正要实现任务切换的是触发PendSV异常，在freertos的port.c中定义了相应的中断服务函数，如图；</p><p><img src="/./../photo/pendsv%E5%87%BD%E6%95%B0.png"></p></li><li><p>SVC异常：这个异常在freertos中一般只会使用一次，它也是用来进行任务调度的，但是只在vTaskStartScheduler(void)这个函数里面调用一次，在freertos中定义了相关的中断服务函数。这个函数调用流程为（vTaskStartScheduler( void )-&gt;xPortStartScheduler( void )-&gt;prvPortStartFirstTask(void)在这个函数里面会触发svc异常）</p><p><img src="/./../photo/svc%E5%87%BD%E6%95%B0.png"></p></li></ul></li></ul></li><li><p>修改启动文件，启动文件里面定义了中断服务函数的名称，需要用freertos中的这三个函数名替换掉三个函数</p><p><img src="/./../photo/%E4%BF%AE%E6%94%B9%E5%90%AF%E5%8A%A8%E6%96%87%E4%BB%B6.png"></p></li><li><p>注释掉HAL库下的中断服务函数：stm32fxxx_it.c文件里面注释掉这三个函数。</p></li><li><p>最后就是将上述操作系统内核核心文件、架构文件、配置文件的c文件加入到项目内，然后添加相应的头文件路径。到这里基本上freertos移植完成了。剩下一些裁剪功能，配置等等在相应的配置文件来处理。</p></li></ul><h2 id="2-3配置文件以及内存管理算法细节"><a href="#2-3配置文件以及内存管理算法细节" class="headerlink" title="2&#x2F;3配置文件以及内存管理算法细节"></a>2&#x2F;3配置文件以及内存管理算法细节</h2><ul><li><p>配置文件主要是对FreeRTOS.h这个头文件的内容进行一些裁剪，并且里面有些如果不定义就会报错；如图必须需要定义的；其他具体的配置内容可以参考FreeRTOS.h这个头文件来进行裁剪和进行配置</p><p><img src="/./../photo/freertos%E5%BF%85%E9%A1%BB%E5%AE%9A%E4%B9%89.png"></p></li><li><p>FreeRTOSConfig.h模板如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> FREERTOS_CONFIG_H</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FREERTOS_CONFIG_H</span><br><br><span class="hljs-comment">/* 头文件 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> SystemCoreClock;<br><br><span class="hljs-comment">/* 基础配置项 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_PREEMPTION                            1                       <span class="hljs-comment">/* 1: 抢占式调度器, 0: 协程式调度器, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION         1                       <span class="hljs-comment">/* 1: 使用硬件计算下一个要运行的任务, 0: 使用软件算法计算下一个要运行的任务, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TICKLESS_IDLE                         0                       <span class="hljs-comment">/* 1: 使能tickless低功耗模式, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configCPU_CLOCK_HZ                              SystemCoreClock         <span class="hljs-comment">/* 定义CPU主频, 单位: Hz, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSYSTICK_CLOCK_HZ                          (configCPU_CLOCK_HZ / 8)<span class="hljs-comment">/* 定义SysTick时钟频率，当SysTick时钟频率与内核时钟频率不同时才可以定义, 单位: Hz, 默认: 不定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTICK_RATE_HZ                              1000                    <span class="hljs-comment">/* 定义系统时钟节拍频率, 单位: Hz, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_PRIORITIES                            32                      <span class="hljs-comment">/* 定义最大优先级数, 最大优先级=configMAX_PRIORITIES-1, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMINIMAL_STACK_SIZE                        128                     <span class="hljs-comment">/* 定义空闲任务的栈空间大小, 单位: Word, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_TASK_NAME_LEN                         16                      <span class="hljs-comment">/* 定义任务名最大字符数, 默认: 16 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_16_BIT_TICKS                          0                       <span class="hljs-comment">/* 1: 定义系统时钟节拍计数器的数据类型为16位无符号数, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configIDLE_SHOULD_YIELD                         1                       <span class="hljs-comment">/* 1: 使能在抢占式调度下,同优先级的任务能抢占空闲任务, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TASK_NOTIFICATIONS                    1                       <span class="hljs-comment">/* 1: 使能任务间直接的消息传递,包括信号量、事件标志组和消息邮箱, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTASK_NOTIFICATION_ARRAY_ENTRIES           1                       <span class="hljs-comment">/* 定义任务通知数组的大小, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_MUTEXES                               1                       <span class="hljs-comment">/* 1: 使能互斥信号量, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_RECURSIVE_MUTEXES                     1                       <span class="hljs-comment">/* 1: 使能递归互斥信号量, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_COUNTING_SEMAPHORES                   1                       <span class="hljs-comment">/* 1: 使能计数信号量, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_ALTERNATIVE_API                       0                       <span class="hljs-comment">/* 已弃用!!! */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configQUEUE_REGISTRY_SIZE                       8                       <span class="hljs-comment">/* 定义可以注册的信号量和消息队列的个数, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_QUEUE_SETS                            1                       <span class="hljs-comment">/* 1: 使能队列集, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TIME_SLICING                          1                       <span class="hljs-comment">/* 1: 使能时间片调度, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_NEWLIB_REENTRANT                      0                       <span class="hljs-comment">/* 1: 任务创建时分配Newlib的重入结构体, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configENABLE_BACKWARD_COMPATIBILITY             0                       <span class="hljs-comment">/* 1: 使能兼容老版本, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configNUM_THREAD_LOCAL_STORAGE_POINTERS         0                       <span class="hljs-comment">/* 定义线程本地存储指针的个数, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSTACK_DEPTH_TYPE                          uint16_t                <span class="hljs-comment">/* 定义任务堆栈深度的数据类型, 默认: uint16_t */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMESSAGE_BUFFER_LENGTH_TYPE                size_t                  <span class="hljs-comment">/* 定义消息缓冲区中消息长度的数据类型, 默认: size_t */</span></span><br><br><span class="hljs-comment">/* 内存分配相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSUPPORT_STATIC_ALLOCATION                 0                       <span class="hljs-comment">/* 1: 支持静态申请内存, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION                1                       <span class="hljs-comment">/* 1: 支持动态申请内存, 默认: 1 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTOTAL_HEAP_SIZE                           ((size_t)(10 * 1024))   <span class="hljs-comment">/* FreeRTOS堆中可用的RAM总量, 单位: Byte, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configAPPLICATION_ALLOCATED_HEAP                0                       <span class="hljs-comment">/* 1: 用户手动分配FreeRTOS内存堆(ucHeap), 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configSTACK_ALLOCATION_FROM_SEPARATE_HEAP       0                       <span class="hljs-comment">/* 1: 用户自行实现任务创建时使用的内存申请与释放函数, 默认: 0 */</span></span><br><br><span class="hljs-comment">/* 钩子函数相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_IDLE_HOOK                             0                       <span class="hljs-comment">/* 1: 使能空闲任务钩子函数, 无默认需定义  */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TICK_HOOK                             0                       <span class="hljs-comment">/* 1: 使能系统时钟节拍中断钩子函数, 无默认需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configCHECK_FOR_STACK_OVERFLOW                  0                       <span class="hljs-comment">/* 1: 使能栈溢出检测方法1, 2: 使能栈溢出检测方法2, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_MALLOC_FAILED_HOOK                    0                       <span class="hljs-comment">/* 1: 使能动态内存申请失败钩子函数, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_DAEMON_TASK_STARTUP_HOOK              0                       <span class="hljs-comment">/* 1: 使能定时器服务任务首次执行前的钩子函数, 默认: 0 */</span></span><br><br><span class="hljs-comment">/* 运行时间和任务状态统计相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configGENERATE_RUN_TIME_STATS                   0                       <span class="hljs-comment">/* 1: 使能任务运行时间统计功能, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">if</span> configGENERATE_RUN_TIME_STATS</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;./BSP/TIMER/btim.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()        ConfigureTimeForRunTimeStats()</span><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint32_t</span> FreeRTOSRunTimeTicks;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> portGET_RUN_TIME_COUNTER_VALUE()                FreeRTOSRunTimeTicks</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TRACE_FACILITY                        1                       <span class="hljs-comment">/* 1: 使能可视化跟踪调试, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS            1                       <span class="hljs-comment">/* 1: configUSE_TRACE_FACILITY为1时，会编译vTaskList()和vTaskGetRunTimeStats()函数, 默认: 0 */</span></span><br><br><span class="hljs-comment">/* 协程相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_CO_ROUTINES                           0                       <span class="hljs-comment">/* 1: 启用协程, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_CO_ROUTINE_PRIORITIES                 2                       <span class="hljs-comment">/* 定义协程的最大优先级, 最大优先级=configMAX_CO_ROUTINE_PRIORITIES-1, 无默认configUSE_CO_ROUTINES为1时需定义 */</span></span><br><br><span class="hljs-comment">/* 软件定时器相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configUSE_TIMERS                                1                               <span class="hljs-comment">/* 1: 使能软件定时器, 默认: 0 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_TASK_PRIORITY                       ( configMAX_PRIORITIES - 1 )    <span class="hljs-comment">/* 定义软件定时器任务的优先级, 无默认configUSE_TIMERS为1时需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_QUEUE_LENGTH                        5                               <span class="hljs-comment">/* 定义软件定时器命令队列的长度, 无默认configUSE_TIMERS为1时需定义 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configTIMER_TASK_STACK_DEPTH                    ( configMINIMAL_STACK_SIZE * 2) <span class="hljs-comment">/* 定义软件定时器任务的栈空间大小, 无默认configUSE_TIMERS为1时需定义 */</span></span><br><br><span class="hljs-comment">/* 可选函数, 1: 使能 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskPrioritySet                        1                       <span class="hljs-comment">/* 设置任务优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_uxTaskPriorityGet                       1                       <span class="hljs-comment">/* 获取任务优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskDelete                             1                       <span class="hljs-comment">/* 删除任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskSuspend                            1                       <span class="hljs-comment">/* 挂起任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xResumeFromISR                          1                       <span class="hljs-comment">/* 恢复在中断中挂起的任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskDelayUntil                         1                       <span class="hljs-comment">/* 任务绝对延时 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_vTaskDelay                              1                       <span class="hljs-comment">/* 任务延时 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetSchedulerState                  1                       <span class="hljs-comment">/* 获取任务调度器状态 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetCurrentTaskHandle               1                       <span class="hljs-comment">/* 获取当前任务的任务句柄 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_uxTaskGetStackHighWaterMark             1                       <span class="hljs-comment">/* 获取任务堆栈历史剩余最小值 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetIdleTaskHandle                  1                       <span class="hljs-comment">/* 获取空闲任务的任务句柄 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_eTaskGetState                           1                       <span class="hljs-comment">/* 获取任务状态 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xEventGroupSetBitFromISR                1                       <span class="hljs-comment">/* 在中断中设置事件标志位 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTimerPendFunctionCall                  1                       <span class="hljs-comment">/* 将函数的执行挂到定时器服务任务 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskAbortDelay                         1                       <span class="hljs-comment">/* 中断任务延时 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskGetHandle                          1                       <span class="hljs-comment">/* 通过任务名获取任务句柄 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INCLUDE_xTaskResumeFromISR                      1                       <span class="hljs-comment">/* 恢复在中断中挂起的任务 */</span></span><br><br><span class="hljs-comment">/* 中断嵌套行为配置 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> __NVIC_PRIO_BITS</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> configPRIO_BITS __NVIC_PRIO_BITS</span><br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> configPRIO_BITS 4</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configLIBRARY_LOWEST_INTERRUPT_PRIORITY         15                  <span class="hljs-comment">/* 中断最低优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY    5                   <span class="hljs-comment">/* FreeRTOS可管理的最高中断优先级 */</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configKERNEL_INTERRUPT_PRIORITY                 ( configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_SYSCALL_INTERRUPT_PRIORITY            ( configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS) )</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configMAX_API_CALL_INTERRUPT_PRIORITY           configMAX_SYSCALL_INTERRUPT_PRIORITY</span><br><br><span class="hljs-comment">/* FreeRTOS中断服务函数相关定义 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xPortPendSVHandler                              PendSV_Handler</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vPortSVCHandler                                 SVC_Handler</span><br><br><span class="hljs-comment">/* 断言 */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vAssertCalled(char, int) printf(<span class="hljs-string">&quot;Error: %s, %d\r\n&quot;</span>, char, int)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> configASSERT( x ) <span class="hljs-keyword">if</span>( ( x ) == 0 ) vAssertCalled( __FILE__, __LINE__ )</span><br><br><span class="hljs-comment">/* FreeRTOS MPU 特殊定义 */</span><br><span class="hljs-comment">//#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0</span><br><span class="hljs-comment">//#define configTOTAL_MPU_REGIONS                                8</span><br><span class="hljs-comment">//#define configTEX_S_C_B_FLASH                                  0x07UL</span><br><span class="hljs-comment">//#define configTEX_S_C_B_SRAM                                   0x07UL</span><br><span class="hljs-comment">//#define configENFORCE_SYSTEM_CALLS_FROM_KERNEL_ONLY            1</span><br><span class="hljs-comment">//#define configALLOW_UNPRIVILEGED_CRITICAL_SECTIONS             1</span><br><br><span class="hljs-comment">/* ARMv8-M 安全侧端口相关定义。 */</span><br><span class="hljs-comment">//#define secureconfigMAX_SECURE_CONTEXTS         5</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span> <span class="hljs-comment">/* FREERTOS_CONFIG_H */</span></span><br></code></pre></td></tr></table></figure></li><li><p>FreeRTOS提供的五种内存管理算法</p><ul><li><table><thead><tr><th align="center">文件</th><th align="center">优点</th><th align="center">缺点</th></tr></thead><tbody><tr><td align="center">heap_1.c</td><td align="center">分配简单，时间确定</td><td align="center">只分配空间，不能释放</td></tr><tr><td align="center">heap_2.c</td><td align="center">动态分配、最佳匹配</td><td align="center">内存碎片化、时间不定</td></tr><tr><td align="center">heap_3.c</td><td align="center">调用标准C库的函数</td><td align="center">速度慢、时间不定</td></tr><tr><td align="center">heap_4.c</td><td align="center">第二种方法的增强版，可以合并相邻空闲内存，解决碎片化</td><td align="center">时间不定</td></tr><tr><td align="center">heap_5.c</td><td align="center">在第四种方法上支持分隔内存块，解决碎片化</td><td align="center">时间不定</td></tr></tbody></table></li><li><p>heap_1的实现方法；它只提供分配函数，不提供释放函数，具体实现就是直接定义一个大数组如图所示：<img src="/./../photo/heap1%E6%95%B0%E7%BB%84%E5%AE%9A%E4%B9%89.png"></p><p>这个实现只是在要求使用 RAM 时将一个单一的数组细分为更小的块 。 数组的总大小（堆的总大小）通过 configTOTAL_HEAP_SIZE （定义于 FreeRTOSConfig.h 中）设置 。</p></li><li><p>heap_2实现方法；heap_2也是在数组上分配内存，跟heap_1不一样的地方在于heap_2使用<strong>最佳匹配算法</strong>(best fit)来分配内存，它支持vPortFree，例如有有三块空闲内存5B,25B,100B现在要申请20B的空间，那么就会将25B的空间划分为20B跟5B。但是这样可能就会造成碎片，就算释放掉申请的20B空间，它也不会把原先的5B空间合并成一个，如果5B的空间一直没人用的话，就会成碎片。</p></li><li><p>heap_3实现方法；他直接调用标准C库的malloc函数跟free函数，但是FreeRTOS中会先暂停调度器，再去调用这些函数，实现了线程安全</p></li><li><p>heap_4实现方法；heap_4使用<strong>首次适应算法</strong>(first fit)来分配内存,例如有三块空闲内存5B,100B,25B现在要申请20B的空间，那么它会找到第一个满足20B的内存，这里就是先找到100B，把它分为20B跟80B的空间，当释放掉申请的内存时候，它会把释放的20B的内存跟80B的内存从新合并成一块100B的内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。</p></li><li><p>heap_5实现方法；heap_5分配内存、释放内存的算法跟heap_4是一样的。但是heap_5不局限于管理一个大数组，可以管理很多块内存、分隔的内存。但是必须记录每块内存的地址以及大小，用结构体保存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">* <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapRegion</span></span><br><span class="hljs-class">* &#123;</span><br>*  <span class="hljs-type">uint8_t</span> *pucStartAddress; &lt;&lt; Start address of a block of memory that will be part of the heap.<br>*  <span class="hljs-type">size_t</span> xSizeInBytes;      &lt;&lt; Size of the block of memory.<br>* &#125; HeapRegion_t;<br></code></pre></td></tr></table></figure><p>如果要定义多块内存，就用该结构体数组形式来表示</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c">* HeapRegion_t xHeapRegions[] =<br>* &#123;<br>*  &#123; ( <span class="hljs-type">uint8_t</span> * ) <span class="hljs-number">0x80000000</span>UL, <span class="hljs-number">0x10000</span> &#125;, &lt;&lt; Defines a block of <span class="hljs-number">0x10000</span> bytes starting at address <span class="hljs-number">0x80000000</span><br>*  &#123; ( <span class="hljs-type">uint8_t</span> * ) <span class="hljs-number">0x90000000</span>UL, <span class="hljs-number">0xa0000</span> &#125;, &lt;&lt; Defines a block of <span class="hljs-number">0xa0000</span> bytes starting at address of <span class="hljs-number">0x90000000</span><br>*  &#123; <span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span> &#125;                &lt;&lt; Terminates the <span class="hljs-built_in">array</span>.<br>* &#125;;<br>*<br></code></pre></td></tr></table></figure></li><li><p>在实际使用的时候我们只需要选择其中一个内存管理算法就行。每个算法提供的申请内存的函数都是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> * <span class="hljs-title function_">pvPortMalloc</span><span class="hljs-params">( <span class="hljs-type">size_t</span> xWantedSize )</span><br>&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>释放函数都是</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vPortFree</span><span class="hljs-params">( <span class="hljs-type">void</span> * pv )</span><br>&#123;<br>    .......<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h1 id="3、FreeRTOS源码"><a href="#3、FreeRTOS源码" class="headerlink" title="3、FreeRTOS源码"></a>3、FreeRTOS源码</h1><h2 id="3-1内核的列表"><a href="#3-1内核的列表" class="headerlink" title="3&#x2F;1内核的列表"></a>3&#x2F;1内核的列表</h2><ul><li><p>在FreeRTOS中列表是个很重要的数据结构，实质就是一个双向链表；FreeRTOS中定义了就绪列表、等待列表、挂起列表、延时列表、终止列表。任务切换等操作都是通过查找对应的列表来实现的。在list.h文件内都是有关列表的定义，以及函数的声明。</p></li><li><p>列表项的数据结构定义，及示意图；</p><ul><li><p>普通列表项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE           <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    configLIST_VOLATILE TickType_t xItemValue;          <span class="hljs-comment">/*&lt; The value being listed.  In most cases this is used to sort the list in ascending order. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxNext</span>;</span>     <span class="hljs-comment">/*&lt; Pointer to the next ListItem_t in the list. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxPrevious</span>;</span> <span class="hljs-comment">/*&lt; Pointer to the previous ListItem_t in the list. */</span><br>    <span class="hljs-type">void</span> * pvOwner;                                     <span class="hljs-comment">/*&lt; Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxContainer</span>;</span>     <span class="hljs-comment">/*&lt; Pointer to the list in which this list item is placed (if any). */</span><br>    listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE          <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>&#125;;<br></code></pre></td></tr></table></figure><p><img src="/./../photo/%E5%88%97%E8%A1%A8%E9%A1%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p>迷你列表项</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xMINI_LIST_ITEM</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    configLIST_VOLATILE TickType_t xItemValue;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxNext</span>;</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST_ITEM</span> * <span class="hljs-title">configLIST_VOLATILE</span> <span class="hljs-title">pxPrevious</span>;</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xMINI_LIST_ITEM</span> <span class="hljs-title">MiniListItem_t</span>;</span><br></code></pre></td></tr></table></figure><p><img src="/./../photo/%E8%BF%B7%E4%BD%A0%E5%88%97%E8%A1%A8%E9%A1%B9%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li></ul></li><li><p>列表数据结构定义，及其示意图；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">xLIST</span></span><br><span class="hljs-class">&#123;</span><br>    listFIRST_LIST_INTEGRITY_CHECK_VALUE      <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>    <span class="hljs-keyword">volatile</span> UBaseType_t uxNumberOfItems;<br>    ListItem_t * configLIST_VOLATILE pxIndex; <span class="hljs-comment">/*&lt; Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */</span><br>    MiniListItem_t xListEnd;                  <span class="hljs-comment">/*&lt; List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */</span><br>    listSECOND_LIST_INTEGRITY_CHECK_VALUE     <span class="hljs-comment">/*&lt; Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */</span><br>&#125; List_t;<br></code></pre></td></tr></table></figure><p><img src="/./../photo/%E5%88%97%E8%A1%A8%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p>切记列表里面的迷你列表项，不算做列表中的列表项的个数</p></li><li><p>FreeRTOS列表操作函数</p><table><thead><tr><th align="center">函数</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">void vListInitialise( List_t * const pxList )</td><td align="center">初始化列表头</td></tr><tr><td align="center">void vListInitialiseItem( ListItem_t * const pxItem )</td><td align="center">初始化列表项</td></tr><tr><td align="center">void vListInsert( List_t * const pxList,<br/>                  ListItem_t * const pxNewListItem )</td><td align="center">按照列表项里的列表值进行顺序插入列表</td></tr><tr><td align="center">void vListInsertEnd( List_t * const pxList,<br/>                     ListItem_t * const pxNewListItem )</td><td align="center">列表末端插入，这里特别要注意，这里并不一定是插到xListEnd后面，具体是插在pxIndex指向的列表项前面</td></tr><tr><td align="center">UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )</td><td align="center">删除列表项，返回移除后列表中列表项的多少</td></tr></tbody></table></li></ul><h2 id="3-2任务操作相关函数"><a href="#3-2任务操作相关函数" class="headerlink" title="3&#x2F;2任务操作相关函数"></a>3&#x2F;2任务操作相关函数</h2><ul><li><p>任务创建函数和删除函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*动态创建*/</span><br>BaseType_t <span class="hljs-title function_">xTaskCreate</span><span class="hljs-params">( </span><br><span class="hljs-params"> TaskFunction_t pxTaskCode, <span class="hljs-comment">//任务函数的函数指针</span></span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, <span class="hljs-comment">//任务名字</span></span><br><span class="hljs-params"> <span class="hljs-type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="hljs-comment">//任务堆栈大小</span></span><br><span class="hljs-params"> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters, <span class="hljs-comment">//传递给任务函数的参数</span></span><br><span class="hljs-params"> UBaseType_t uxPriority, <span class="hljs-comment">//任务优先级</span></span><br><span class="hljs-params"> TaskHandle_t * <span class="hljs-type">const</span> pxCreatedTask<span class="hljs-comment">//任务函数的函数句柄，就是任务控制块</span></span><br><span class="hljs-params">)</span>; <br><span class="hljs-comment">/*静态创建*/</span><br>TaskHandle_t <span class="hljs-title function_">xTaskCreateStatic</span><span class="hljs-params">( </span><br><span class="hljs-params"> TaskFunction_t pxTaskCode, </span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">char</span> * <span class="hljs-type">const</span> pcName, </span><br><span class="hljs-params"> <span class="hljs-type">const</span> <span class="hljs-type">uint32_t</span> ulStackDepth, </span><br><span class="hljs-params"> <span class="hljs-type">void</span> * <span class="hljs-type">const</span> pvParameters, </span><br><span class="hljs-params"> UBaseType_t uxPriority, </span><br><span class="hljs-params"> StackType_t * <span class="hljs-type">const</span> puxStackBuffer,<span class="hljs-comment">//任务的栈指针，内存由用户分配</span></span><br><span class="hljs-params"> StaticTask_t * <span class="hljs-type">const</span> pxTaskBuffer<span class="hljs-comment">//任务控制块的指针，内存由用户分配</span></span><br><span class="hljs-params">)</span>; <br><span class="hljs-comment">/*任务删除*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskDelete</span><span class="hljs-params">(TaskHandle_t xTaskToDelete<span class="hljs-comment">//任务的句柄); </span></span><br></code></pre></td></tr></table></figure></li><li><p>任务挂起和恢复</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskSuspend</span><span class="hljs-params">(TaskHandle_t xTaskToSuspend)</span>;<span class="hljs-comment">//挂起任务，会阻塞任务</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">vTaskResume</span><span class="hljs-params">(TaskHandle_t xTaskToResume)</span>;<span class="hljs-comment">//恢复任务</span><br>BaseType_t <span class="hljs-title function_">xTaskResumeFromISR</span><span class="hljs-params">(TaskHandle_t xTaskToResume)</span><span class="hljs-comment">//在中断中要用这个来恢复任务</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="3-3任务间通信"><a href="#3-3任务间通信" class="headerlink" title="3&#x2F;3任务间通信"></a>3&#x2F;3任务间通信</h2><h3 id="3-3-1消息队列和队列集"><a href="#3-3-1消息队列和队列集" class="headerlink" title="3&#x2F;3&#x2F;1消息队列和队列集"></a>3&#x2F;3&#x2F;1消息队列和队列集</h3><ul><li><p>消息队列；是一种先进先出的存储机制，消息队列里面可以存储任何数据类型；但是要求任务在写队列的时候，要严格按照数据类型格式来写。如图所示：</p><p><img src="/./../photo/%E9%98%9F%E5%88%97%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p></li><li><p>队列创建</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//动态创建，返回队列的起始地址</span><br>xQueueCreate(uxQueueLength，uxItemSize)<br></code></pre></td></tr></table></figure></li><li><p>队列读写函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">xQueueSend()<span class="hljs-comment">//尾部写队列</span><br>xQueueSendFromISR()<span class="hljs-comment">//中断中写</span><br>    <br>xQueueReceive()<span class="hljs-comment">//读队列</span><br>xQueueReceiveFromISR() <span class="hljs-comment">//中断中对</span><br></code></pre></td></tr></table></figure></li><li><p>注意，读写队列都可能导致任务阻塞，写的时候队列满，阻塞任务；读的时候队列空，阻塞任务；</p></li><li><p>队列集：队列集就是把存储不同数据类型的队列，管理起来；方便任务读取不同的队列。</p></li><li><p>队列集操作函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs C">xQueueCreateSet()<span class="hljs-comment">//创建队列集</span><br>xQueueAddToSet()<span class="hljs-comment">//添加队列到队列集</span><br>xQueueRemoveFromSet()<span class="hljs-comment">//移除队列</span><br>xQueueSelectFromSet()<span class="hljs-comment">//获取队列集中有效消息的队列</span><br>xQueueSelectFromSetFromISR()<span class="hljs-comment">//在中断中获取队列集中的有效队列消息</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="3-3-2信号量"><a href="#3-3-2信号量" class="headerlink" title="3&#x2F;3&#x2F;2信号量"></a>3&#x2F;3&#x2F;2信号量</h3><ul><li><p>任务同步与互斥；任务同步就是一个任务要等待另一个任务操作完，才能进行下一步操作；互斥就是，两个任务在同一时间只能对某一个临界区资源进行操作；所以同步与互斥是成对出现的。</p></li><li><p>二值信号量：实质是一个队列项只有一个的队列，所以队列要么空和要么满；来解决任务间同步与互斥的问题。</p></li><li><p>计数型信号量：实质是一个多项的队列，但是这个队列，并不传递数据。仅仅是来表示可用资源数有多少；</p></li><li><p>互斥信号量：在二值信号量的基础上，加了优先级继承的机制，让获得信号量的任务优先级暂时提高，防止中等优先级任务打断，导致最高优先级任务一直阻塞。切记，不能用到中断，因为中断不是任务，没有优先级。并且中断中不能等待互斥量而被阻塞。</p></li></ul><h3 id="3-3-3空闲任务"><a href="#3-3-3空闲任务" class="headerlink" title="3&#x2F;3&#x2F;3空闲任务"></a>3&#x2F;3&#x2F;3空闲任务</h3><ul><li>在启动任务调度器的时候，内核默认创建了一个优先级最低的任务，就是空闲任务，这个任务主要在没有其他用户任务运行时，才会执行。主要作用是内存清理，以及统计任务。里面有个钩子函数，主要设置处理进入低功耗模式，这里是设置处理器；freertos有自带的低功耗区分一下。</li></ul>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式常见协议总结</title>
    <link href="/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/30/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B8%B8%E8%A7%81%E5%8D%8F%E8%AE%AE%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1、UART串口通信"><a href="#1、UART串口通信" class="headerlink" title="1、UART串口通信"></a>1、UART串口通信</h1><h2 id="1-1简介"><a href="#1-1简介" class="headerlink" title="1.1简介"></a>1.1简介</h2><ul><li><p>通用异步收发器 <strong>UART</strong>（Universal AsynchronousReceiver&#x2F;Transmitter)，是一种串行、异步、全双工的通信协议。高电平代表’1‘，低电平代表’0‘。特别注意固定格式位，起始位以0为通信起步，停止位以1作为结束位。</p></li><li><p>整体结构如图：</p><p><img src="/./../photo/%E7%BB%93%E6%9E%84%E7%AE%80%E5%9B%BE.png"></p></li></ul><h2 id="1-2参数配置"><a href="#1-2参数配置" class="headerlink" title="1.2参数配置"></a>1.2参数配置</h2><ul><li><p>数据传输格式</p><p><img src="/./../photo/UART%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F.png" alt="数据格式"></p><ul><li>起始位总是以低电平有效，停止位以高电平有效。</li><li>数据位：数据位可以是5、6、7、8，9位等，构成一个字符（一般都是8位）。如ASCII码（7位），扩展BCD码（8位）。先发送<strong>最低位</strong>，最后发送<strong>最高位</strong>，使用低电平表示‘0’高电平表示‘1’完成数据位的传输。</li><li>奇偶检验位：数据位加上这一位后，使得“1”的位数应为偶数(偶校验)或奇数(奇校验)，以此来校验数据传送的正确性。</li></ul></li><li><p>波特率</p><ul><li>数据传输的速率用波特率来表示。通俗讲就是让通信双方知道什么时间点来采样数据。例如:通信波特率是115200bps，即代表1秒可以传输115200位的数据。</li></ul></li></ul><h2 id="1-3示例"><a href="#1-3示例" class="headerlink" title="1.3示例"></a>1.3示例</h2><ul><li><p>在stm32中如何使用串口，来实现printf函数与PC串口助手进行通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">//值得的注意点：printf函数最终调用的是fputc(int ch, FILE *f)来输出字符串的，但是这个函数在stdio.h文件里面仅仅是定义了但是没有实现，所以必须重定义这个函数。</span><br>    <span class="hljs-comment">/*以下示例均以UART1来作为示例*/</span><br>    <span class="hljs-comment">/*HAL库函数版本实现串口的中断接收和发送*/</span><br>    <span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">    &#123;</span><br>        __IO <span class="hljs-type">uint32_t</span> SR;         <span class="hljs-comment">/*!&lt; USART Status register,                   Address offset: 0x00 */</span><br>        __IO <span class="hljs-type">uint32_t</span> DR;         <span class="hljs-comment">/*!&lt; USART Data register,                     Address offset: 0x04 */</span><br>        __IO <span class="hljs-type">uint32_t</span> BRR;        <span class="hljs-comment">/*!&lt; USART Baud rate register,                Address offset: 0x08 */</span><br>        __IO <span class="hljs-type">uint32_t</span> CR1;        <span class="hljs-comment">/*!&lt; USART Control register 1,                Address offset: 0x0C */</span><br>        __IO <span class="hljs-type">uint32_t</span> CR2;        <span class="hljs-comment">/*!&lt; USART Control register 2,                Address offset: 0x10 */</span><br>        __IO <span class="hljs-type">uint32_t</span> CR3;        <span class="hljs-comment">/*!&lt; USART Control register 3,                Address offset: 0x14 */</span><br>        __IO <span class="hljs-type">uint32_t</span> GTPR;       <span class="hljs-comment">/*!&lt; USART Guard time and prescaler register, Address offset: 0x18 */</span><br>    &#125; USART_TypeDef;<span class="hljs-comment">//这是底层寄存器封装</span><br>    <br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> PERIPH_BASE           0x40000000UL</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> APB2PERIPH_BASE       (PERIPH_BASE + 0x00010000UL)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> USART1_BASE           (APB2PERIPH_BASE + 0x00003800UL)</span><br>    <span class="hljs-meta">#<span class="hljs-keyword">define</span> USART1              ((USART_TypeDef *)USART1_BASE)</span><br>    <br>    <span class="hljs-comment">/*重定义fputc(int ch, FILE *f)*/</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">fputc</span><span class="hljs-params">(<span class="hljs-type">int</span> ch, FILE *f)</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> ((USART1-&gt;SR &amp; <span class="hljs-number">0X40</span>) == <span class="hljs-number">0</span>);     <span class="hljs-comment">/* 等待上一个字符发送完成 */</span><br>        USART_UX-&gt;DR = (<span class="hljs-type">uint8_t</span>)ch;           <span class="hljs-comment">/* 将要发送的字符 ch 写入到DR寄存器 */</span><br>        <span class="hljs-keyword">return</span> ch;<br>    &#125;<br>    <span class="hljs-comment">/*初始化串口1,省略大部分代码，保留核心函数*/</span><br>    UART_HandleTypeDef g_uart1_handle;  <span class="hljs-comment">/* UART句柄 */</span><br>    HAL_UART_Init(&amp;g_uart1_handle)内部调用--&gt;HAL_UART_MspInit(&amp;g_uart1_handle)--&gt; HAL_GPIO_Init()函数来配置相关引脚的复用输入输出--&gt;HAL_NVIC_EnableIRQ()使能串口中断--&gt;HAL_NVIC_SetPriority()设置中断优先级<br>    <br>        HAL_UART_Receive_IT(&amp;g_uart1_handle, (<span class="hljs-type">uint8_t</span> *)g_rx_buffer, RXBUFFERSIZE)开启串口接收中断天<br>    <br>        USART1_IRQHandler()串口<span class="hljs-number">1</span>中断服务函数--&gt;HAL_UART_IRQHandler()HAL串口中断公共服务函--&gt;HAL_UART_RxCpltCallback()中断接收回调函数 <br></code></pre></td></tr></table></figure></li></ul><h1 id="2、集成电路总线-IIC"><a href="#2、集成电路总线-IIC" class="headerlink" title="2、集成电路总线(IIC)"></a>2、集成电路总线(IIC)</h1><h2 id="2-1简介"><a href="#2-1简介" class="headerlink" title="2.1简介"></a>2.1简介</h2><ul><li>IIC使用两根信号线进行通信：一根时钟线SCL，一根数据线SDA。IIC将SCL处于高时SDA拉低的动作作为开始信号，SCL处于高时SDA拉高的动作作为结束信号；传输数据时，SDA在SCL低电平时改变数据，在SCL高电平时保持数据，每个SCL脉冲的高电平传递1位数据。IIC是半双工同步通信协议</li></ul><h2 id="2-2总线特性与硬件结构"><a href="#2-2总线特性与硬件结构" class="headerlink" title="2.2总线特性与硬件结构"></a>2.2总线特性与硬件结构</h2><ul><li><p>IIC总线上所有器件的SDA、SCL引脚输出驱动都为 <strong>开漏(OD)</strong> 结构，通过外接上拉电阻实现总线上所有节点SDA、SCL信号的<strong>线与</strong>逻辑关系；</p></li><li><p>总线上的所有设备通过软件寻址且具有唯一的地址（7位或10位）。7位“从机专用地址码”，其高4位为由生产厂家制定的<strong>设备类型地址</strong>，低3位为器件引脚定义地址（由使用者定义）；10位地址不常见；</p></li><li><p>支持多主机。在总线上存在多个主机时，通过冲突检测和仲裁机制防止多个主机同时发起数据传输时存在的冲突；</p></li><li><p>通信模式</p><ul><li><table><thead><tr><th align="center">模式</th><th align="center">速度</th></tr></thead><tbody><tr><td align="center">标准模式（Standard Mode）</td><td align="center">100kb&#x2F;s</td></tr><tr><td align="center">快速模式（Fast Mode）</td><td align="center">400kb&#x2F;s</td></tr><tr><td align="center">增强快速模式（Fast Mode Plus）</td><td align="center">1Mb&#x2F;s</td></tr><tr><td align="center">高速模式（High Speed Mode）</td><td align="center">3.4Mb&#x2F;s</td></tr><tr><td align="center">极速模式（Ultra-FastMode）</td><td align="center">5Mb&#x2F;s</td></tr></tbody></table></li></ul></li><li><p>硬件结构</p><ul><li>IIC使用两根信号线进行通信，要求两根线都使用 <strong>开漏输出接上拉电阻</strong> 的配置，以此实现总线上所有节点SDA、SCL信号的 <strong>线与</strong> 逻辑关系。</li><li><img src="/./../photo/IIC%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E4%BD%93%E5%9B%BE.png" alt="结构图"></li><li>IIC允许一对多通信，但是同一时间只能有一个丛机跟主机通信</li></ul></li></ul><h2 id="2-3工作时序"><a href="#2-3工作时序" class="headerlink" title="2.3工作时序"></a>2.3工作时序</h2><ul><li><strong>数据有效性以及采集过程</strong><ul><li>IIC 的数据读取动作都在 <strong>SCL为高</strong> 时产生，<strong>SCL为低</strong>时是数据改变的时期，无论SDA如何变化都不影响读取。所以，传输数据的过程中，当SCL为高时，数据应当保持稳定，避免数据的采集出错。</li></ul></li><li><strong>开始和结束信号</strong><ul><li><strong>开始信号：</strong>SCL为高时，SDA从高到低的跳变产生开始信号</li><li><strong>结束信号：</strong>SCL为高时，SDA从低到高的跳变产生结束信号</li></ul></li><li><strong>重复开始信号（ReSTART&#x2F;Sr）：</strong> 在结束时不给出STOP信号，而以一个时钟周期内再次给出开始信号作为替代</li><li><strong>字节格式：</strong>SDA数据线上的每个字节<strong>必须是8位</strong>，对于每次传输的<strong>字节数没有限制</strong>。每个字节（8位）数据传送完后紧跟着应答信号（ACK，第9位）。数据的先后顺序为：<strong>高位在前</strong> 。</li><li><strong>应答信号（ACK）：</strong>协议规定数据传输过程必须包含应答（ACK）。接收器通过应答告知发送的字节已被成功接收，之后发送器可以进行下一个字节的传输。<strong>主机产生数据传输过程中的所有时钟，包括用于应答的第9个时钟。发送器在应答时钟周期内释放对SDA总线的控制，</strong>这样接收器可以通过将SDA线拉低告知发送器：数据已被成功接收。（<strong>特别注意，ACK信号是主机发送完数据后，必须必须释放SDA总线后，丛机来控制SDA总线发出的信号</strong>）<ul><li>应答信号分为两种：<ul><li>当第9位(应答位)为 <strong>低电平</strong> 时，为 <strong>ACK</strong> 信号</li><li>当第9位(应答位)为 <strong>高电平</strong> 时，为 <strong>NACK</strong>信号</li></ul></li></ul></li></ul><h2 id="2-4地址设备为7位的通信过程"><a href="#2-4地址设备为7位的通信过程" class="headerlink" title="2.4地址设备为7位的通信过程"></a>2.4地址设备为7位的通信过程</h2><ul><li>完整通信示意图：<ul><li><img src="/./../photo/7bit%E8%AE%BE%E5%A4%87%E5%9C%B0%E5%9D%80%E9%80%9A%E4%BF%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="示意图"></li><li><strong>START信号后，第一个字节包含设备7位地址以及1位读写位，读写位表示主机将要对丛机进行的操作。发送完这个字节之后，主机释放SDA总线等待从机给出ACK应答。如果从机给出了ACK应答，表示从机地址正确（有从机响应）并且已知晓是读还是写，便可以开始读写数据。如果从机没有给出ACK应答，则说明接收设备可能没有收到数据（如寻址的设备不存在或是设备正在忙碌）或无法解析收到的数据，如果是这样，则由主机来决定如何处理（STOP或ReSTART）。</strong><ul><li>情况一：主机写，丛机收，传输过程传输方向不变<ul><li><img src="/./../photo/%E4%B8%BB%E5%8F%91%E4%B8%9B%E6%94%B6.png" alt="示意图"></li></ul></li><li>情况二：主机收，丛机发送，传输过程传输方向改变<ul><li><img src="/./../photo/%E4%B8%BB%E6%94%B6%E4%B8%9B%E5%8F%91.png" alt="示意图"></li></ul></li></ul></li></ul></li></ul><h2 id="2-4实例操作"><a href="#2-4实例操作" class="headerlink" title="2.4实例操作"></a>2.4实例操作</h2><ul><li><p>情况一：用GPIO来模拟IIC通信过程</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*以F103为例子，SCL--&gt;PB6,SDA--&gt;PB7，精简代码，不是所有都列出来*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCL(x)do&#123;x? HAL_GPIO_WritePin(GPIOB,GPIO_PIN6,GPIO_PIN_SET):</span><br> \HAL_GPIO_WritePin(GPIOB,GPIO_PIN6,GPIO_PIN_RESET);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SDA(x)do&#123;x? HAL_GPIO_WritePin(GPIOB,GPIO_PIN7,GPIO_PIN_SET):</span><br> \HAL_GPIO_WritePin(GPIOB,GPIO_PIN7,GPIO_PIN_RESET);&#125;<span class="hljs-keyword">while</span>(<span class="hljs-number">0</span>)<br><span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//初始化函数</span><br>&#123;<br>    GPIO_InitTypeDef gpio_init_struct;<br>    <br><span class="hljs-comment">/*首先是初始化这两个IO口，SCL配置为推挽输出，SDA配置为开漏输出（这样保证无论在哪种通信下，都不需要去切换IO口的     方向，因为开漏输出也可以读取IO的电平）*/</span><br>    <br>    ...配置省略<br>        <br>HAL_GPIO_Init(GPIOB, &amp;gpio_init_struct);<br>stop();<span class="hljs-comment">//初始化后先停止</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//起始信号</span><br>&#123;<br>    <span class="hljs-comment">/*SCL为高时，SDA从高到低的跳变产生开始信号*/</span><br>    SDA(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SDA(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    <br>    SCL(<span class="hljs-number">0</span>);<span class="hljs-comment">//这个操作是钳住IIC总线，准备接受或者发送数据</span><br>    delay_us(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//停止信号</span><br>&#123;<br>    <span class="hljs-comment">/*SCL为高时，SDA从低到高的跳变产生结束信号*/</span><br>    SDA(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SDA(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">master_ack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//主机应答信号</span><br>&#123;<br>    SDA(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    <br>    SDA(<span class="hljs-number">1</span>);<span class="hljs-comment">//释放总线</span><br>    delay_us(<span class="hljs-number">2</span>);      <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">master_nack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//主机不应答信号</span><br>&#123;<br>    SDA(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);     <br>&#125;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">slave_ack</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> timeout;<br>    <span class="hljs-type">uint8_t</span> res=<span class="hljs-number">0</span>;<br>    SDA(<span class="hljs-number">1</span>);<span class="hljs-comment">//主机释放总线，此时丛机可以操作SDA线</span><br>    delay_us(<span class="hljs-number">2</span>);<br>    SCL(<span class="hljs-number">1</span>);<span class="hljs-comment">//拉高时钟线，可以传输数据了</span><br>    delay_us(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">while</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_7))<span class="hljs-comment">//等待SDA线的电平被从机拉低</span><br>    &#123;<br>        timeout++;<br>        <span class="hljs-keyword">if</span>(timeout&gt;<span class="hljs-number">250</span>)<br>        &#123;<br>            stop();<span class="hljs-comment">//超时</span><br>            res=<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    SCL(<span class="hljs-number">0</span>);<br>    delay_us(<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">iic_send</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> data)</span><span class="hljs-comment">//发送8位数据</span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>    &#123;<br>        SDA((data&amp;<span class="hljs-number">0x80</span>)&gt;&gt;<span class="hljs-number">7</span>);<span class="hljs-comment">//因为IIC是先传输最高位的</span><br>        delay_us(<span class="hljs-number">2</span>);<br>        SCL(<span class="hljs-number">1</span>);<br>        delay_us(<span class="hljs-number">2</span>);<br>        SCL(<span class="hljs-number">0</span>);<br>        delay_us(<span class="hljs-number">2</span>);<br>        data&lt;&lt;=<span class="hljs-number">1</span>;<br>    &#125;<br>    SDA(<span class="hljs-number">1</span>);<span class="hljs-comment">//释放总线</span><br>&#125;<br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">iic_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> ack)</span><span class="hljs-comment">//读取8位数据   </span><br>&#123;<br>    <span class="hljs-type">uint8_t</span> res;<br>    <span class="hljs-type">uint8_t</span> i;<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">8</span>;i++)<br>    &#123;<br>        res&lt;&lt;=<span class="hljs-number">1</span>;<br>        SCL(<span class="hljs-number">1</span>);<br>        delay_us(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">if</span>(HAL_GPIO_ReadPin(GPIOB,GPIO_PIN_7)<br>           &#123;<br>               res++;<br>           &#125;<br>        SCL(<span class="hljs-number">0</span>);<br>  delay_us(<span class="hljs-number">2</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!ack)<br>    &#123;<br>         master_nack();      <br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>         master_ack();       <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;       <br>&#125; <br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p>情况二：硬件IIC，用HAL库函数实现（F1系列HAL库硬件IIC可能会有BUG）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/////////////////////////</span><br>I2C_HandleTypeDef handle_iic<br>    <span class="hljs-type">void</span> <span class="hljs-title function_">iic_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><span class="hljs-comment">//硬件IIC初始化函数</span><br>&#123;<br>    <span class="hljs-comment">/*具体句柄配置省略，设置i2c速度、模式、丛机地址位数等等*/</span><br>    ...省略代码<br>        HAL_I2C_Iint(&amp;handle_iic);<span class="hljs-comment">/*这是IIC的初始化，还需要对应GPIO的初始化，这个函数内部会调用HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)这个函数*/</span><br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_I2C_MspInit</span><span class="hljs-params">(I2C_HandleTypeDef* hi2c)</span><br>&#123;<br>    GPIO_InitTypeDef GPIO_InitStruct = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">if</span>(hi2c-&gt;I2C1)<br>    &#123;<br>        ...具体GPIO配置省略<br>        HAL_GPIO_Init();<br>        __HAL_RCC_I2C1_CLK_ENABLE();<br>        HAL_NVIC_SetPriority(I2C1_EV_IRQn, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        HAL_NVIC_EnableIRQ(I2C1_EV_IRQn);<br>        HAL_NVIC_SetPriority(I2C1_ER_IRQn, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        HAL_NVIC_EnableIRQ(I2C1_ER_IRQn);<br>    &#125;<br>&#125;<br><span class="hljs-comment">/*HAL库提供三种类型读写函（阻塞、非阻塞（其中包括中断和DMA））*/</span><br><span class="hljs-comment">//阻塞IIC发送、接受代码原型</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Transmit</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Receive</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_IsDeviceReady</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint32_t</span> Trials, <span class="hljs-type">uint32_t</span> Timeout)</span>;<br><br><span class="hljs-comment">//非阻塞普通中断IIC发送、接受代码原型</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Transmit_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Receive_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read_IT</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br><br><span class="hljs-comment">//非阻塞DMA中断IIC发送、接受代码原型</span><br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Transmit_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Master_Receive_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Write_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>HAL_StatusTypeDef <span class="hljs-title function_">HAL_I2C_Mem_Read_DMA</span><span class="hljs-params">(I2C_HandleTypeDef *hi2c, <span class="hljs-type">uint16_t</span> DevAddress, <span class="hljs-type">uint16_t</span> MemAddress, <span class="hljs-type">uint16_t</span> MemAddSize, <span class="hljs-type">uint8_t</span> *pData, <span class="hljs-type">uint16_t</span> Size)</span>;<br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p><strong>通过硬件IIC读取AT24C02代码</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><br><span class="hljs-comment">//AT24Cxx这是一个IIC接口的EEPROM存储芯片</span><br><span class="hljs-comment">//读写地址</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Write 0xA0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Read  0xA1</span><br><span class="hljs-comment">//三次写入的字符串</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str1[]=&#123;<span class="hljs-string">&quot;xyz666&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str2[]=&#123;<span class="hljs-string">&quot;1234567&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str3[]=&#123;<span class="hljs-string">&quot;abcdefg&quot;</span>&#125;;<br><span class="hljs-comment">//读取缓存区</span><br><span class="hljs-type">uint8_t</span> ReadBuffer[<span class="hljs-number">50</span>];<br><span class="hljs-comment">/* USER CODE END PV */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//阻塞方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str1,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>)==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>);<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_IT(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str2,<span class="hljs-keyword">sizeof</span>(str2))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_IT(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//DMA中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_DMA(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str3,<span class="hljs-keyword">sizeof</span>(str3))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_DMA(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li></ul><h1 id="3、串行外设接口（SPI）"><a href="#3、串行外设接口（SPI）" class="headerlink" title="3、串行外设接口（SPI）"></a>3、串行外设接口（SPI）</h1><h2 id="3-1简介"><a href="#3-1简介" class="headerlink" title="3.1简介"></a>3.1简介</h2><ul><li>SPI，是一<strong>种高速的，全双工，同步</strong>的通信总线，并且在芯片的管脚上只占用四根线。SPI分为主、从两种模式，一个SPI通讯系统需要包含一个（且只能是一个）主设备，一个或多个从设备。提供时钟的为主设备（Master），接收时钟的设备为从设备（Slave），SPI接口的读写操作，都是由主设备发起。当存在多个从设备时，通过各自的片选信号进行管理。</li><li>4线SPI示意图<ul><li><img src="/./../photo/4%E7%BA%BFSPI%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="示意图"></li><li><strong>MISO</strong>： <strong>主设备输入&#x2F;从设备输出引脚</strong>。该引脚在从模式下发送数据，在主模式下接收数据。</li><li><strong>MOSI</strong>： <strong>主设备输出&#x2F;从设备输入引脚</strong>。该引脚在主模式下发送数据，在从模式下接收数据。</li><li><strong>SCLK</strong>：<strong>串行时钟信号</strong>，由主设备产生。</li><li><strong>CS&#x2F;SS</strong>：<strong>从设备片选信号</strong>，由主设备控制。它的功能是用来作为“片选引脚”，也<strong>就是选择指定的从设备</strong>，让主设备可以单独地与特定从设备通讯，避免数据线上的冲突。</li></ul></li><li>SPI工作原理<ul><li>在主机和从机都有一个串行移位寄存器，主机通过向它的 SPI 串行寄存 器写入一个字节来发起一次传输。串行移位寄存器通过 MOSI 信号线将字节传送给从机，从机 也将自己的串行移位寄存器中的内容通过 MISO 信号线返回给主机。这样，两个移位寄存器中 的内容就被交换。外设的写操作和读操作是同步完成的。<strong>如果只是进行写操作，主机只需忽略 接收到的字节。反之，若主机要读取从机的一个字节，就必须发送一个空字节引发从机传输。</strong></li></ul></li><li>SPI传输方式<ul><li><strong>SPI总共有三种传输方式：全双工、单工以及半双工传输方式。</strong></li></ul></li></ul><h2 id="3-2工作时序"><a href="#3-2工作时序" class="headerlink" title="3.2工作时序"></a>3.2工作时序</h2><ul><li><p>SPI四种不同工作模式由CPOL(时钟极性)和CPHA（时钟相位）来控制</p><ul><li><table><thead><tr><th align="center">SPI工作模式</th><th align="center">CPOL</th><th align="center">CPHA</th><th align="center">SCL空闲状态</th><th align="center">采样边沿</th><th align="center">采样时刻</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">低电平</td><td align="center">上升沿</td><td align="center">奇数边沿</td></tr><tr><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">低电平</td><td align="center">下降沿</td><td align="center">偶数边沿</td></tr><tr><td align="center">2</td><td align="center">1</td><td align="center">0</td><td align="center">高电平</td><td align="center">下降沿</td><td align="center">奇数边沿</td></tr><tr><td align="center">3</td><td align="center">1</td><td align="center">1</td><td align="center">高电平</td><td align="center">上升沿</td><td align="center">偶数边沿</td></tr></tbody></table></li><li><p>以CPOL&#x3D;0,CPHA&#x3D;0为示例时序图，其他同理</p><ul><li><img src="/./../photo/SPI%E6%97%B6%E5%BA%8F%E5%9B%BE.png" alt="时序图"></li><li>由图可以看出来，在传输开始前以及传输完成后，CPOL即SCL都为低电平，表示空闲的时候SCL为低电平状态，由于采样边沿是上升沿，即在第1、3、5、7…..等这些边沿进行采样。</li></ul></li></ul></li></ul><h2 id="3-3实例操作"><a href="#3-3实例操作" class="headerlink" title="3.3实例操作"></a>3.3实例操作</h2><ul><li><p><strong>基于stm32的HAL库配置SPI</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* USER CODE BEGIN PV */</span><br><span class="hljs-comment">//AT24Cxx这是一个IIC接口的EEPROM存储芯片</span><br><span class="hljs-comment">//读写地址</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Write 0xA0</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> AT24C02_Read  0xA1</span><br><span class="hljs-comment">//三次写入的字符串</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str1[]=&#123;<span class="hljs-string">&quot;xyz666&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str2[]=&#123;<span class="hljs-string">&quot;1234567&quot;</span>&#125;;<br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> str3[]=&#123;<span class="hljs-string">&quot;abcdefg&quot;</span>&#125;;<br><span class="hljs-comment">//读取缓存区</span><br><span class="hljs-type">uint8_t</span> ReadBuffer[<span class="hljs-number">50</span>];<br><span class="hljs-comment">/* USER CODE END PV */</span><br>  <span class="hljs-comment">/* USER CODE BEGIN 2 */</span><br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;Init Ok!\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">100</span>);<br><span class="hljs-comment">//阻塞方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str1,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>)==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR1_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1),<span class="hljs-number">1000</span>);<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str1));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_IT(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str2,<span class="hljs-keyword">sizeof</span>(str2))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR2_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_IT(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str2));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br><span class="hljs-comment">//DMA中断方式写入读取</span><br><span class="hljs-keyword">if</span>(HAL_I2C_Mem_Write_DMA(&amp;hi2c1,AT24C02_Write,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,str3,<span class="hljs-keyword">sizeof</span>(str3))==HAL_OK)<br>HAL_UART_Transmit_IT(&amp;huart1,<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>,<span class="hljs-keyword">sizeof</span>(<span class="hljs-string">&quot;STR3_Write_OK\r\n&quot;</span>));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_I2C_Mem_Read_DMA(&amp;hi2c1,AT24C02_Read,<span class="hljs-number">0</span>,I2C_MEMADD_SIZE_8BIT,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>HAL_UART_Transmit_IT(&amp;huart1,ReadBuffer,<span class="hljs-keyword">sizeof</span>(str3));<br>HAL_Delay(<span class="hljs-number">1000</span>);<br>  <span class="hljs-comment">/* USER CODE END 2 */</span><br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p><strong>SPI-&gt;norflash存储芯片的读写</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*仅仅介绍几个函数，具体的请参考完整代码*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_init</span><span class="hljs-params">()</span><br>&#123;<br>    GPIO_InitTypeDef gpio_init_struct;<span class="hljs-comment">//主要为了配置片选引脚</span><br>    ...配置代码省略<br>    HAL_GPIO_Init(GPIOX,&amp;gpio_init_struct)<br>    spi_init();<br>    spi_set_speed(SPI_SPEED_2);<span class="hljs-comment">//这个设置SPI速度的</span><br>    <span class="hljs-comment">/*有些flash芯片需要开启4字节地址模式*/</span>   <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_send_address</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> address)</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (g_norflash_type == W25Q256) <span class="hljs-comment">/*  只有W25Q256支持4字节地址模式 */</span><br>    &#123;<br>        spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)((address)&gt;&gt;<span class="hljs-number">24</span>)); <span class="hljs-comment">/* 发送 bit31 ~ bit24 地址 */</span><br>    &#125; <br>    spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)((address)&gt;&gt;<span class="hljs-number">16</span>));     <span class="hljs-comment">/* 发送 bit23 ~ bit16 地址 */</span><br>    spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)((address)&gt;&gt;<span class="hljs-number">8</span>));      <span class="hljs-comment">/* 发送 bit15 ~ bit8  地址 */</span><br>    spi2_read_write_byte((<span class="hljs-type">uint8_t</span>)address);             <span class="hljs-comment">/* 发送 bit7  ~ bit0  地址 */</span><br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_read</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pbuf, <span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint16_t</span> datalen)</span><br>&#123;<br>    <span class="hljs-type">uint16_t</span> i;<br><br>    HAL_GPIO_WritePin(GPIOX,GPIO_PIN,GPIO_PIN_RESET);<span class="hljs-comment">//拉低片选选中芯片</span><br>    spi2_read_write_byte(FLASH_ReadData);       <span class="hljs-comment">/* 发送读取命令 */</span><br>    norflash_send_address(addr);                <span class="hljs-comment">/* 发送地址 */</span><br>    <br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;datalen;i++)<br>    &#123;<br>        pbuf[i] = spi2_read_write_byte(<span class="hljs-number">0XFF</span>);   <span class="hljs-comment">/* 循环读取 */</span><br>    &#125;<br>    <br>    HAL_GPIO_WritePin(GPIOX,GPIO_PIN,GPIO_PIN_SET);<br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">norflash_write</span><span class="hljs-params">(<span class="hljs-type">uint8_t</span> *pbuf, <span class="hljs-type">uint32_t</span> addr, <span class="hljs-type">uint16_t</span> datalen)</span><br>&#123;<br>    <span class="hljs-type">uint32_t</span> secpos;<br>    <span class="hljs-type">uint16_t</span> secoff;<br>    <span class="hljs-type">uint16_t</span> secremain;<br>    <span class="hljs-type">uint16_t</span> i;<br>    <span class="hljs-type">uint8_t</span> *norflash_buf;<br><br>    norflash_buf = g_norflash_buf;<br>    secpos = addr / <span class="hljs-number">4096</span>;       <span class="hljs-comment">/* 扇区地址 */</span><br>    secoff = addr % <span class="hljs-number">4096</span>;       <span class="hljs-comment">/* 在扇区内的偏移 */</span><br>    secremain = <span class="hljs-number">4096</span> - secoff;  <span class="hljs-comment">/* 扇区剩余空间大小 */</span><br>    <span class="hljs-keyword">if</span> (datalen &lt;= secremain)<br>    &#123;<br>        secremain = datalen;    <span class="hljs-comment">/* 不大于4096个字节 */</span><br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>    &#123;<br>        norflash_read(norflash_buf, secpos * <span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>);   <span class="hljs-comment">/* 读出整个扇区的内容 */</span><br><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; secremain; i++)   <span class="hljs-comment">/* 校验数据 */</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (norflash_buf[secoff + i] != <span class="hljs-number">0XFF</span>)<br>            &#123;<br>                <span class="hljs-keyword">break</span>;      <span class="hljs-comment">/* 需要擦除, 直接退出for循环 */</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (i &lt; secremain)   <span class="hljs-comment">/* 需要擦除 */</span><br>        &#123;<br>            norflash_erase_sector(secpos);  <span class="hljs-comment">/* 擦除这个扇区 */</span><br><br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; secremain; i++)   <span class="hljs-comment">/* 复制 */</span><br>            &#123;<br>                norflash_buf[i + secoff] = pbuf[i];<br>            &#125;<br><br>            norflash_write_nocheck(norflash_buf, secpos * <span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>);  <span class="hljs-comment">/* 写入整个扇区 */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">/* 写已经擦除了的,直接写入扇区剩余区间. */</span><br>        &#123;<br>            norflash_write_nocheck(pbuf, addr, secremain);  <span class="hljs-comment">/* 直接写扇区 */</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (datalen == secremain)<br>        &#123;<br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">/* 写入结束了 */</span><br>        &#125;<br>        <span class="hljs-keyword">else</span>        <span class="hljs-comment">/* 写入未结束 */</span><br>        &#123;<br>            secpos++;               <span class="hljs-comment">/* 扇区地址增1 */</span><br>            secoff = <span class="hljs-number">0</span>;             <span class="hljs-comment">/* 偏移位置为0 */</span><br><br>            pbuf += secremain;      <span class="hljs-comment">/* 指针偏移 */</span><br>            addr += secremain;      <span class="hljs-comment">/* 写地址偏移 */</span><br>            datalen -= secremain;   <span class="hljs-comment">/* 字节数递减 */</span><br><br>            <span class="hljs-keyword">if</span> (datalen &gt; <span class="hljs-number">4096</span>)<br>            &#123;<br>                secremain = <span class="hljs-number">4096</span>;   <span class="hljs-comment">/* 下一个扇区还是写不完 */</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                secremain = datalen;<span class="hljs-comment">/* 下一个扇区可以写完了 */</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li><li><p><strong>扩展</strong></p><ul><li>SPI不仅仅只有4线的，还有6线的。多出来两根数据线，这样可以一个时钟周期传输两个字节</li></ul></li></ul><h1 id="4、控制局域网总线（CAN）"><a href="#4、控制局域网总线（CAN）" class="headerlink" title="4、控制局域网总线（CAN）"></a>4、控制局域网总线（CAN）</h1><h2 id="4-1简介"><a href="#4-1简介" class="headerlink" title="4.1简介"></a>4.1简介</h2><ul><li>控制器局域网总线（CAN，Controller Area Network）是一种用于实时应用的串行通讯协议总线，它可以使用双绞线来传输信号，是世界上应用最广泛的现场总线之一。CAN协议用于汽车中各种不同元件之间的通信，以此取代昂贵而笨重的配电线束。该协议的健壮性使其用途延伸到其他自动化和工业应用。CAN协议的特性包括完整性的串行数据通讯、提供实时支持、传输速率高达1Mb&#x2F;s、同时具有11位的寻址以及检错能力。</li></ul><h2 id="4-2CAN总线结构"><a href="#4-2CAN总线结构" class="headerlink" title="4.2CAN总线结构"></a>4.2CAN总线结构</h2><ul><li><strong>闭环总线结构</strong>：如图所示，总线两端各连接一个120欧的电阻，两根信号线形成回路。这种CAN总线网络由ISO 11898标准定义，是高速、短距离的CAN网络，通信速率为125kbit&#x2F;s到1Mbit&#x2F;s。在1Mbit&#x2F;s通讯速率时，总线长度最长达40m。<ul><li><img src="/./../photo/%E9%97%AD%E7%8E%AFCAN%E7%BB%93%E6%9E%84.png" alt="总线结构图"></li></ul></li><li><strong>开环总线结构</strong>：两根信号线独立，各自串联一个2.2k欧的电阻。这种CAN总线网络由ISO11519-2标准定义，是低速、远距离的CAN网络，通信速率最高125kbit&#x2F;s。在40kbit&#x2F;s速率时，总线最长距离可达1000m。<ul><li><img src="/./../photo/%E5%BC%80%E7%8E%AF%E6%80%BB%E7%BA%BF%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="示意图"></li></ul></li><li><strong>CAN总线特性</strong>：CAN总线由两根信号线，CANH和CANL，没有时钟同步信号。所以CAN是一种异步通信方式。两根信号线的电压差CANH-CANL表示CAN总线的电平，与传输的逻辑信号1或0对应。对应于逻辑1的称为隐性（Recessive）电平，对应于逻辑0成为显性（Dominant）电平。<ul><li><img src="/./../photo/%E9%80%BB%E8%BE%91%E7%94%B5%E5%B9%B3%E4%BF%A1%E5%8F%B7.png" alt="示意图"></li><li>在开环跟闭环的结构里面，隐形电平和显型电平对应的电压值略有不同</li><li>隐性电平表示逻辑1</li><li>显性电平表示逻辑0</li></ul></li><li><strong>CAN总线特点</strong>:<ul><li><strong>实时性：</strong> CAN总线具有优越的实时性能，适用于需要及时传输数据的应用，如汽车控制系统、工业自动化等。仲裁机制和帧优先级的设计保证了低延迟和可预测性。<strong>多主机系统：</strong> CAN支持多主机系统，多个节点可以同时发送和接收数据。<strong>差分信号传输：</strong> CAN使用差分信号传输，通过两个线路（CAN_H和CAN_L）之间的电压差来传递信息。这种差分传输方式提供了良好的抗干扰性能。<strong>仲裁机制：</strong> CAN总线采用非破坏性仲裁机制，通过比较消息标识符的优先级来决定哪个节点有权继续发送数据。这种机制确保了总线上数据传输的有序性，避免了冲突。<strong>广播通信：</strong> CAN总线采用广播通信方式，即发送的数据帧可以被总线上的所有节点接收。<strong>错误检测和处理：</strong>CAN总线具有强大的错误检测和处理机制。通过CRC检查和其他错误检测手段。<strong>多种帧类型：</strong>CAN总线上的节点没有地址的概念。CAN总线上的数据是以帧为单位传输的，帧又分为数据帧、遥控帧等多种帧类型，帧包含需要传输的数据或控制信息。<strong>特定标识符</strong>：每一个帧有一个标识符（Identifier，一下简称ID）。ID不是地址，它表示传输数据的类型，也可以用于总线仲裁时确定优先级。<strong>滤波特性：</strong>每个CAN节点都接收数据，但是可以对接收的帧根据ID进行过滤。<strong>半双工：</strong>CAN总线通信时半双工的，即总线不能同时发送和接收。在多个节点竞争总线进行发送时，通过ID的优先级进行仲裁。<strong>无时钟信号：</strong>CAN总线没有用于同步的时钟信号，所以需要规定CAN总线通信的波特率，所以节点都是用同样的波特率进行通信。</li></ul></li></ul><h2 id="4-3CAN通信的重点（各种帧）"><a href="#4-3CAN通信的重点（各种帧）" class="headerlink" title="4.3CAN通信的重点（各种帧）"></a>4.3CAN通信的重点（各种帧）</h2><ul><li><p>CAN网络中通信通过5种类型的帧进行的。</p><ul><li><p>5种帧类型以及用途如下表</p><ul><li><table><thead><tr><th align="left">帧类型</th><th align="left">帧用途</th></tr></thead><tbody><tr><td align="left">数据帧（Data frame）</td><td align="left">节点发送的包含ID和数据的帧，用于发送单元向接收单元传送数据的帧。</td></tr><tr><td align="left">遥控帧（Remote frame）</td><td align="left">节点向网络上的其他节点发出的某个ID的数据请求，发送节点收到遥控帧后就可以发送相应ID的数据帧</td></tr><tr><td align="left">错误帧（Error frame）</td><td align="left">节点检测出错误时，向其他节点发送的通知错误的帧</td></tr><tr><td align="left">过载帧（Overload frame）</td><td align="left">接收单元未做好接收数据的准备时发送的帧，发送节点收到过载帧后可以暂缓发送数据帧</td></tr><tr><td align="left">帧间空间（Inter-frame space）</td><td align="left">用于将数据帧、遥控帧与前后的帧分隔开的帧</td></tr></tbody></table></li></ul></li></ul></li><li><p><strong>标准格式数据帧</strong>：由7个段构成，如下图</p><ul><li><p><img src="/./../photo/CAN%E6%95%B0%E6%8D%AE%E5%B8%A7%E6%A0%BC%E5%BC%8F.png" alt="数据帧"></p><ul><li>帧起始:一位显性电平；</li><li>仲裁段禁止ID高7位全为隐性电平；</li><li>控制段，保留位r0必须以显性电平发送。DLC表示数据段的字节数</li><li>CRC段，根据多项式生成CRC校验码</li><li>ACK段：发送方的ACK发送2个位的隐性位，接收单元ACK，在ACK位发送一个显性位，通知接收正常</li><li>帧结束：7个隐性位构成。</li></ul></li></ul></li><li><p><strong>标准遥控帧</strong>：由6段构成，图示省略</p><ul><li>跟数据帧少了一个数据段<ul><li>遥控帧的RTR位为隐性位，没有数据段</li><li>遥控帧的数据长度码DLC以请求数据帧的数据长度码表示</li></ul></li></ul></li><li><p><strong>错误帧</strong>：用于在接收和发送消息时检测出错误通知错误的帧。错误帧由错误标志和错误界定符构成。如图所示</p><ul><li><img src="/./../photo/%E9%94%99%E8%AF%AF%E5%B8%A7.png" alt="错误帧"><ul><li>主动错误标志：6 个位的显性位。</li><li>被动错误标志：6 个位的隐性位。</li><li>错误界定符由 8 个位的隐性位构成。</li></ul></li></ul></li><li><p><strong>过载帧</strong>：过载帧是用于接收单元通知其尚未完成接收准备的帧。过载帧由过载标志和过载界定符构成。</p><ul><li>过载标志：6 个位的显性位。过载标志的构成与主动错误标志的构成相同。过载界定符：8 个位的隐性位。过载界定符的构成与错误界定符的构成相同。</li></ul></li><li><p><strong>帧间隔</strong>：帧间隔是用于分隔数据帧和遥控帧的帧。数据帧和遥控帧可通过插入帧间隔将本帧与前面的任何帧（数据帧、遥控帧、错误帧、过载帧）分开。</p><ul><li>间隔：3 个位的隐性位。总线空闲：隐性电平，无长度限制（0 亦可）。本状态下，可视为总线空闲，要发送的单元可开始访问总线。延迟传送（发送暂时停止）：8 个位的隐性位。只在处于被动错误状态的单元刚发送一个消息后的帧间隔中包含的段。</li></ul></li></ul><h2 id="4-4CAN总线优先级及同步"><a href="#4-4CAN总线优先级及同步" class="headerlink" title="4.4CAN总线优先级及同步"></a>4.4CAN总线优先级及同步</h2><ul><li><p><strong>优先级决定</strong>：在总线空闲态，最先开始发送消息的单元获得发送权。多个单元同时开始发送时，各发送单元从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的单元可继续发送。</p></li><li><p><strong>数据帧和遥控帧的优先级</strong>：具有相同 ID 的数据帧和遥控帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权，可继续发送。</p></li><li><p><strong>CAN通信错误种类</strong>：如下表</p><ul><li><img src="/./../photo/CAN%E9%80%9A%E4%BF%A1%E9%94%99%E8%AF%AF.png" alt="错误表"></li></ul></li><li><p><strong>位时序</strong>：由发送单元在非同步的情况下发送的每秒钟的位数称为位速率。一个位可分为 4 段。同步段（SS）传播时间段（PTS）</p><p>相位缓冲段 1（PBS1）相位缓冲段 2（PBS2）这些段又由可称为 Time Quantum（以下称为 Tq）的最小时间单位构成。</p></li><li><p><strong>CAN通信同步的方法</strong>：CAN 协议的通信方法为 NRZ（Non-Return to Zero）方式。各个位的开头或者结尾都没有附加同步信号。发送单元以与位时序同步的方式开始发送数据。另外，接收单元根据总线上电平的变化进行同步并进行接收工作。但是，发送单元和接收单元存在的时钟频率误差及传输路径上的（电缆、驱动器等）相位延迟会引起同步偏差。因此接收单元通过硬件同步或者再同步的方法调整时序进行接收。</p></li></ul><h2 id="4-5CAN实例操作"><a href="#4-5CAN实例操作" class="headerlink" title="4.5CAN实例操作"></a>4.5CAN实例操作</h2><ul><li><p>基于stm32的CAN通信</p><ul><li><p>CAN 发送流程为：程序选择 1 个空置的邮箱（TME&#x3D;1）→设置标识符（ID），数据长度和 发送数据→设置 CAN_TIxR 的 TXRQ 位为 1，请求发送→邮箱挂号（等待成为最高优先级）→ 预定发送（等待总线空闲）→发送→邮箱空置。</p></li><li><p>CAN 接收到的有效报文，被存储在 3 级邮箱深度的 FIFO 中。CAN 接收流程为：FIFO 空→收到有效报文→挂号1（存入 FIFO 的一个邮箱，这个由硬件 控制，我们不需要理会）→收到有效报文→挂号2→收到有效报文→挂号_3→收到有效报文溢 出。</p></li><li><p>重点是构造发送的数据消息，跟接收的数据消息配置。</p></li><li><p>并且配置的时候有多种模式可选择，比如回环模式和正常模式</p></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-comment">/*HAL库配置CAN控制器,简略代码，列出关键,以CAN1为例子*/</span><br>CAN_HandleTypeDef   g_canx_handler;     <span class="hljs-comment">/* CANx句柄 */</span><br>CAN_TxHeaderTypeDef g_canx_txheader;    <span class="hljs-comment">/* 发送参数句柄 */</span><br>CAN_RxHeaderTypeDef g_canx_rxheader;    <span class="hljs-comment">/* 接收参数句柄 */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">can_init</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> tsjw, <span class="hljs-type">uint32_t</span> tbs2, <span class="hljs-type">uint32_t</span> tbs1, <span class="hljs-type">uint16_t</span> brp, <span class="hljs-type">uint32_t</span> mode)</span><br>&#123;<br>    <span class="hljs-comment">/*CAN的各种配置*/</span><br>    ...代码省略<br>    HAL_CAN_Init(&amp;g_canx_handler);<span class="hljs-comment">//HAL_CAN_Init()-&gt;内部调用HAL_CAN_MspInit()</span><br>    <span class="hljs-comment">/*配置CAN的过滤操作*/</span><br>    CAN_FilterTypeDef sFilterConfig;<br>    ...配置过程省略<br>    HAL_CAN_ConfigFilter(&amp;g_canx_handler, &amp;sFilterConfig)<br>    <br>&#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">HAL_CAN_MspInit</span><span class="hljs-params">(CAN_HandleTypeDef *hcan)</span><span class="hljs-comment">//用来配置CAN相关的引脚的状态</span><br>&#123;<br>    <span class="hljs-keyword">if</span> (CAN1 == hcan-&gt;Instance)<br>    &#123;<br>        __HAL_RCC_GPIOX_CLK_ENABLE();<br>        __HAL_RCC_CAN1_CLK_ENABLE();<br>        GPIO_InitTypeDef gpio_initure;<br>        ...具体配置省略<br>        HAL_GPIO_Init(GPIOX, &amp;gpio_initure);<br>    &#125;<br>&#125;<br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">can_send_msg</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> id, <span class="hljs-type">uint8_t</span> *msg, <span class="hljs-type">uint8_t</span> len)</span><br>&#123;<br>      <span class="hljs-type">uint32_t</span> TxMailbox = CAN_TX_MAILBOX0;<br>    <br>      g_canx_txheader.StdId = id;         <span class="hljs-comment">/* 标准标识符 */</span><br>      g_canx_txheader.ExtId = id;         <span class="hljs-comment">/* 扩展标识符(29位) 标准标识符情况下，该成员无效*/</span><br>      g_canx_txheader.IDE = CAN_ID_STD;   <span class="hljs-comment">/* 使用标准标识符 */</span><br>      g_canx_txheader.RTR = CAN_RTR_DATA; <span class="hljs-comment">/* 数据帧 */</span><br>      g_canx_txheader.DLC = len;<br><br>  <span class="hljs-keyword">if</span> (HAL_CAN_AddTxMessage(&amp;g_canx_handler, &amp;g_canx_txheader, msg, &amp;TxMailbox) != HAL_OK) <span class="hljs-comment">/* 发送消息 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">while</span> (HAL_CAN_GetTxMailboxesFreeLevel(&amp;g_canx_handler) != <span class="hljs-number">3</span>); <span class="hljs-comment">/* 等待发送完成,所有邮箱(有三个邮箱)为空 */</span><br>  <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">can_receive_msg</span><span class="hljs-params">(<span class="hljs-type">uint32_t</span> id, <span class="hljs-type">uint8_t</span> *buf)</span><br>&#123;<br>  <span class="hljs-keyword">if</span> (HAL_CAN_GetRxFifoFillLevel(&amp;g_canx_handler, CAN_RX_FIFO0) == <span class="hljs-number">0</span>)     <span class="hljs-comment">/* 没有接收到数据 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (HAL_CAN_GetRxMessage(&amp;g_canx_handler, CAN_RX_FIFO0, &amp;g_canx_rxheader, buf) != HAL_OK)  <span class="hljs-comment">/* 读取数据 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (g_canx_rxheader.StdId!= id || g_canx_rxheader.IDE != CAN_ID_STD || g_canx_rxheader.RTR != CAN_RTR_DATA)       <span class="hljs-comment">/* 接收到的ID不对 / 不是标准帧 / 不是数据帧 */</span><br>  &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;    <br>  &#125;<br><br>  <span class="hljs-keyword">return</span> g_canx_rxheader.DLC;<br>&#125;<br>/-&gt;CODEEND<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>学习总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
